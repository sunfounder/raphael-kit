.. note::

    Bonjour, bienvenue dans la communautÃ© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur FacebookÂ ! Approfondissez vos connaissances sur RaspberryÂ Pi, Arduino et ESP32 avec dâ€™autres passionnÃ©s.

    **Pourquoi rejoindreÂ ?**

    - **Support dâ€™experts**Â : RÃ©solvez les problÃ¨mes aprÃ¨sâ€‘vente et les dÃ©fis techniques avec lâ€™aide de notre communautÃ© et de notre Ã©quipe.
    - **Apprendre et partager**Â : Ã‰changez des astuces et des tutoriels pour amÃ©liorer vos compÃ©tences.
    - **AperÃ§us exclusifs**Â : AccÃ©dez en avantâ€‘premiÃ¨re aux annonces de nouveaux produits et aux aperÃ§us.
    - **RÃ©ductions spÃ©ciales**Â : Profitez de rÃ©ductions exclusives sur nos tout derniers produits.
    - **Promotions et cadeaux festifs**Â : Participez Ã  des concours et promotions spÃ©ciales pendant les fÃªtes.

    ðŸ‘‰ PrÃªt Ã  explorer et Ã  crÃ©er avec nousÂ ? Cliquez sur [|link_sf_facebook|] et rejoignezâ€‘nous dÃ¨s aujourdâ€™huiÂ !

.. _2.1.9_c_pi5_mcp3008:

2.1.9 Joystick (MCP3008)
========================

.. note::

   .. image:: ../img/mcp3008_and_adc0834.jpg
      :width: 25%
      :align: left
    

   Selon la version de votre kit, identifiez si vous disposez dâ€™un **ADC0834** ou dâ€™un **MCP3008** et suivez la section correspondante.

Introduction
------------

Dans ce projet, nous allons apprendre le fonctionnement dâ€™un joystick.  
Nous allons manipuler le joystick et afficher les rÃ©sultats Ã  lâ€™Ã©cran.

Composants requis
-----------------

Dans ce projet, nous avons besoin des composants suivantsÂ :

.. image:: ../img/image317-copy.png

Il est bien sÃ»r pratique dâ€™acheter un kit complet, voici le lienÂ :

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom
        - Ã‰LÃ‰MENTS DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez Ã©galement les acheter sÃ©parÃ©ment via les liens ciâ€‘dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DU COMPOSANT
        - LIEN Dâ€™ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_joystick`
        - \-
    *   - :ref:`cpn_mcp3008`
        - \-

SchÃ©ma de cÃ¢blage
-----------------

Lorsque les donnÃ©es du joystick sont lues, il existe certaines diffÃ©rences entre les axesÂ :  
les donnÃ©es des axes X et Y sont analogiques et nÃ©cessitent lâ€™utilisation du MCP3008 pour convertir la valeur analogique en valeur numÃ©rique.  
Les donnÃ©es de lâ€™axe Z sont numÃ©riques, donc vous pouvez directement utiliser le GPIO pour les lire, ou encore utiliser lâ€™ADC.

.. .. image:: ../img/image319.png

    *   - Nom Tâ€‘Board
        - Physique
        - WiringPi
        - BCM

    *   - SPICE0
        - pin24
        - 10
        - 8
    *   - SPIMOSI
        - pin19
        - 12
        - 10
    *   - SPIMISO
        - pin21
        - 13
        - 9
    *   - SPISCLK
        - pin23
        - 14
        - 11
    *   - GPIO22
        - pin15
        - 3
        - 22

.. image:: ../img/schematic_2.1.9_joystick_mcp3008.png

ProcÃ©dures expÃ©rimentales
-------------------------

**Ã‰tapeÂ 1Â :** Construisez le circuit.

.. image:: ../img/july24_2.1.9_joystick_mcp3008.png

**Ã‰tapeÂ 2Â :** AccÃ©dez au dossier contenant le code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/c/2.1.9-2/

**Ã‰tapeÂ 3Â :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.1.9_Joystick.c -o joystick -lwiringPi

**Ã‰tapeÂ 4Â :** ExÃ©cutez le fichier exÃ©cutable.

.. raw:: html

   <run></run>

.. code-block::

    ./joystick

AprÃ¨s lâ€™exÃ©cution du code, dÃ©placez le joystick, les valeurs correspondantes de  
x, y et Btn sâ€™affichent Ã  lâ€™Ã©cran.

.. note::

    Si cela ne fonctionne pas aprÃ¨s lâ€™exÃ©cution ou si un message dâ€™erreur apparaÃ®tÂ : Â«Â wiringPi.h: No such file or directoryÂ Â», veuillez vous rÃ©fÃ©rer Ã Â :ref:`install_wiringpi_pi5`.

Code
----

.. code-block:: c

    #include <wiringPi.h>
    #include <wiringPiSPI.h>
    #include <stdio.h>

    #define SPI_CHANNEL 0
    #define SPI_SPEED   1000000  // 1 MHz
    #define BtnPin      3        // WiringPi 3 = BCM GPIO22

    // Lecture depuis le canal MCP3008 (0â€“7)
    int read_ADC(int channel) {
        if (channel < 0 || channel > 7) return -1;

        unsigned char buffer[3];
        buffer[0] = 1;                            // Bit de dÃ©marrage
        buffer[1] = (8 + channel) << 4;           // Configuration du canal
        buffer[2] = 0;

        wiringPiSPIDataRW(SPI_CHANNEL, buffer, 3);

        int result = ((buffer[1] & 0x03) << 8) | buffer[2];
        return result;
    }

    int main(void) {
        if (wiringPiSetup() == -1) {
            printf("Ã‰chec de lâ€™initialisation de WiringPiÂ !\n");
            return 1;
        }

        if (wiringPiSPISetup(SPI_CHANNEL, SPI_SPEED) == -1) {
            printf("Ã‰chec de lâ€™initialisation du SPIÂ !\n");
            return 1;
        }

        pinMode(BtnPin, INPUT);
        pullUpDnControl(BtnPin, PUD_UP);

        while (1) {
            int x_val = read_ADC(0);     // VRX sur CH0
            int y_val = read_ADC(1);     // VRY sur CH1
            int btn_val = digitalRead(BtnPin);  // Bouton SW

            printf("x = %d, y = %d, btn = %d\n", x_val, y_val, btn_val);
            delay(100);
        }

        return 0;
    }

Explication du code
-------------------

#. Cette section initialise les bibliothÃ¨ques nÃ©cessaires pour la communication GPIO et SPI.

   .. code-block:: c

       #include <wiringPi.h>
       #include <wiringPiSPI.h>
       #include <stdio.h>

       #define SPI_CHANNEL 0
       #define SPI_SPEED   1000000  // 1 MHz
       #define BtnPin      3        // WiringPi 3 = BCM GPIO22

#. DÃ©finit une fonction ``read_ADC()`` pour lire les donnÃ©es analogiques du MCP3008. Elle communique via SPI pour demander les donnÃ©es dâ€™un canal donnÃ© (0â€“7), puis analyse la rÃ©ponse pour obtenir un rÃ©sultat ADC 10Â bits.

   .. code-block:: c

       int read_ADC(int channel) {
           if (channel < 0 || channel > 7) return -1;

           unsigned char buffer[3];
           buffer[0] = 1;
           buffer[1] = (8 + channel) << 4;
           buffer[2] = 0;

           wiringPiSPIDataRW(SPI_CHANNEL, buffer, 3);

           int result = ((buffer[1] & 0x03) << 8) | buffer[2];
           return result;
       }

#. La fonction principale initialise les interfaces WiringPi et SPI, configure la broche du bouton du joystick et lit en continu les valeurs du joystick en les affichant sur la console.

   .. code-block:: c

       int main(void) {
           if (wiringPiSetup() == -1) {
               printf("Ã‰chec de lâ€™initialisation de WiringPiÂ !\n");
               return 1;
           }

           if (wiringPiSPISetup(SPI_CHANNEL, SPI_SPEED) == -1) {
               printf("Ã‰chec de lâ€™initialisation du SPIÂ !\n");
               return 1;
           }

           pinMode(BtnPin, INPUT);
           pullUpDnControl(BtnPin, PUD_UP);

           while (1) {
               int x_val = read_ADC(0);     // VRX vers CH0
               int y_val = read_ADC(1);     // VRY vers CH1
               int btn_val = digitalRead(BtnPin);  // SW vers GPIO22

               printf("x = %d, y = %d, btn = %d\n", x_val, y_val, btn_val);
               delay(100);
           }

           return 0;
       }

#. Dans ce programmeÂ :

   - Le VRX du joystick est connectÃ© Ã  CH0 du MCP3008.
   - Le VRY est connectÃ© Ã  CH1.
   - Le bouton (SW) est connectÃ© Ã  GPIO22 (brocheÂ 3 WiringPi).
   - La fonction ``read_ADC()`` est utilisÃ©e pour lire les valeurs analogiques de VRX et VRY.
   - La valeur numÃ©rique du bouton du joystick est lue avec ``digitalRead()``.
   - Toutes les valeurs sont affichÃ©es en continu toutes les 100Â millisecondes.

