.. note::

    Bonjour, bienvenue dans la communautÃ© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur FacebookÂ ! Approfondissez vos connaissances sur RaspberryÂ Pi, Arduino et ESP32 avec dâ€™autres passionnÃ©s.

    **Pourquoi rejoindreÂ ?**

    - **Support dâ€™experts**Â : RÃ©solvez les problÃ¨mes aprÃ¨sâ€‘vente et les dÃ©fis techniques avec lâ€™aide de notre communautÃ© et de notre Ã©quipe.
    - **Apprendre et partager**Â : Ã‰changez des astuces et des tutoriels pour amÃ©liorer vos compÃ©tences.
    - **AperÃ§us exclusifs**Â : AccÃ©dez en avantâ€‘premiÃ¨re aux annonces de nouveaux produits et aux aperÃ§us.
    - **RÃ©ductions spÃ©ciales**Â : Profitez de rÃ©ductions exclusives sur nos tout derniers produits.
    - **Promotions et cadeaux festifs**Â : Participez Ã  des concours et promotions spÃ©ciales pendant les fÃªtes.

    ğŸ‘‰ PrÃªt Ã  explorer et Ã  crÃ©er avec nousÂ ? Cliquez sur [|link_sf_facebook|] et rejoignezâ€‘nous dÃ¨s aujourdâ€™huiÂ !

.. _3.1.5_c_pi5_mcp3008:

3.1.5 Indicateur de batterie (MCP3008)
======================================

.. note::

   .. image:: ../img/mcp3008_and_adc0834.jpg
      :width: 25%
      :align: left
    

   Selon la version de votre kit, identifiez si vous disposez dâ€™un **ADC0834** ou dâ€™un **MCP3008** et suivez la section correspondante.

Introduction
------------

Dans ce projet, nous allons rÃ©aliser un dispositif indicateur de batterie qui peut afficher visuellement le niveau de la batterie sur la barre Ã  LED.

.. warning::

    Nâ€™utilisez pas de composants de batterie dÃ©passant 3,3Â V afin dâ€™Ã©viter une surcharge susceptible dâ€™endommager la puce ou le RaspberryÂ Pi.

Composants requis
-----------------

Dans ce projet, nous avons besoin des composants suivants.

.. image:: ../img/list2_Battery_Indicator.png
    :align: center

Il est bien sÃ»r pratique dâ€™acheter un kit complet, voici le lienÂ : 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom
        - Ã‰LÃ‰MENTS DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez Ã©galement les acheter sÃ©parÃ©ment via les liens ciâ€‘dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DU COMPOSANT
        - LIEN Dâ€™ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_bar_graph`
        - \-
    *   - :ref:`cpn_mcp3008`
        - \-

SchÃ©ma de cÃ¢blage
-----------------

============ ======== ======== ===
Nom Tâ€‘Board  physique wiringPi BCM
SPICE0       PinÂ 24   10       8
SPIMOSI      PinÂ 19   12       10
SPIMISO      PinÂ 21   13       9
SPISCLK      PinÂ 23   14       11
GPIO25       PinÂ 22   6        25
GPIO12       PinÂ 32   26       12
GPIO16       PinÂ 36   27       16
GPIO20       PinÂ 38   28       20
GPIO21       PinÂ 40   29       21
GPIO5        PinÂ 29   21       5
GPIO6        PinÂ 31   22       6
GPIO13       PinÂ 33   23       13
GPIO19       PinÂ 35   24       19
GPIO26       PinÂ 37   25       26
============ ======== ======== ===

.. image:: ../img/schematic_battery_indicator_mcp3008.png
   :align: center

ProcÃ©dures expÃ©rimentales
-------------------------

**Ã‰tapeÂ 1Â :** Construisez le circuit.

.. image:: ../img/july24_3.1.5_battery_indicator_mcp3008.png

**Ã‰tapeÂ 2Â :** AccÃ©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/c/3.1.5-2/

**Ã‰tapeÂ 3Â :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.5_BatteryIndicator.c -lwiringPi

**Ã‰tapeÂ 4Â :** ExÃ©cutez le fichier exÃ©cutable.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

AprÃ¨s lâ€™exÃ©cution du programme, connectez sÃ©parÃ©ment le 3eÂ broche du MCP3008 et la masse (GND) aux deux pÃ´les dâ€™une batterie.  
Vous pouvez voir que la LED correspondante de la barre Ã  LED sâ€™allume pour afficher le niveau de puissance (plage de mesureÂ :Â 0Â â€“Â 5Â V).

.. note::

    Si cela ne fonctionne pas aprÃ¨s lâ€™exÃ©cution ou si un message dâ€™erreur apparaÃ®tÂ : Â«Â wiringPi.h: No such file or directoryÂ Â», veuillez vous rÃ©fÃ©rer Ã Â :ref:`install_wiringpi_pi5`.

Code
----

.. code-block:: c

    #include <wiringPi.h>
    #include <wiringPiSPI.h>
    #include <stdio.h>

    #define SPI_CHANNEL 0
    #define SPI_SPEED   1000000  // 1Â MHz
    #define VREF        3.3      

    int pins[10] = {6, 26, 27, 28, 29, 21, 22, 23, 24, 25};

    int read_ADC(int channel)
    {
        if (channel < 0 || channel > 7) return -1;

        unsigned char buffer[3];
        buffer[0] = 1;  // Bit de dÃ©marrage
        buffer[1] = (8 + channel) << 4;  // Mode entrÃ©e unique
        buffer[2] = 0;

        wiringPiSPIDataRW(SPI_CHANNEL, buffer, 3);

        int value = ((buffer[1] & 3) << 8) | buffer[2];
        return value;
    }

    void LedBarGraph(int value) {
        for (int i = 0; i < 10; i++) {
            if (i < value)
                digitalWrite(pins[i], HIGH);  
            else
                digitalWrite(pins[i], LOW);
        }
    }

    int main(void)
    {
        if (wiringPiSetup() == -1) {
            printf("Ã‰chec de lâ€™initialisation de wiringPiÂ !\n");
            return 1;
        }

        if (wiringPiSPISetup(SPI_CHANNEL, SPI_SPEED) == -1) {
            printf("Ã‰chec de la configuration SPIÂ !\n");
            return 1;
        }

        for (int i = 0; i < 10; i++) {
            pinMode(pins[i], OUTPUT);
            digitalWrite(pins[i], HIGH);
        }

        while (1) {
            int analogVal = read_ADC(0);  // MCP3008Â CH0
            if (analogVal < 0) continue;

            float voltage = analogVal * VREF / 1023.0;
            int level = analogVal * 10 / 1024;  
            if (level > 10) level = 10;  

            LedBarGraph(level);

            printf("ADCÂ ValueÂ :Â %d\tVoltageÂ :Â %.2fÂ V\tLevelÂ :Â %d\n", analogVal, voltage, level);

            delay(200);
        }

        return 0;
    }

Explication du code
-------------------

.. code-block:: c

    int read_ADC(int channel)
    {
        if (channel < 0 || channel > 7) return -1;

        unsigned char buffer[3];
        buffer[0] = 1;  // Bit de dÃ©marrage
        buffer[1] = (8 + channel) << 4;  // Mode entrÃ©e unique, CH0~CH7
        buffer[2] = 0;

        wiringPiSPIDataRW(SPI_CHANNEL, buffer, 3);

        int value = ((buffer[1] & 3) << 8) | buffer[2];  // Combine rÃ©sultat 10 bits
        return value;
    }

Cette fonction lit les valeurs analogiques du circuit intÃ©grÃ© MCP3008 via SPI.  
Le paramÃ¨tre ``channel`` sÃ©lectionne lâ€™une des 8Â entrÃ©es analogiques (CH0Â â€“Â CH7).  
Le MCP3008 retourne une valeur numÃ©rique 10Â bits comprise entre 0 etÂ 1023 reprÃ©sentant la tension analogique.

.. code-block:: c

    void LedBarGraph(int value) {
        for (int i = 0; i < 10; i++) {
            if (i < value)
                digitalWrite(pins[i], HIGH);  // Allumer LED (hypothÃ¨seÂ : cÃ¢blage actif HIGH)
            else
                digitalWrite(pins[i], LOW);   // Ã‰teindre LED
        }
    }

Cette fonction contrÃ´le un afficheur Ã  10Â LEDs.  
Chaque LED reprÃ©sente 1/10Â de la plage de tension.  
Les LED sâ€™allument dans lâ€™ordre jusquâ€™au niveau spÃ©cifiÃ©.

RemarqueÂ : Cette version suppose que les anodes des LED sont connectÃ©es aux GPIO et les cathodes Ã  la masse (actif HIGH).

.. code-block:: c

    int main(void)
    {
        if (wiringPiSetup() == -1) {
            printf("Ã‰chec de lâ€™initialisation de wiringPiÂ !\n");
            return 1;
        }

        if (wiringPiSPISetup(SPI_CHANNEL, SPI_SPEED) == -1) {
            printf("Ã‰chec de la configuration SPIÂ !\n");
            return 1;
        }

        for (int i = 0; i < 10; i++) {
            pinMode(pins[i], OUTPUT);
            digitalWrite(pins[i], HIGH);  // Initialiser toutes les LED sur ON
        }

        while (1) {
            int analogVal = read_ADC(0);  // Lecture tension sur CH0
            if (analogVal < 0) continue;

            float voltage = analogVal * VREF / 1023.0;
            int level = analogVal * 10 / 1024;  // Mise Ã  lâ€™Ã©chelle 0Â â€“Â 10Â niveaux
            if (level > 10) level = 10;

            LedBarGraph(level);  // Affichage du niveau sur les LED

            printf("ADCÂ ValueÂ :Â %d\tVoltageÂ :Â %.2fÂ V\tLevelÂ :Â %d\n", analogVal, voltage, level);

            delay(200);  // Taux de mise Ã  jourÂ :Â 5Â Hz
        }

        return 0;
    }

Logique principale du programmeÂ :

- Initialise wiringPi et la communication SPI.  
- DÃ©finit les broches GPIO comme sorties pour contrÃ´ler la barre Ã  10Â LEDs.  
- Lit en continu la tension analogique via MCP3008 (CH0).  
- Convertit la lecture en tension avec ``VREFÂ =Â 3,3Â V``.  
- Met Ã  lâ€™Ã©chelle la tension sur une barre 0Â â€“Â 10Â et allume les LED correspondantes.  
- Affiche la valeur brute de lâ€™ADC, la tension (en volts) et le niveau de LED sur la console sÃ©rie.

Ceci agit comme un indicateur visuel du niveau de batterie ou un voltmÃ¨tre analogique.
