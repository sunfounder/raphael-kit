.. note::

    Bonjour, bienvenue dans la communautÃ© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur FacebookÂ ! Approfondissez vos connaissances sur RaspberryÂ Pi, Arduino et ESP32 avec dâ€™autres passionnÃ©s.

    **Pourquoi rejoindreÂ ?**

    - **Support dâ€™experts**Â : RÃ©solvez les problÃ¨mes aprÃ¨sâ€‘vente et les dÃ©fis techniques avec lâ€™aide de notre communautÃ© et de notre Ã©quipe.
    - **Apprendre et partager**Â : Ã‰changez des astuces et des tutoriels pour amÃ©liorer vos compÃ©tences.
    - **AperÃ§us exclusifs**Â : AccÃ©dez en avantâ€‘premiÃ¨re aux annonces de nouveaux produits et aux aperÃ§us.
    - **RÃ©ductions spÃ©ciales**Â : Profitez de rÃ©ductions exclusives sur nos tout derniers produits.
    - **Promotions et cadeaux festifs**Â : Participez Ã  des concours et promotions spÃ©ciales pendant les fÃªtes.

    ðŸ‘‰ PrÃªt Ã  explorer et Ã  crÃ©er avec nousÂ ? Cliquez sur [|link_sf_facebook|] et rejoignezâ€‘nous dÃ¨s aujourdâ€™huiÂ !

.. _3.1.4_c_pi5_mcp3008:

3.1.4 Ventilateur intelligent (MCP3008)
=======================================

.. note::

   .. image:: ../img/mcp3008_and_adc0834.jpg
      :width: 25%
      :align: left
    

   Selon la version de votre kit, identifiez si vous disposez dâ€™un **ADC0834** ou dâ€™un **MCP3008** et suivez la section correspondante.

Introduction
------------

Dans ce projet, nous utiliserons des moteurs, des boutons et des thermistances pour fabriquer un ventilateur intelligent manuelÂ +Â automatique dont la vitesse de rotation est rÃ©glable.

Composants requis
-----------------

Dans ce projet, nous avons besoin des composants suivantsÂ :

.. image:: ../img/list2_Smart_Fan.png
    :align: center

Il est bien sÃ»r pratique dâ€™acheter un kit complet, voici le lienÂ :

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom
        - Ã‰LÃ‰MENTS DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez Ã©galement les acheter sÃ©parÃ©ment via les liens ciâ€‘dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DU COMPOSANT
        - LIEN Dâ€™ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_power_module`
        - \-
    *   - :ref:`cpn_thermistor`
        - |link_thermistor_buy|
    *   - :ref:`cpn_l293d`
        - \-
    *   - :ref:`cpn_mcp3008`
        - \-
    *   - :ref:`cpn_button`
        - |link_button_buy|
    *   - :ref:`cpn_motor`
        - |link_motor_buy|

SchÃ©ma de cÃ¢blage
-----------------

============ ======== ======== ===
T-Board Name physique wiringPi BCM
SPICE0       Pin 24   10       8
SPIMOSI      Pin 19   12       10
SPIMISO      Pin 21   13       9
SPISCLK      Pin 23   14       11
GPIO22       Pin 15   3        22
GPIO5        Pin 29   21       5
GPIO6        Pin 31   22       6
GPIO13       Pin 33   23       13
============ ======== ======== ===

.. image:: ../img/schematic_3.1.4_smart_fan_mcp3008.png
   :align: center

ProcÃ©dures expÃ©rimentales
-------------------------

**Ã‰tapeÂ 1Â :** Construisez le circuit.

.. image:: ../img/july24_3.1.4_smart_fan_mcp3008.png
    :align: center

.. note::
    Le module dâ€™alimentation peut utiliser une pile 9Â V avec lâ€™attache 9Â V fournie dans le kit. InsÃ©rez le cavalier du module dâ€™alimentation sur la barre 5Â V de la plaque dâ€™essai.

.. image:: ../img/image118.jpeg
    :align: center

**Ã‰tapeÂ 2Â :** AccÃ©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/c/3.1.4-2/

**Ã‰tapeÂ 3Â :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.4_SmartFan.c -o SmartFan -lwiringPi -lm

**Ã‰tapeÂ 4Â :** ExÃ©cutez le fichier exÃ©cutable.

.. raw:: html

   <run></run>

.. code-block:: 

    ./SmartFan

Lorsque le programme sâ€™exÃ©cute, dÃ©marrez le ventilateur en appuyant sur le bouton.  
Chaque pression ajuste la vitesse dâ€™un cran vers le haut ou vers le bas.  
Il y a **5Â niveaux de vitesse**Â : **0Â ~Â 4**. Lorsque la vitesse atteint le 4\ :sup:`Ã¨me` niveau et que vous appuyez Ã  nouveau sur le bouton, le ventilateur sâ€™arrÃªte (**0**).

DÃ¨s que la tempÃ©rature augmente ou diminue de plus de 2Â Â°C, la vitesse augmente ou diminue automatiquement dâ€™un cran.

.. note::

    Si cela ne fonctionne pas aprÃ¨s lâ€™exÃ©cution ou si un message dâ€™erreur apparaÃ®tÂ : Â«Â wiringPi.h: No such file or directoryÂ Â», veuillez vous rÃ©fÃ©rer Ã Â :ref:`install_wiringpi`.

Code
----

.. code-block:: c

    #include <wiringPi.h>
    #include <wiringPiSPI.h>
    #include <stdio.h>
    #include <softPwm.h>
    #include <math.h>

    #define SPI_CHANNEL 0
    #define SPI_SPEED   1000000
    #define MotorPin1   21
    #define MotorPin2   22
    #define MotorEnable 23
    #define BtnPin      3

    int read_ADC(int channel)
    {
        if (channel < 0 || channel > 7) return -1;

        unsigned char buffer[3];
        buffer[0] = 1;                      // Bit de dÃ©marrage
        buffer[1] = (8 + channel) << 4;     // Mode entrÃ©e unique et canal
        buffer[2] = 0;

        wiringPiSPIDataRW(SPI_CHANNEL, buffer, 3);

        int result = ((buffer[1] & 3) << 8) | buffer[2];
        return result;
    }

    int temperture()
    {
        int analogVal = read_ADC(0);
        double Vr = 3.3 * analogVal / 1023.0;  // RÃ©fÃ©rence de 3,3Â V
        double Rt = 10000.0 * Vr / (3.3 - Vr);
        double temp = 1 / (((log(Rt / 10000.0)) / 3950.0) + (1 / (273.15 + 25.0)));
        double cel = temp - 273.15;
        double Fah = cel * 1.8 + 32;
        printf("CelsiusÂ : %.2fÂ Â°C  FahrenheitÂ : %.2fÂ Â°F\n", cel, Fah);
        return (int)cel;
    }

    int motor(int level)
    {
        if (level == 0) {
            digitalWrite(MotorEnable, LOW);
            return 0;
        }
        if (level >= 4) {
            level = 4;
        }
        digitalWrite(MotorEnable, HIGH);
        softPwmWrite(MotorPin1, level * 25);
        return level;
    }

    void setup()
    {
        if (wiringPiSetup() == -1) {
            printf("Ã‰chec de lâ€™initialisation de wiringPiÂ !\n");
            return;
        }

        if (wiringPiSPISetup(SPI_CHANNEL, SPI_SPEED) == -1) {
            printf("Ã‰chec de lâ€™initialisation SPIÂ !\n");
            return;
        }

        softPwmCreate(MotorPin1, 0, 100);
        softPwmCreate(MotorPin2, 0, 100);
        pinMode(MotorEnable, OUTPUT);
        pinMode(BtnPin, INPUT);
    }

    int main(void)
    {
        setup();
        int currentState, lastState = 0;
        int level = 0;
        int currentTemp, markTemp = 0;

        while (1) {
            currentState = digitalRead(BtnPin);
            currentTemp = temperture();

            if (currentTemp <= 0) continue;

            if (currentState == 1 && lastState == 0) {
                level = (level + 1) % 5;
                markTemp = currentTemp;
                delay(500);
            }

            lastState = currentState;

            if (level != 0) {
                if (currentTemp - markTemp <= -2) {
                    level = level - 1;
                    markTemp = currentTemp;
                }
                if (currentTemp - markTemp >= 2) {
                    level = level + 1;
                    markTemp = currentTemp;
                }
            }

            level = motor(level);
        }

        return 0;
    }

Explication du code
-------------------

.. code-block:: c

    int read_ADC(int channel)
    {
        if (channel < 0 || channel > 7) return -1;

        unsigned char buffer[3];
        buffer[0] = 1;                      // Bit de dÃ©marrage
        buffer[1] = (8 + channel) << 4;     // Mode entrÃ©e unique et canal
        buffer[2] = 0;

        wiringPiSPIDataRW(SPI_CHANNEL, buffer, 3);

        int result = ((buffer[1] & 3) << 8) | buffer[2];
        return result;
    }

Cette fonction lit lâ€™entrÃ©e analogique du MCP3008 sur le canal spÃ©cifiÃ©.  
Elle envoie une commande SPI de 3Â octets et renvoie une valeur numÃ©rique sur 10Â bits comprise entre 0Â etÂ 1023.

.. code-block:: c

    int temperture()
    {
        int analogVal = read_ADC(0);
        double Vr = 3.3 * analogVal / 1023.0;  // RÃ©fÃ©rence de 3,3Â V
        double Rt = 10000.0 * Vr / (3.3 - Vr);
        double temp = 1 / (((log(Rt / 10000.0)) / 3950.0) + (1 / (273.15 + 25.0)));
        double cel = temp - 273.15;
        double Fah = cel * 1.8 + 32;
        printf("CelsiusÂ : %.2fÂ Â°C  FahrenheitÂ : %.2fÂ Â°F\n", cel, Fah);
        return (int)cel;
    }

La fonction ``temperture()`` lit le signal analogique du thermistor via le MCP3008,  
calcule la tension, la rÃ©sistance, puis convertit la valeur en degrÃ©s Celsius et Fahrenheit grÃ¢ce Ã  la formule du thermistor (approximation de Steinhartâ€“Hart).

.. code-block:: c

    int motor(int level)
    {
        if (level == 0) {
            digitalWrite(MotorEnable, LOW);
            return 0;
        }
        if (level >= 4) {
            level = 4;
        }
        digitalWrite(MotorEnable, HIGH);
        softPwmWrite(MotorPin1, level * 25);
        return level;
    }

La fonction ``motor()`` contrÃ´le la vitesse du ventilateur via le PWM.  
Le niveau varie deÂ 0Â Ã Â 4, oÃ¹Â 0 Ã©teint le ventilateur et chaque niveau augmente le cycle de service de 25Â %.

.. code-block:: c

    void setup()
    {
        if (wiringPiSetup() == -1) {
            printf("Ã‰chec de lâ€™initialisation de wiringPiÂ !\n");
            return;
        }

        if (wiringPiSPISetup(SPI_CHANNEL, SPI_SPEED) == -1) {
            printf("Ã‰chec de lâ€™initialisation SPIÂ !\n");
            return;
        }

        softPwmCreate(MotorPin1, 0, 100);
        softPwmCreate(MotorPin2, 0, 100);
        pinMode(MotorEnable, OUTPUT);
        pinMode(BtnPin, INPUT);
    }

La fonction ``setup()`` initialise WiringPi, configure le SPI, configure le PWM et les broches GPIO nÃ©cessaires au contrÃ´le du moteur et du bouton.

.. code-block:: c

    int main(void)
    {
        setup();
        int currentState, lastState = 0;
        int level = 0;
        int currentTemp, markTemp = 0;

        while (1) {
            currentState = digitalRead(BtnPin);
            currentTemp = temperture();

            if (currentTemp <= 0) continue;

            if (currentState == 1 && lastState == 0) {
                level = (level + 1) % 5;
                markTemp = currentTemp;
                delay(500);
            }

            lastState = currentState;

            if (level != 0) {
                if (currentTemp - markTemp <= -2) {
                    level = level - 1;
                    markTemp = currentTemp;
                }
                if (currentTemp - markTemp >= 2) {
                    level = level + 1;
                    markTemp = currentTemp;
                }
            }

            level = motor(level);
        }

        return 0;
    }

La fonction ``main()`` contient la boucle principale du programmeÂ :

1. VÃ©rifie constamment lâ€™Ã©tat du bouton et lit la tempÃ©rature actuelle.  
2. Ã€ chaque appui, le niveau de vitesse augmente (cycleÂ 0â€“4) et la tempÃ©rature de rÃ©fÃ©rence est enregistrÃ©e.  
3. Si la tempÃ©rature change deÂ Â±2Â Â°C, la vitesse sâ€™ajuste automatiquement dâ€™un cran.  
4. Appelle ``motor(level)`` pour mettre Ã  jour la sortie PWM en fonction du niveau actuel.
