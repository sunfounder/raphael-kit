.. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    ðŸ‘‰ Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _3.1.7_c_pi5:

3.1.7 Overheat Monitor
==================================

.. note::

   .. image:: ../img/mcp3008_and_adc0834.jpg
      :width: 25%
      :align: left
    

   Depending on your kit version, please identify whether you have **ADC0834** or **MCP3008** and proceed with the matching section.

Introduction
-------------------

You may want to make an overheat monitoring device that applies to
various situations, ex., in the factory, if we want to have an alarm and
the timely automatic turning off of the machine when there is a circuit
overheating. In this project, we will use thermistor, joystick, buzzer,
LED and LCD to make an smart temperature monitoring device whose
threshold is adjustable.

Required Components
------------------------------

In this project, we need the following components.

.. image:: ../img/list_Overheat_Monitor.png
    :align: center

It's definitely convenient to buy a whole kit, here's the link: 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Name	
        - ITEMS IN THIS KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

You can also buy them separately from the links below.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - COMPONENT INTRODUCTION
        - PURCHASE LINK

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_joystick`
        - \-
    *   - :ref:`cpn_adc0834`
        - \-
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|
    *   - :ref:`cpn_i2c_lcd`
        - |link_i2clcd1602_buy|
    *   - :ref:`cpn_thermistor`
        - |link_thermistor_buy|
    *   - :ref:`cpn_buzzer`
        - \-

Schematic Diagram
--------------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin15    3        22
GPIO23       Pin16    4        23
GPIO24       Pin18    5        24
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: ../img/Schematic_three_one8.png
   :align: center

Experimental Procedures
-----------------------------

**Step 1:** Build the circuit.

.. image:: ../img/image258.png

**Step 2**: Go to the folder of the code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/c/3.1.7/

**Step 3**: Compile the code.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.7_OverheatMonitor.c -lm -lwiringPi

**Step 4**: Run the executable file.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

As the code runs, the current temperature and the high-temperature
threshold **40** are displayed on **I2C LCD1602**. If the current
temperature is larger than the threshold, the buzzer and LED are started
to alarm you.

**Joystick** here is for your pressing to adjust the high-temperature
threshold. Toggling the **Joystick** in the direction of X-axis and
Y-axis can adjust (turn up or down) the current high-temperature
threshold. Press the **Joystick** once again to reset the threshold to
initial value.

.. note::

    * If there is an error prompt ``wiringPi.h: No such file or directory``, please refer to :ref:`install_wiringpi`.
    * If you get ``Unable to open I2C device: No such file or directory`` error, you need to refer to :ref:`i2c_config` to enable I2C and check if the wiring is correct.
    * If the code and wiring are fine, but the LCD still does not display content, you can turn the potentiometer on the back to increase the contrast.

**Code Explanation**

.. code-block:: c

    intÂ get_joystick_value(){
    Â Â Â Â ucharÂ x_val;
    Â Â Â Â ucharÂ y_val;
    Â Â Â Â x_valÂ =Â get_ADC_Result(1);
    Â Â Â Â y_valÂ =Â get_ADC_Result(2);
    Â Â Â Â ifÂ (x_valÂ >Â 200){
    Â Â Â Â Â Â Â Â returnÂ 1;
    Â Â Â Â }
    Â Â Â Â elseÂ if(x_valÂ <Â 50){
    Â Â Â Â Â Â Â Â returnÂ -1;
    Â Â Â Â }
    Â Â Â Â elseÂ if(y_valÂ >Â 200){
    Â Â Â Â Â Â Â Â returnÂ -10;
    Â Â Â Â }
    Â Â Â Â elseÂ if(y_valÂ <Â 50){
    Â Â Â Â Â Â Â Â returnÂ 10;
    Â Â Â Â }
    Â Â Â Â else{
    Â Â Â Â Â Â Â Â returnÂ 0;
    }
    }

This function reads values of X and Y. If ``X>200``, there will return
``1``; ``X<50``, return ``-1``; ``y>200``, return
``-10``, and ``y<50``, return ``10``.

.. code-block:: c

    voidÂ upper_tem_setting(){
    Â Â Â Â write(0,Â 0,Â "UpperÂ Adjust:");
    Â Â Â Â intÂ changeÂ =Â get_joystick_value();
    Â Â Â Â upperTemÂ =Â upperTemÂ +Â change;
    Â Â Â Â charÂ str[6];
    Â Â Â Â snprintf(str,3,"%d",upperTem);
    write(0,1,str);
    intÂ len;
    Â Â lenÂ =Â strlen(str);
    Â Â write(len,1,"Â Â Â Â Â Â Â Â Â Â Â Â Â ");
        delay(100);
    }

This function is for adjusting the threshold and displaying it on the
I2C LCD1602.

.. code-block:: c

    doubleÂ temperature(){
    Â Â Â Â unsignedÂ charÂ temp_value;
    Â Â Â Â doubleÂ Vr,Â Rt,Â temp,Â cel,Â Fah;
    Â Â Â Â temp_valueÂ =Â get_ADC_Result(0);
    Â Â Â Â VrÂ =Â 5Â *Â (double)(temp_value)Â /Â 255;
    Â Â Â Â RtÂ =Â 10000Â *Â (double)(Vr)Â /Â (5Â -Â (double)(Vr));
    Â Â Â Â tempÂ =Â 1Â /Â (((log(Rt/10000))Â /Â 3950)+(1Â /Â (273.15Â +Â 25)));
    Â Â Â Â celÂ =Â tempÂ -Â 273.15;
    Â Â Â Â FahÂ =Â celÂ *Â 1.8Â +32;
    Â Â Â Â returnÂ cel;
    }

Read the analog value of the **CH0** (thermistor) of **ADC0834** and
then convert it to temperature value.

.. code-block:: c

    voidÂ monitoring_temp(){
    Â Â Â Â charÂ str[6];
    Â Â Â Â doubleÂ celÂ =Â temperature();
    Â Â Â Â snprintf(str,6,"%.2f",cel);
    Â Â Â Â write(0,Â 0,Â "Temp:Â ");
    Â Â Â Â write(6,Â 0,Â str);
    Â Â Â Â snprintf(str,3,"%d",upperTem);
    Â Â Â Â write(0,Â 1,Â "Upper:Â ");
    Â Â Â Â write(7,Â 1,Â str);
        delay(100);
    Â Â Â Â if(celÂ >=Â upperTem){
    Â Â Â Â Â Â Â Â digitalWrite(buzzPin,Â HIGH);
    Â Â Â Â Â Â Â Â digitalWrite(LedPin,Â HIGH);
    Â Â Â Â }
    Â Â Â Â elseÂ if(celÂ <Â upperTem){
    Â Â Â Â Â Â Â Â digitalWrite(buzzPin,Â LOW);
    Â Â Â Â Â Â Â Â digitalWrite(LedPin,Â LOW);
        }
    }

As the code runs, the current temperature and the high-temperature
threshold **40** are displayed on **I2C LCD1602**. If the current
temperature is larger than the threshold, the buzzer and LED are started
to alarm you.

.. code-block:: c

    intÂ main(void)
    {
        setup();
    Â Â Â Â intÂ lastStateÂ =1;
    Â Â Â Â intÂ stage=0;
    Â Â Â Â whileÂ (1)
    Â Â Â Â {
    Â Â Â Â Â Â Â Â intÂ currentStateÂ =Â digitalRead(Joy_BtnPin);
    Â Â Â Â Â Â Â Â if(currentState==1Â &&Â lastStateÂ ==Â 0){
    Â Â Â Â Â Â Â Â Â Â Â Â stage=(stage+1)%2;
                delay(100);
                lcd_clear();
            }
    Â Â Â Â Â Â Â Â lastState=currentState;
    Â Â Â Â Â Â Â Â ifÂ (stage==1){
                upper_tem_setting();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â else{
                monitoring_temp();
        }
    Â Â Â Â }
    Â Â Â Â returnÂ 0;
    }

The function ``main()`` contains the whole program process as shown:

1) When the program starts, the initial value of **stage** is **0**, and
   the current temperature and the high-temperature threshold **40** are
   displayed on **I2C LCD1602**. If the current temperature is larger
   than the threshold, the buzzer and the LED are started to alarm you.

2) Press the Joystick, and **stage** will be **1** and you can adjust
   the high-temperature threshold. Toggling the Joystick in the
   direction of X-axis and Y-axis can adjust (turn up or down) the
   current threshold. Press the Joystick once again to reset the
   threshold to initial value.

Phenomenon Picture
-------------------------

.. image:: ../img/image259.jpeg
   :align: center