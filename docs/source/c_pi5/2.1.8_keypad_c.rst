.. note::

    隆Hola! Bienvenidos a la Comunidad de Entusiastas de SunFounder Raspberry Pi, Arduino y ESP32 en Facebook. Profundiza en Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **驴Por qu茅 unirse?**

    - **Soporte experto**: Resuelve problemas post-venta y desaf铆os t茅cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprende y comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Avances exclusivos**: Obt茅n acceso anticipado a nuevos anuncios de productos y adelantos.
    - **Descuentos especiales**: Disfruta de descuentos exclusivos en nuestros productos m谩s nuevos.
    - **Promociones festivas y sorteos**: Participa en sorteos y promociones de temporada.

     驴Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y 煤nete hoy mismo.

.. _2.1.8_c_pi5:

2.1.8 Teclado
====================

Introducci贸n
---------------

Un teclado es una matriz rectangular de botones. En este proyecto, lo utilizaremos para introducir caracteres.

Componentes necesarios
--------------------------

En este proyecto, necesitamos los siguientes componentes.

.. image:: ../img/list_2.1.5_keypad.png

Es definitivamente conveniente comprar un kit completo, aqu铆 est谩 el enlace:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre
        - ELEMENTOS EN ESTE KIT
        - ENLACE
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Tambi茅n puedes comprarlos por separado en los siguientes enlaces.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCIN DEL COMPONENTE
        - ENLACE DE COMPRA

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_keypad`
        - \-

Diagrama esquem谩tico
------------------------

.. image:: ../img/image315.png


.. image:: ../img/image316.png


Procedimientos Experimentales
--------------------------------

**Paso 1:** Construye el circuito.

.. image:: ../img/image186.png

**Paso 2:** Abre el archivo de c贸digo.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/c/2.1.8/

**Paso 3:** Compila el c贸digo.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.1.8_Keypad.cpp -lwiringPi

**Paso 4:** Ejecuta.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Despu茅s de ejecutar el c贸digo, los valores de los botones presionados
 en el teclado (button Value) se imprimir谩n en la pantalla.

.. note::

    Si no funciona despu茅s de ejecutar el c贸digo, o hay un mensaje de error: \"wiringPi.h: No such file or directory\", por favor, consulta :ref:`install_wiringpi`.

**C贸digo**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>

    #define ROWS  4 
    #define COLS  4
    #define BUTTON_NUM (ROWS * COLS)

    unsigned char KEYS[BUTTON_NUM] {  
    '1','2','3','A',
    '4','5','6','B',
    '7','8','9','C',
    '*','0','#','D'};

    unsigned char rowPins[ROWS] = {1, 4, 5, 6}; 
    unsigned char colPins[COLS] = {12, 3, 2, 0};

    void keyRead(unsigned char* result);
    bool keyCompare(unsigned char* a, unsigned char* b);
    void keyCopy(unsigned char* a, unsigned char* b);
    void keyPrint(unsigned char* a);
    void keyClear(unsigned char* a);
    int keyIndexOf(const char value);

    void init(void) {
        for(int i=0 ; i<4 ; i++) {
            pinMode(rowPins[i], OUTPUT);
            pinMode(colPins[i], INPUT);
        }
    }

    int main(void){
        unsigned char pressed_keys[BUTTON_NUM];
        unsigned char last_key_pressed[BUTTON_NUM];

        if(wiringPiSetup() == -1){ //when initialize wiring failed,print message to screen
            printf("setup wiringPi failed !");
            return 1; 
        }
        init();
        while(1){
            keyRead(pressed_keys);
            bool comp = keyCompare(pressed_keys, last_key_pressed);
            if (!comp){
                keyPrint(pressed_keys);
                keyCopy(last_key_pressed, pressed_keys);
            }
            delay(100);
        }
        return 0;  
    }

    void keyRead(unsigned char* result){
        int index;
        int count = 0;
        keyClear(result);
        for(int i=0 ; i<ROWS ; i++ ){
            digitalWrite(rowPins[i], HIGH);
            for(int j =0 ; j < COLS ; j++){
                index = i * ROWS + j;
                if(digitalRead(colPins[j]) == 1){
                    result[count]=KEYS[index];
                    count += 1;
                }
            }
            delay(1);
            digitalWrite(rowPins[i], LOW);
        }
    }

    bool keyCompare(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            if (a[i] != b[i]){
                return false;
            }
        }
        return true;
    }

    void keyCopy(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            a[i] = b[i];
        }
    }

    void keyPrint(unsigned char* a){
        if (a[0] != 0){
            printf("%c",a[0]);
        }
        for (int i=1; i<BUTTON_NUM; i++){
            if (a[i] != 0){
                printf(", %c",a[i]);
            }
        }
        printf("\n");
    }

    void keyClear(unsigned char* a){
        for (int i=0; i<BUTTON_NUM; i++){
            a[i] = 0;
        }
    }

    int keyIndexOf(const char value){
        for (int i=0; i<BUTTON_NUM; i++){
            if ((const char)KEYS[i] == value){
                return i;
            }
        }
        return -1;
    }

**Explicaci贸n del C贸digo**

.. code-block:: c

    unsigned char KEYS[BUTTON_NUM] {  
    '1','2','3','A',
    '4','5','6','B',
    '7','8','9','C',
    '*','0','#','D'};

    unsigned char rowPins[ROWS] = {1, 4, 5, 6}; 
    unsigned char colPins[COLS] = {12, 3, 2, 0};

Declara cada tecla del teclado matricial en el array ``keys[]`` y define los 
pines en cada fila y columna.

.. code-block:: c

    while(1){
            keyRead(pressed_keys);
            bool comp = keyCompare(pressed_keys, last_key_pressed);
            if (!comp){
                keyPrint(pressed_keys);
                keyCopy(last_key_pressed, pressed_keys);
            }
            delay(100);
        }

Esta es la parte de la funci贸n principal que lee e imprime el valor del bot贸n.

La funci贸n ``keyRead()`` leer谩 el estado de cada bot贸n.

``keyCompare()`` y ``keyCopy()`` se utilizan para juzgar si el estado de un 
bot贸n ha cambiado (es decir, si se ha presionado o liberado un bot贸n).

``keyPrint()`` imprimir谩 el valor del bot贸n cuyo nivel actual es alto (el bot贸n est谩 presionado).

.. code-block:: c

    void keyRead(unsigned char* result){
        int index;
        int count = 0;
        keyClear(result);
        for(int i=0 ; i<ROWS ; i++ ){
            digitalWrite(rowPins[i], HIGH);
            for(int j =0 ; j < COLS ; j++){
                index = i * ROWS + j;
                if(digitalRead(colPins[j]) == 1){
                    result[count]=KEYS[index];
                    count += 1;
                }
            }
            delay(1);
            digitalWrite(rowPins[i], LOW);
        }
    }

Esta funci贸n asigna un nivel alto a cada fila por turno, y cuando se presiona 
la tecla en la columna, la columna en la que se encuentra la tecla obtiene un 
nivel alto. Despu茅s del juicio del bucle de dos capas, la compilaci贸n del estado 
de la tecla generar谩 un array (``result[]``).

Al presionar el bot贸n 3:

.. image:: ../img/image187.png


``RowPin [0]`` escribe en el nivel alto, y colPin[2] obtiene el nivel alto. ``ColPin [0]``, 
colPin[1], colPin[3] obtienen el nivel bajo.

Esto nos da 0,0,1,0. Cuando rowPin[1], rowPin[2] y rowPin[3] se escriben en nivel alto, 
colPin[0]~colPin[4] obtendr谩n nivel bajo.

Despu茅s de que se complete el juicio del bucle, se generar谩 un array:

.. code-block:: c

    result[BUTTON_NUM] {  
    0, 0, 1, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0};

.. code-block:: c

    bool keyCompare(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            if (a[i] != b[i]){
                return false;
            }
        }
        return true;
    }

    void keyCopy(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            a[i] = b[i];
        }
    }

Estas dos funciones se utilizan para juzgar si el estado de la tecla ha cambiado, 
por ejemplo, cuando sueltas la mano al presionar '3' o presionas '2', keyCompare() 
devuelve falso.

KeyCopy() se utiliza para reescribir el valor del bot贸n actual para el array a 
(last_key_pressed[BUTTON_NUM]) despu茅s de cada comparaci贸n. As铆 podemos compararlos 
la pr贸xima vez.

.. code-block:: c

    void keyPrint(unsigned char* a){
    //printf("{");
        if (a[0] != 0){
            printf("%c",a[0]);
        }
        for (int i=1; i<BUTTON_NUM; i++){
            if (a[i] != 0){
                printf(", %c",a[i]);
            }
        }
        printf("\n");
    }

Esta funci贸n se utiliza para imprimir el valor de la tecla presionada actualmente. 
Si se presiona el bot贸n '1', se imprimir谩 '1'. Si se presionan el bot贸n '1' y el bot贸n '3', 
se imprimir谩 '1, 3'.


Imagen del Fen贸meno
----------------------------

.. image:: ../img/image188.jpeg


