.. note::

    Â¡Hola! Bienvenidos a la Comunidad de Entusiastas de SunFounder para Raspberry Pi, Arduino y ESP32 en Facebook. SumÃ©rgete mÃ¡s profundamente en Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **Â¿Por quÃ© unirse?**

    - **Soporte Experto**: Resuelve problemas post-venta y desafÃ­os tÃ©cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprender y Compartir**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Previews Exclusivos**: ObtÃ©n acceso anticipado a nuevos anuncios de productos y adelantos.
    - **Descuentos Especiales**: Disfruta de descuentos exclusivos en nuestros productos mÃ¡s nuevos.
    - **Promociones y Sorteos Festivos**: Participa en sorteos y promociones festivas.

    ğŸ‘‰ Â¿Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y Ãºnete hoy mismo.

.. _3.1.11_c_pi5:

3.1.11 JUEGO â€“ Adivina el NÃºmero
======================================

IntroducciÃ³n
------------------

Adivinar NÃºmeros es un juego de fiesta divertido donde tÃº y tus amigos se turnan 
para ingresar un nÃºmero (0~99). El rango se harÃ¡ mÃ¡s pequeÃ±o con la entrada del 
nÃºmero hasta que un jugador adivine correctamente el enigma. Entonces, el jugador 
es derrotado y castigado. Por ejemplo, si el nÃºmero de la suerte es 51, que los 
jugadores no pueden ver, y el jugador â‘  ingresa 50, el rango de nÃºmeros cambia a 
50~99; si el jugador â‘¡ ingresa 70, el rango de nÃºmeros puede ser 50~70; si el 
jugador â‘¢ ingresa 51, este jugador es el desafortunado. AquÃ­, usamos un teclado 
para ingresar nÃºmeros y una LCD para mostrar los resultados.


Componentes Requeridos
------------------------------

En este proyecto, necesitamos los siguientes componentes.

.. image:: ../img/list_GAME_Guess_Number.png
    :align: center

Es definitivamente conveniente comprar un kit completo, aquÃ­ estÃ¡ el enlace:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre
        - ELEMENTOS EN ESTE KIT
        - ENLACE
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

TambiÃ©n puedes comprarlos por separado en los siguientes enlaces.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCIÃ“N DE COMPONENTES
        - ENLACE DE COMPRA

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_keypad`
        - \-
    *   - :ref:`cpn_i2c_lcd`
        - |link_i2clcd1602_buy|

Diagrama EsquemÃ¡tico
-------------------------

============== ========== ======== =======
Nombre T-Board Pin fÃ­sico wiringPi BCM
GPIO18         Pin 12     1        18
GPIO23         Pin 16     4        23
GPIO24         Pin 18     5        24
GPIO25         Pin 22     6        25
SPIMOSI        Pin 19     12       10
GPIO22         Pin 15     3        22
GPIO27         Pin 13     2        27
GPIO17         Pin 11     0        17
SDA1           Pin 3      SDA1(8)  SDA1(2)
SCL1           Pin 5      SCL1(9)  SDA1(3)
============== ========== ======== =======

.. image:: ../img/Schematic_three_one12.png
   :align: center

Procedimientos Experimentales
---------------------------------

**Paso 1:** Construir el circuito.

.. image:: ../img/image273.png

**Paso 2**: Configurar I2C (ver ApÃ©ndice :ref:`i2c_config`. Si ya has configurado I2C, omite este paso.)

**Paso 3**: Cambiar de directorio.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/c/3.1.11/

**Paso 4**: Compilar.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.11_GAME_GuessNumber.c -lwiringPi

**Paso 5**: Ejecutar.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

DespuÃ©s de ejecutar el programa, se mostrarÃ¡ la pÃ¡gina inicial en la LCD:

.. note::

    * Si aparece un mensaje de error ``wiringPi.h: No such file or directory``, consulta :ref:`install_wiringpi`.
    * Si recibes el error ``Unable to open I2C device: No such file or directory``, consulta :ref:`i2c_config` para habilitar I2C y verificar si el cableado es correcto.
    * Si el cÃ³digo y el cableado estÃ¡n bien, pero la pantalla LCD aÃºn no muestra contenido, puedes ajustar el potenciÃ³metro en la parte posterior para aumentar el contraste.

.. code-block:: 

   Welcome!
   Press A to go!

Presiona â€˜Aâ€™, y el juego comenzarÃ¡ y la pÃ¡gina del juego aparecerÃ¡ en la LCD.

.. code-block:: 

   Enter number:
   0 â€¹pointâ€¹ 99

Cuando comienza el juego, se genera un nÃºmero aleatorio â€˜\ **point**\ â€™ pero no se 
muestra en la LCD, y lo que debes hacer es adivinarlo. El nÃºmero que has ingresado 
aparece al final de la primera lÃ­nea hasta que se complete el cÃ¡lculo final. 
(Presiona â€˜Dâ€™ para iniciar la comparaciÃ³n, y si el nÃºmero ingresado es mayor que **10**, 
la comparaciÃ³n automÃ¡tica comenzarÃ¡.)

El rango de nÃºmeros de â€˜pointâ€™ se muestra en la segunda lÃ­nea. Y debes ingresar el nÃºmero 
dentro del rango. Cuando ingresas un nÃºmero, el rango se reduce; si obtuviste el nÃºmero 
de la suerte afortunadamente o desafortunadamente, aparecerÃ¡ â€œYou've got it!â€

**ExplicaciÃ³n del CÃ³digo**

En la parte inicial del cÃ³digo se encuentran las funciones funcionales del **teclado** 
y **I2C LCD1602**. Puedes aprender mÃ¡s detalles sobre ellas en :ref:`1.1.7_c_pi5` y :ref:`2.1.8_c_pi5`.

AquÃ­, lo que necesitamos saber es lo siguiente:

.. code-block:: c

    /****************************************/
    //StartÂ fromÂ here
    /****************************************/
    voidÂ init(void){
    Â Â Â Â fdÂ =Â wiringPiI2CSetup(LCDAddr);
        lcd_init();
        lcd_clear();
    Â Â Â Â for(intÂ i=0Â ;Â i<4Â ;Â i++)Â {
    Â Â Â Â Â Â Â Â pinMode(rowPins[i],Â OUTPUT);
    Â Â Â Â Â Â Â Â pinMode(colPins[i],Â INPUT);
        }
        lcd_clear();
    Â Â Â Â write(0,Â 0,Â "Welcome!");
    Â Â Â Â write(0,Â 1,Â "PressÂ AÂ toÂ go!");
    }

Esta funciÃ³n se utiliza para definir inicialmente **I2C LCD1602** y **Keypad** 
y para mostrar â€œWelcome!â€ y â€œPress A to go!â€.

.. code-block:: c

    voidÂ init_new_value(void){
        srand(time(0));
    Â Â Â Â pointValueÂ =Â rand()%100;
    Â Â Â Â upperÂ =Â 99;
    Â Â Â Â lowerÂ =Â 0;
    Â Â Â Â countÂ =Â 0;
    Â Â Â Â printf("pointÂ isÂ %d\n",pointValue);
    }

La funciÃ³n produce el nÃºmero aleatorio â€˜\ **point**\ â€™ y restablece el rango de pista del punto.

.. code-block:: c

    boolÂ detect_point(void){
    Â Â Â Â if(countÂ >Â pointValue){
    Â Â Â Â Â Â Â Â if(countÂ <Â upper){
    Â Â Â Â Â Â Â Â Â Â Â Â upperÂ =Â count;
            }
        }
    Â Â Â Â elseÂ if(countÂ <Â pointValue){
    Â Â Â Â Â Â Â Â if(countÂ >Â lower){
    Â Â Â Â Â Â Â Â Â Â Â Â lowerÂ =Â count;
            }
        }
    Â Â Â Â elseÂ if(countÂ =Â pointValue){
    Â Â Â Â Â Â Â Â countÂ =Â 0;
    Â Â Â Â Â Â Â Â returnÂ 1;
        }
    Â Â Â Â countÂ =Â 0;
    Â Â Â Â returnÂ 0;
    }

detect_point() compara el nÃºmero ingresado con el â€œpointâ€ producido. 
Si el resultado de la comparaciÃ³n es que no son iguales, **count** 
asignarÃ¡ valores a **upper** y **lower** y devolverÃ¡ â€˜\ **0**\ â€™; 
de lo contrario, si el resultado indica que son iguales, devolverÃ¡ â€˜\ **1**\ â€™.

.. code-block:: c

    voidÂ lcd_show_input(boolÂ result){
    Â Â Â Â charÂ *str=NULL;
    Â Â Â Â strÂ =(char*)malloc(sizeof(char)*3);
        lcd_clear();
    Â Â Â Â ifÂ (resultÂ ==Â 1){
    Â Â Â Â Â Â Â Â write(0,1,"You'veÂ gotÂ it!");
            delay(5000);
            init_new_value();
            lcd_show_input(0);
            return;
        }
    Â Â Â Â write(0,0,"EnterÂ number:");
        Int2Str(str,count);
        write(13,0,str);
        Int2Str(str,lower);
        write(0,1,str);
        write(3,1,"<Point<");
        Int2Str(str,upper);
        write(12,1,str);
    }

Esta funciÃ³n se encarga de mostrar la pÃ¡gina del juego. Presta atenciÃ³n a la 
funciÃ³n **Int2Str(str,count)**, que convierte estas variables **count**, **lower** y
 **upper** de **entero** a **cadena de caracteres** para la correcta visualizaciÃ³n en **lcd**.

.. code-block:: c

    intÂ main(){
    Â Â Â Â unsignedÂ charÂ pressed_keys[BUTTON_NUM];
    Â Â Â Â unsignedÂ charÂ last_key_pressed[BUTTON_NUM];
    Â Â Â Â if(wiringPiSetup()Â ==Â -1){Â //whenÂ initializeÂ wiringÂ failed,printÂ messagetoÂ screen
    Â Â Â Â Â Â Â Â printf("setupÂ wiringPiÂ failedÂ !");
    Â Â Â Â Â Â Â Â returnÂ 1;Â 
        }
        init();
        init_new_value();
        while(1){
            keyRead(pressed_keys);
    Â Â Â Â Â Â Â Â boolÂ compÂ =Â keyCompare(pressed_keys,Â last_key_pressed);
    Â Â Â Â Â Â Â Â ifÂ (!comp){
    Â Â Â Â Â Â Â Â Â Â Â Â if(pressed_keys[0]Â !=Â 0){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â boolÂ resultÂ =Â 0;
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if(pressed_keys[0]Â ==Â 'A'){
                        init_new_value();
                        lcd_show_input(0);
                    }
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â elseÂ if(pressed_keys[0]Â ==Â 'D'){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resultÂ =Â detect_point();
                        lcd_show_input(result);
                    }
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â elseÂ if(pressed_keys[0]Â >='0'Â &&Â pressed_keys[0]Â <=Â '9'){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â countÂ =Â countÂ *Â 10;
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â countÂ =Â countÂ +Â (pressed_keys[0]Â -Â 48);
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ (count>=10){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resultÂ =Â detect_point();
                        }
                        lcd_show_input(result);
                    }
                }
    Â Â Â Â Â Â Â Â Â Â Â Â keyCopy(last_key_pressed,Â pressed_keys);
            }
            delay(100);
        }
    Â Â Â Â returnÂ 0;Â Â Â 
    }

Main() contiene todo el proceso del programa, como se muestra a continuaciÃ³n:

1) Inicializa **I2C LCD1602** y **Keypad**.

2) Usa **init_new_value()** para crear un nÃºmero aleatorio **0-99**.

3) Determina si se presiona el botÃ³n y obtiene la lectura del botÃ³n.

4) Si se presiona el botÃ³n â€˜\ **A**\ â€™, aparecerÃ¡ un nÃºmero aleatorio **0-99** y comenzarÃ¡ el juego.

5) Si se detecta que se ha presionado el botÃ³n â€˜\ **D**\ â€™, el programa entrarÃ¡ en la evaluaciÃ³n 
del resultado y mostrarÃ¡ el resultado en la LCD. Este paso ayuda a que tambiÃ©n puedas evaluar el 
resultado cuando solo presionas un nÃºmero y luego el botÃ³n â€˜\ **D**\ â€™.

6) Si se presiona el botÃ³n **0-9**, el valor de **count** cambiarÃ¡; si **count** es mayor que
 **10**, entonces comenzarÃ¡ la evaluaciÃ³n.

7) Los cambios del juego y sus valores se muestran en **LCD1602**.

Imagen del FenÃ³meno
------------------------

.. image:: ../img/image274.jpeg
   :align: center