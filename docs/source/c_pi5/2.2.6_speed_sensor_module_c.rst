.. note::

    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten.

    **Warum beitreten?**

    - **Expertenunterst√ºtzung**: L√∂sen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams.
    - **Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre F√§higkeiten zu verbessern.
    - **Exklusive Vorschauen**: Erhalten Sie fr√ºhzeitigen Zugang zu neuen Produktank√ºndigungen und exklusiven Einblicken.
    - **Spezialrabatte**: Genie√üen Sie exklusive Rabatte auf unsere neuesten Produkte.
    - **Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil.

    üëâ Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!

.. _2.2.6_c_pi5:

2.2.6 Geschwindigkeitssensormodul
=================================

Einf√ºhrung
-------------

In diesem Projekt werden wir den Gebrauch des Geschwindigkeitssensormoduls erlernen. Ein Geschwindigkeitssensormodul ist eine Art von Drehzahlmesser, der zur Messung der Geschwindigkeit eines rotierenden Objekts, wie eines Motors, verwendet wird.

Ben√∂tigte Komponenten
---------------------------

F√ºr dieses Projekt ben√∂tigen wir die folgenden Komponenten.

.. image:: ../img/2.2.6component.png
    :width: 700
    :align: center

Es ist definitiv praktisch, ein komplettes Kit zu kaufen, hier ist der Link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Name	
        - ARTIKEL IN DIESEM KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Sie k√∂nnen diese auch einzeln √ºber die untenstehenden Links kaufen.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - KOMPONENTENBESCHREIBUNG
        - KAUF LINK

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_speed_sensor`
        - \-

Schaltplan
-------------

.. image:: ../img/2.2.6circuit.png
    :width: 400
    :align: center

Experimentelle Verfahren
----------------------------

**Schritt 1:** Bauen Sie den Schaltkreis.

.. image:: ../img/2.2.6fritzing.png
    :width: 700
    :align: center

**Schritt 2:** Verzeichnis wechseln.

.. raw:: html

   <run></run>

.. code-block::
    
    cd ~/raphael-kit/c/2.2.6/

**Schritt 3:** Kompilieren.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.2.6_speed_sensor_module.c -lwiringPi

**Schritt 4:** Ausf√ºhren.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Nachdem der Code ausgef√ºhrt wurde, leuchtet die gr√ºne LED. Wenn Sie ein Hindernis in den Spalt des Geschwindigkeitssensormoduls stellen, wird "Licht blockiert" auf dem Bildschirm angezeigt und die rote LED leuchtet. Entfernen Sie das Hindernis und die gr√ºne LED leuchtet wieder.

.. note::

    Wenn es nach dem Ausf√ºhren nicht funktioniert oder eine Fehlermeldung angezeigt wird: \"wiringPi.h: Datei oder Verzeichnis nicht gefunden\", beziehen Sie sich bitte auf :ref:`install_wiringpi`.

**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>

    #define speedPin		0  
    #define Gpin		2
    #define Rpin		3

    void LED(int color)
    {
        pinMode(Gpin, OUTPUT);
        pinMode(Rpin, OUTPUT);
        if (color == 0){
            digitalWrite(Rpin, HIGH);
            digitalWrite(Gpin, LOW);
        }
        else if (color == 1){
            digitalWrite(Rpin, LOW);
            digitalWrite(Gpin, HIGH);
        }
    }

    void Print(int x){
        if ( x == 0 ){
            printf("Light was blocked\n");
        }
    }

    int main(void){

        if(wiringPiSetup() == -1){ //when initialize wiring failed,print messageto screen
            printf("setup wiringPi failed !");
            return 1; 
        }

        pinMode(speedPin, INPUT);
        int temp;
        while(1){
            //Reverse the input of speedPin
            if ( digitalRead(speedPin) == 0 ){  
                temp = 1;
            }
            if ( digitalRead(speedPin) == 1 ){
                temp = 0;
            }

            LED(temp);
            Print(temp);
        }
        return 0;
    }

**Code-Erkl√§rung**

.. code-block:: c

    void LED(int color)
    {
        pinMode(Gpin, OUTPUT);
        pinMode(Rpin, OUTPUT);
        if (color == 0){
            digitalWrite(Rpin, HIGH);
            digitalWrite(Gpin, LOW);
        }
        else if (color == 1){
            digitalWrite(Rpin, LOW);
            digitalWrite(Gpin, HIGH);
        }
    }    

Stellen Sie eine ``LED()`` Funktion bereit, um die 2 LEDs zu steuern. Der Parameter dieser Funktion ist ``color``.

Wenn ``color`` 0 ist, setzen Sie ``Rpin`` auf ``HIGH`` (schalten Sie die rote LED ein) und ``Gpin`` auf ``LOW`` (schalten Sie die gr√ºne LED aus); wenn ``color`` 1 ist, schalten Sie die gr√ºne LED ein und die rote LED aus.

.. code-block:: c

    while(1){
        //Reverse the input of speedPin
        if ( digitalRead(speedPin) == 0 ){  
            temp = 1;
        }
        if ( digitalRead(speedPin) == 1 ){
            temp = 0;
        }

        LED(temp);
        Print(temp);
    }

Wenn Sie ein Hindernis in den Spalt des Geschwindigkeitssensormoduls stellen, ist ``speedPin`` auf niedrigem Pegel (0), dann rufen Sie die ``LED(1)`` Funktion auf, um die gr√ºne LED einzuschalten, und es wird "Licht wurde blockiert!" ausgedruckt.

Ph√§nomen-Bild
--------------------

.. image:: ../img/2.2.6photo_interrrupter.JPG
   :width: 500
   :align: center