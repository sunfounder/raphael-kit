.. note::

    ¡Hola, bienvenido a la comunidad de entusiastas de SunFounder Raspberry Pi & Arduino & ESP32 en Facebook! Sumérgete más en Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **¿Por qué unirse?**

    - **Soporte experto**: Resuelve problemas postventa y desafíos técnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprender y compartir**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Previsualizaciones exclusivas**: Obtén acceso temprano a anuncios de nuevos productos y adelantos exclusivos.
    - **Descuentos especiales**: Disfruta de descuentos exclusivos en nuestros productos más nuevos.
    - **Promociones y sorteos festivos**: Participa en sorteos y promociones festivas.

    👉 ¿Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y únete hoy mismo.

.. _3.1.3_c_pi5:

3.1.3 Alarma de Reversa
================================

Introducción
----------------

En este proyecto, usaremos una pantalla LCD, un zumbador y sensores ultrasónicos 
para crear un sistema de asistencia de reversa. Podemos colocarlo en un vehículo 
controlado a distancia para simular el proceso real de reversa del coche en el garaje.

Componentes Necesarios
------------------------------

En este proyecto, necesitaremos los siguientes componentes. 

.. image:: ../img/list_Reversing_Alarm.png
    :align: center

Es definitivamente conveniente comprar un kit completo, aquí está el enlace:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre
        - ARTÍCULOS EN ESTE KIT
        - ENLACE
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

También puedes comprarlos por separado desde los enlaces a continuación.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCIÓN DEL COMPONENTE
        - ENLACE DE COMPRA

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_buzzer`
        - \-
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|
    *   - :ref:`cpn_ultrasonic_sensor`
        - |link_ultrasonic_buy|
    *   - :ref:`cpn_i2c_lcd`
        - |link_i2clcd1602_buy|
        
Diagrama Esquemático
------------------------

El sensor ultrasónico detecta la distancia entre él mismo y el obstáculo, 
que se mostrará en la pantalla LCD en forma de código. Al mismo tiempo, 
el sensor ultrasónico hace que el zumbador emita un sonido de advertencia 
de diferentes frecuencias según el valor de la distancia.

============== ======== ======== ===
Nombre T-Board física   wiringPi BCM
GPIO23         Pin 16   4        23
GPIO24         Pin 18   5        24
GPIO17         Pin 11   0        17
SDA1           Pin 3             
SCL1           Pin 5             
============== ======== ======== ===

.. image:: ../img/Schematic_three_one3.png
   :align: center

Procedimientos Experimentales
---------------------------------

**Paso 1:** Construye el circuito.

.. image:: ../img/image242.png

**Paso 2:** Cambiar directorio.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/c/3.1.3/

**Paso 3:** Compilar.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.3_ReversingAlarm.c -lwiringPi

**Paso 4:** Ejecutar.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

A medida que se ejecuta el código, el módulo de sensor ultrasónico detecta la 
distancia al obstáculo y luego muestra la información sobre la distancia en el 
LCD1602; además, el zumbador emite un tono de advertencia cuya frecuencia cambia 
con la distancia.

.. note::

    * Si aparece un mensaje de error ``wiringPi.h: No such file or directory``, consulta :ref:`install_wiringpi`.
    * Si aparece el error ``Unable to open I2C device: No such file or directory``, consulta :ref:`i2c_config` para habilitar I2C y verificar si el cableado es correcto.
    * Si el código y el cableado están bien, pero la pantalla LCD aún no muestra contenido, puedes girar el potenciómetro en la parte posterior para aumentar el contraste.

**Código**

.. note::
    Los siguientes códigos están incompletos. Si deseas ver los códigos completos,
    se sugiere usar el comando nano 3.1.1_ReversingAlarm.c.

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #include <sys/time.h>
    #include <wiringPi.h>
    #include <wiringPiI2C.h>
    #include <string.h>

    #define Trig    4
    #define Echo    5
    #define Buzzer  0

    int LCDAddr = 0x27;
    int BLEN = 1;
    int fd;

    //here is the function of LCD
    void write_word(int data){...}

    void send_command(int comm){...}

    void send_data(int data){...}

    void lcdInit(){...}

    void clear(){...}

    void write(int x, int y, char data[]){...}

    //here is the function of Ultrasonic
    void ultraInit(void){...}

    float disMeasure(void){...}

    //here is the main function
    int main(void)
    {
        float dis;
        char result[10];
        if(wiringPiSetup() == -1){ 
            printf("setup wiringPi failed !");
            return 1;
        }

        pinMode(Buzzer,OUTPUT);
        fd = wiringPiI2CSetup(LCDAddr);
        lcdInit();
        ultraInit();

        clear();
        write(0, 0, "Ultrasonic Starting"); 
        write(1, 1, "By Sunfounder");   

        while(1){
            dis = disMeasure();
            printf("%.2f cm \n",dis);
            digitalWrite(Buzzer,LOW);
            if (dis > 400){
                clear();
                write(0, 0, "Error");
                write(3, 1, "Out of range");    
                delay(500);
            }
            else
            {
                clear();
                write(0, 0, "Distance is");
                sprintf(result,"%.2f cm",dis);
                write(5, 1, result);

                if(dis>=50)
                {delay(500);}
                else if(dis<50 & dis>20) {
                    for(int i=0;i<2;i++){
                    digitalWrite(Buzzer,HIGH);
                    delay(50);
                    digitalWrite(Buzzer,LOW);
                    delay(200);
                    }
                }
                else if(dis<=20){
                    for(int i=0;i<5;i++){
                    digitalWrite(Buzzer,HIGH);
                    delay(50);
                    digitalWrite(Buzzer,LOW);
                    delay(50);
                    }
                }
            }   
        }

        return 0;
    }

**Explicación del Código**

.. code-block:: c

    pinMode(Buzzer,OUTPUT);
    fd = wiringPiI2CSetup(LCDAddr);
    lcdInit();
    ultraInit();

En este programa, aplicamos componentes anteriores de manera sintética. Aquí usamos 
zumbadores, LCD y ultrasonido. Los inicializamos de la misma manera que hicimos antes.

.. code-block:: c

    dis = disMeasure();
    printf("%.2f cm \n",dis);
    digitalWrite(Buzzer,LOW);
    if (dis > 400){
        write(0, 0, "Error");
        write(3, 1, "Out of range");    
    }
    else
    {
        write(0, 0, "Distance is");
        sprintf(result,"%.2f cm",dis);
        write(5, 1, result);
	}

Aquí obtenemos el valor del sensor ultrasónico y calculamos la distancia.

Si el valor de la distancia es mayor que el valor del rango a detectar,
se imprime un mensaje de error en el LCD. Y si el valor de la distancia está
dentro del rango, se mostrarán los resultados correspondientes.

.. code-block:: c

    sprintf(result,"%.2f cm",dis);

Dado que el modo de salida del LCD solo admite el tipo de carácter y la
variable dis almacena el valor de tipo float, necesitamos usar sprintf().
La función convierte el valor de tipo float en un carácter y lo almacena
en la variable de cadena result[]. %.2f significa mantener dos decimales.

.. code-block:: c

    if(dis>=50)
    {delay(500);}
    else if(dis<50 & dis>20) {
        for(int i=0;i<2;i++){
        digitalWrite(Buzzer,HIGH);
        delay(50);
        digitalWrite(Buzzer,LOW);
        delay(200);
        }
    }
    else if(dis<=20){
        for(int i=0;i<5;i++){
        digitalWrite(Buzzer,HIGH);
        delay(50);
        digitalWrite(Buzzer,LOW);
        delay(50);
        }
    }

Esta condición de juicio se utiliza para controlar el sonido del zumbador.
De acuerdo con la diferencia en la distancia, se puede dividir en tres
casos, en los que habrá diferentes frecuencias de sonido. Dado que
el valor total de delay es 500, todos los casos pueden proporcionar un intervalo
de 500 ms para el sensor ultrasónico.

Imagen del Fenómeno
-----------------------

.. image:: ../img/image243.jpeg
   :align: center