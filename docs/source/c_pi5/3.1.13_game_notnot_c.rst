 
.. note::

    Bonjour et bienvenue dans la Communaut√© Facebook des passionn√©s de Raspberry Pi, Arduino et ESP32 de SunFounder ! Plongez plus profond√©ment dans l'univers des Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre et partager** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits et aux aper√ßus.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos produits les plus r√©cents.
    - **Promotions festives et cadeaux** : Participez √† des cadeaux et des promotions de vacances.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez [|link_sf_facebook|] et rejoignez-nous aujourd'hui !

.. _3.1.13_c_pi5:

3.1.13 JEU ‚Äì NotNot
===========================

Introduction
-------------------

Dans ce projet, nous allons cr√©er un dispositif de jeu int√©ressant, que nous appelons "Not Not".

Pendant le jeu, la matrice de points affichera une fl√®che de mani√®re al√©atoire. Ce que vous devez faire, c'est appuyer sur le bouton dans la direction oppos√©e √† la fl√®che dans un temps limit√©. Si le temps est √©coul√© ou si vous appuyez sur le bouton dans la m√™me direction que la fl√®che, vous perdez.

Ce jeu est excellent pour exercer votre pens√©e invers√©e, alors, pourquoi ne pas essayer ?

Composants n√©cessaires
------------------------------

Pour ce projet, nous avons besoin des composants suivants.

.. image:: ../img/list_GAME_14_NotNot.png
    :align: center

Il est tr√®s pratique d'acheter un kit complet, voici le lien : 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom
        - √âL√âMENTS DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez √©galement les acheter s√©par√©ment aux liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DES COMPOSANTS
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_dot_matrix`
        - |link_led_matrix_buy|
    *   - :ref:`cpn_button`
        - |link_button_buy|

Sch√©ma de c√¢blage
------------------------

=============== ======== ======== ====
Nom de la carte Physique WiringPi BCM
GPIO22          Pin 15   3        22
GPIO23          Pin 16   4        23
SPIMOSI         Pin 19   12       MOSI
SPICE0          Pin 24   10       CE0
SPISCLK         Pin 23   14       SCLK
=============== ======== ======== ====

.. image:: ../img/Schematic_notnot.png
   :align: center

Proc√©dures exp√©rimentales
---------------------------------

**√âtape 1** : Construisez le circuit.

.. image:: ../img/3.1.14game_notnot.png

**√âtape 2** : Activez le SPI avant de commencer l'exp√©rience, consultez :ref:`spi_configuration` pour plus de d√©tails.

**√âtape 3** : Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/c/3.1.13/

**√âtape 4** : Compilez le code.

.. raw:: html

   <run></run>

.. code-block:: 

    make

**√âtape 5** : Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./3.1.13_GAME_NotNot

Apr√®s le d√©marrage du programme, une fl√®che gauche ou droite sera affich√©e al√©atoirement sur 
la matrice de points. Vous devez appuyer sur le bouton dans la direction oppos√©e √† la fl√®che, 
puis ‚Äú‚àö‚Äù appara√Æt sur la matrice de points. Si vous appuyez sur le bouton dans la m√™me direction 
que la fl√®che, vous perdez et la matrice de points affiche ‚Äúx‚Äù. Vous pouvez √©galement ajouter 2 
nouveaux boutons ou les remplacer par des touches de joystick pour les directions haut, bas, gauche 
et droite afin d'augmenter la difficult√© du jeu.

.. note::

    Si cela ne fonctionne pas apr√®s l'ex√©cution ou s'il y a un message d'erreur : "wiringPi.h: No such file or directory", veuillez consulter :ref:`install_wiringpi`.

**Explication du code**

Ce programme en C est con√ßu pour fonctionner sur un Raspberry Pi en utilisant la biblioth√®que WiringPi. Il interagit avec un √©cran de matrice LED 8x8 contr√¥l√© par le pilote MAX7219 et utilise deux boutons pour l‚Äôinteraction avec l‚Äôutilisateur. Le programme affiche al√©atoirement une fl√®che vers la gauche ou la droite sur la matrice LED, et l‚Äôutilisateur doit appuyer sur le bouton correspondant. Ensuite, il affiche une coche pour une r√©ponse correcte ou une croix pour une r√©ponse incorrecte.

#. Fichiers d'en-t√™te :

   * ``wiringPi.h`` : Fournit des fonctions pour le contr√¥le GPIO via la biblioth√®que WiringPi.
   * ``wiringPiSPI.h`` : Fournit des fonctions pour la communication SPI.
   * ``stdio.h`` : Fonctions standard d'entr√©e/sortie (``printf``, etc.).
   * ``stdlib.h`` : Fonctions de la biblioth√®que standard (``rand``, ``srand``, ``exit``).
   * ``time.h`` : Fonctions pour manipuler la date et l'heure (``time``, ``NULL``).

#. D√©finitions de types :

   * ``#define uchar unsigned char`` : D√©finit ``uchar`` comme un alias pour ``unsigned char``.
   * ``#define uint unsigned int`` : D√©finit ``uint`` comme un alias pour ``unsigned int``.

#. Constantes et macros :

   * ``SPI_CHANNEL`` : Canal SPI utilis√© pour la communication (0 ou 1).
   * ``SPI_SPEED`` : Vitesse de communication SPI fix√©e √† 1 MHz.
   * ``AButtonPin`` : Num√©ro de broche WiringPi pour le Bouton A (GPIO 22).
   * ``BButtonPin`` : Num√©ro de broche WiringPi pour le Bouton B (GPIO 23).

#. Variables globales :

   * ``int stage = 0;`` : Suit l‚Äô√©tape actuelle du jeu (affichage de la fl√®che ou du r√©sultat).

#. Tableaux de donn√©es :

   * ``uchar arrow[2][8]`` : Contient deux mod√®les de 8 octets repr√©sentant les fl√®ches droite et gauche pour la matrice LED.

     * ``arrow[0]`` : Mod√®le de fl√®che droite.
     * ``arrow[1]`` : Mod√®le de fl√®che gauche.

   * ``uchar check[2][8]`` : Contient deux mod√®les de 8 octets repr√©sentant les symboles correct (coche) et incorrect (croix).

     * ``check[0]`` : Mod√®le de symbole correct.
     * ``check[1]`` : Mod√®le de symbole incorrect.

#. Fonction ``void Delay_xms(uint x)`` :

   * Fonction enveloppe pour ``delay(x)`` fournie par WiringPi.
   * Retarde l'ex√©cution du programme de ``x`` millisecondes.

#. Fonction ``void Write_Max7219_byte(uchar DATA)`` :

   * Envoie un octet unique (``DATA``) au MAX7219 via SPI.
   * Utilise ``wiringPiSPIDataRW`` pour effectuer le transfert de donn√©es SPI.
   * ``DATA`` : L'octet de donn√©es √† envoyer.

#. Fonction ``void Write_Max7219(uchar address1, uchar dat1)`` :

   * Envoie une commande et des donn√©es au MAX7219.
   * Combine ``address1`` (adresse du registre) et ``dat1`` (donn√©es) dans un buffer et les envoie via SPI.
   * ``address1`` : Adresse du registre MAX7219.
   * ``dat1`` : Donn√©es √† √©crire dans le registre.

#. Fonction ``void Init_MAX7219()`` :

   * Initialise le pilote d'affichage MAX7219 avec les configurations n√©cessaires.
   * Configure le mode de d√©codage, l‚Äôintensit√©, la limite de balayage, le mode veille et le test d'affichage.
   * Efface les donn√©es pr√©c√©dentes sur l'affichage.

#. Fonction ``void Init_WiringPi()`` :

   * Initialise la biblioth√®que WiringPi et l'interface SPI.
   * Configure les broches des boutons en entr√©e avec des r√©sistances pull-up.
   * V√©rifie la r√©ussite de l'initialisation et quitte en cas d'√©chec.

#. Fonction ``int get_index()`` :

   * G√©n√®re un index al√©atoire (0 ou 1) pour choisir entre la fl√®che gauche et droite.
   * Retourne : ``0`` ou ``1``.

#. Fonction ``int get_key(uint num)`` :

   * Attend que l‚Äôutilisateur appuie sur un bouton et d√©termine si l‚Äôentr√©e correspond √† la fl√®che affich√©e.
   * Param√®tres :

     * ``num`` : L'index de la fl√®che affich√©e (0 pour droite, 1 pour gauche).

   * Renvoie :

     * ``1`` si l'entr√©e de l'utilisateur est correcte.
     * ``0`` si l'entr√©e de l'utilisateur est incorrecte.

   * Fonctionnalit√© :

     * Entre dans une boucle infinie v√©rifiant l'√©tat des boutons.
     * Utilise ``digitalRead`` pour d√©tecter les appuis de boutons (actif en BAS).
     * Compare le bouton press√© avec l'entr√©e attendue en fonction de ``num``.

#. Fonction ``void display(uint index)`` :

   * Affiche soit une fl√®che soit un symbole de r√©sultat sur la matrice LED en fonction de ``stage``.
   * Param√®tres :

     * ``index`` : Index pour s√©lectionner le mod√®le dans les tableaux ``arrow`` ou ``check``.

   * Fonctionnalit√© :

     * Si ``stage == 0``, affiche un mod√®le de fl√®che.
     * Si ``stage == 1``, affiche une coche ou une croix.

#. Fonction principale :

   * **Initialisation :**

     * Initialise le g√©n√©rateur de nombres al√©atoires avec ``srand((unsigned)time(NULL))``.
     * Appelle ``Init_WiringPi()`` pour configurer le GPIO et le SPI.
     * Appelle ``Init_MAX7219()`` pour initialiser l'affichage de la matrice LED.
     * Introduit un court d√©lai avec ``Delay_xms(50)``.
   
   * **Boucle du jeu (``while (1)``) :**

     * **√âtape 0 (Affichage de la fl√®che) :**

       * Appelle ``get_index()`` pour s√©lectionner al√©atoirement une direction de fl√®che.
       * Appelle ``display(direction)`` pour afficher la fl√®che sur la matrice LED.
       * D√©finit ``stage = 1`` pour passer √† l‚Äô√©tape suivante.

     * **√âtape 1 (Obtenir l‚Äôentr√©e de l‚Äôutilisateur et afficher le r√©sultat) :**

       * Appelle ``get_key(direction)`` pour attendre l'entr√©e de l‚Äôutilisateur et d√©terminer si elle est correcte.
       * Appelle ``display(key)`` pour afficher le symbole de r√©sultat (coche ou croix).
       * Attend 1 seconde avec ``Delay_xms(1000)`` pour permettre √† l‚Äôutilisateur de voir le r√©sultat.
       * D√©finit ``stage = 0`` pour red√©marrer la boucle.

**R√©sum√© du d√©roulement du programme :**

1. **Configuration :**

   * Initialiser WiringPi et SPI.
   * Configurer les broches des boutons et les param√®tres du MAX7219.
   * Initialiser le g√©n√©rateur de nombres al√©atoires.

2. **Affichage de la fl√®che :**

   * S√©lectionner al√©atoirement une direction de fl√®che (gauche ou droite).
   * Afficher la fl√®che correspondante sur la matrice LED.

3. **Interaction avec l'utilisateur :**

   * Attendre que l'utilisateur appuie sur le bouton A ou le bouton B.
   * V√©rifier si le bouton press√© correspond √† la direction de la fl√®che.

4. **Affichage du r√©sultat :**

   * Afficher une coche si la r√©ponse de l'utilisateur est correcte.
   * Afficher une croix si la r√©ponse de l'utilisateur est incorrecte.
   * Attendre 1 seconde avant la prochaine manche.

5. **R√©p√©ter :**

   * Revenir en boucle pour afficher une nouvelle fl√®che et continuer le jeu.
