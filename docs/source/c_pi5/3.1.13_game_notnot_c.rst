.. note::

    ¬°Hola! Bienvenido a la Comunidad de Entusiastas de SunFounder Raspberry Pi, Arduino y ESP32 en Facebook. Sum√©rgete en el mundo de Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **¬øPor qu√© unirse?**

    - **Soporte experto**: Resuelve problemas postventa y desaf√≠os t√©cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprender y compartir**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Vistas previas exclusivas**: Obt√©n acceso anticipado a anuncios de nuevos productos y avances.
    - **Descuentos especiales**: Disfruta de descuentos exclusivos en nuestros productos m√°s nuevos.
    - **Promociones festivas y sorteos**: Participa en sorteos y promociones navide√±as.

    üëâ ¬øListo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y √∫nete hoy mismo!

.. _3.1.13_c_pi5:

3.1.13 JUEGO‚Äì NotNot
===========================

Introducci√≥n
-------------------

En este proyecto, crearemos un dispositivo de juego interesante, y lo llamamos ‚ÄúNot Not‚Äù.

Durante el juego, la matriz de puntos mostrar√° una flecha al azar. Lo que debes hacer es presionar el bot√≥n en la direcci√≥n opuesta a la flecha dentro de un tiempo limitado. Si se acaba el tiempo o presionas el bot√≥n en la misma direcci√≥n que la flecha, est√°s fuera.

Este juego realmente puede practicar tu pensamiento inverso, ¬øte animas a intentarlo?

Componentes Requeridos
------------------------------

En este proyecto, necesitamos los siguientes componentes.

.. image:: ../img/list_GAME_14_NotNot.png
    :align: center

Es definitivamente conveniente comprar un kit completo, aqu√≠ est√° el enlace:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre	
        - ELEMENTOS EN ESTE KIT
        - ENLACE
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Tambi√©n puedes comprarlos por separado en los enlaces a continuaci√≥n.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCI√ìN DEL COMPONENTE
        - ENLACE DE COMPRA

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_dot_matrix`
        - |link_led_matrix_buy|
    *   - :ref:`cpn_button`
        - |link_button_buy|

Diagrama Esquem√°tico
--------------------------

================= ========== ======== ====
Nombre de T-Board Pin f√≠sico wiringPi BCM
GPIO22            Pin 15     3        22
GPIO23            Pin 16     4        23
SPIMOSI           Pin 19     12       MOSI
SPICE0            Pin 24     10       CE0
SPISCLK           Pin 23     14       SCLK
================= ========== ======== ====

.. image:: ../img/Schematic_notnot.png
   :align: center

Procedimientos Experimentales
---------------------------------

**Paso 1**: Construir el circuito.

.. image:: ../img/3.1.14game_notnot.png

**Paso 2**: Activa el SPI antes de comenzar el experimento, consulta :ref:`spi_configuration` para m√°s detalles.

**Paso 3**: Ve a la carpeta del c√≥digo.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/c/3.1.13/

**Paso 4**: Compila el c√≥digo.

.. raw:: html

   <run></run>

.. code-block:: 

    make

**Paso 5**: Ejecuta el archivo compilado.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./3.1.13_GAME_NotNot

Despu√©s de iniciar el programa, una flecha hacia la izquierda o hacia la derecha se 
refrescar√° al azar en la matriz de puntos. Lo que necesitas hacer es presionar el 
bot√≥n en la direcci√≥n opuesta a la flecha, entonces aparecer√° ‚Äú‚àö‚Äù en la matriz de puntos. 
Si se presiona el bot√≥n en la misma direcci√≥n que la flecha, est√°s fuera y la matriz de 
puntos mostrar√° ‚Äúx‚Äù. Tambi√©n puedes agregar 2 nuevos botones o reemplazarlos con teclas 
de joystick para arriba, abajo, izquierda y derecha‚Äî 4 direcciones para aumentar la 
dificultad del juego.

.. note::

    Si no funciona despu√©s de ejecutarlo, o aparece un mensaje de error: \"wiringPi.h: No such file or directory\", consulta :ref:`install_wiringpi`.

**Explicaci√≥n del C√≥digo**

Este programa en C est√° dise√±ado para ejecutarse en una Raspberry Pi usando la biblioteca WiringPi. Se comunica con una pantalla de matriz LED 8x8 controlada por el chip MAX7219 y usa dos botones para la interacci√≥n del usuario. El programa muestra aleatoriamente una flecha hacia la izquierda o derecha en la matriz LED, y el usuario debe presionar el bot√≥n correspondiente. Luego, muestra una marca de verificaci√≥n para una respuesta correcta o una cruz para una incorrecta.

#. Archivos de Cabecera:

   * ``wiringPi.h``: Proporciona funciones para el control de GPIO usando la biblioteca WiringPi.
   * ``wiringPiSPI.h``: Proporciona funciones para la comunicaci√≥n SPI.
   * ``stdio.h``: Funciones est√°ndar de entrada/salida (``printf``, etc.).
   * ``stdlib.h``: Funciones de biblioteca est√°ndar (``rand``, ``srand``, ``exit``).
   * ``time.h``: Funciones para manipular fecha y hora (``time``, ``NULL``).

#. Definiciones de Tipos:

   * ``#define uchar unsigned char``: Define ``uchar`` como un alias para ``unsigned char``.
   * ``#define uint unsigned int``: Define ``uint`` como un alias para ``unsigned int``.

#. Constantes y Macros:

   * ``SPI_CHANNEL``: Canal SPI usado para la comunicaci√≥n (0 o 1).
   * ``SPI_SPEED``: Velocidad de comunicaci√≥n SPI establecida en 1 MHz.
   * ``AButtonPin``: N√∫mero de pin de WiringPi para el Bot√≥n A (GPIO 22).
   * ``BButtonPin``: N√∫mero de pin de WiringPi para el Bot√≥n B (GPIO 23).

#. Variables Globales:

   * ``int stage = 0;``: Rastrea la etapa actual del juego (mostrando flecha o resultado).

#. Arreglos de Datos:

   * ``uchar arrow[2][8]``: Contiene dos patrones de 8 bytes que representan flechas hacia la derecha e izquierda para la matriz LED.

     * ``arrow[0]``: Patr√≥n de flecha hacia la derecha.
     * ``arrow[1]``: Patr√≥n de flecha hacia la izquierda.

   * ``uchar check[2][8]``: Contiene dos patrones de 8 bytes que representan s√≠mbolos de correcto (marca de verificaci√≥n) e incorrecto (cruz).

     * ``check[0]``: Patr√≥n de s√≠mbolo correcto.
     * ``check[1]``: Patr√≥n de s√≠mbolo incorrecto.

#. Funci√≥n ``void Delay_xms(uint x)``:

   * Funci√≥n de envoltura para ``delay(x)`` proporcionada por WiringPi.
   * Retrasa la ejecuci√≥n del programa por ``x`` milisegundos.

#. Funci√≥n ``void Write_Max7219_byte(uchar DATA)``:

   * Env√≠a un solo byte (``DATA``) al MAX7219 a trav√©s de SPI.
   * Usa ``wiringPiSPIDataRW`` para realizar la transferencia de datos SPI.
   * ``DATA``: El byte de datos a enviar.

#. Funci√≥n ``void Write_Max7219(uchar address1, uchar dat1)``:

   * Env√≠a un comando y datos al MAX7219.
   * Combina ``address1`` (direcci√≥n del registro) y ``dat1`` (datos) en un buffer y lo env√≠a por SPI.
   * ``address1``: Direcci√≥n del registro del MAX7219.
   * ``dat1``: Datos a escribir en el registro.

#. Funci√≥n ``void Init_MAX7219()``:

   * Inicializa el controlador de pantalla MAX7219 con las configuraciones necesarias.
   * Configura el modo de decodificaci√≥n, intensidad, l√≠mite de escaneo, modo de apagado y prueba de pantalla.
   * Borra cualquier dato anterior en la pantalla.

#. Funci√≥n ``void Init_WiringPi()``:

   * Inicializa la biblioteca WiringPi y la interfaz SPI.
   * Configura los pines de los botones como entrada con resistencias pull-up.
   * Verifica una inicializaci√≥n exitosa y sale si falla.

#. Funci√≥n ``int get_index()``:

   * Genera un √≠ndice aleatorio (0 o 1) para elegir entre la flecha izquierda o derecha.
   * Retorno: ``0`` o ``1``.

#. Funci√≥n ``int get_key(uint num)``:

   * Espera que el usuario presione un bot√≥n y determina si la entrada coincide con la flecha mostrada.
   * Par√°metros:

     * ``num``: El √≠ndice de la flecha mostrada (0 para derecha, 1 para izquierda).

   * Retorno:

     * ``1`` si la entrada del usuario es correcta.
     * ``0`` si la entrada del usuario es incorrecta.

   * Funcionalidad:

     * Entra en un bucle infinito verificando el estado de los botones.
     * Usa ``digitalRead`` para detectar pulsaciones de botones (activo en bajo).
     * Compara el bot√≥n presionado con la entrada esperada seg√∫n ``num``.

#. Funci√≥n ``void display(uint index)``:

   * Muestra en la matriz LED una flecha o un s√≠mbolo de resultado basado en la ``stage`` (etapa).
   * Par√°metros:

     * ``index``: √çndice para seleccionar el patr√≥n de los arreglos ``arrow`` o ``check``.

   * Funcionalidad:

     * Si ``stage == 0``, muestra un patr√≥n de flecha.
     * Si ``stage == 1``, muestra un s√≠mbolo de verificaci√≥n o cruz.

#. Funci√≥n Principal (Main):

   * **Inicializaci√≥n:**

     * Inicializa el generador de n√∫meros aleatorios con ``srand((unsigned)time(NULL))``.
     * Llama a ``Init_WiringPi()`` para configurar GPIO y SPI.
     * Llama a ``Init_MAX7219()`` para inicializar la pantalla de matriz LED.
     * Introduce un breve retraso con ``Delay_xms(50)``.
   
   * **Bucle del Juego (``while (1)``):**

     * **Etapa 0 (Mostrar Flecha):**

       * Llama a ``get_index()`` para seleccionar aleatoriamente una direcci√≥n de flecha.
       * Llama a ``display(direction)`` para mostrar la flecha en la matriz LED.
       * Establece ``stage = 1`` para pasar a la siguiente etapa.

     * **Etapa 1 (Obtener Entrada del Usuario y Mostrar Resultado):**

       * Llama a ``get_key(direction)`` para esperar la entrada del usuario y determinar si es correcta.
       * Llama a ``display(key)`` para mostrar el s√≠mbolo de resultado (verificaci√≥n o cruz).
       * Espera 1 segundo usando ``Delay_xms(1000)`` para permitir que el usuario vea el resultado.
       * Establece ``stage = 0`` para reiniciar el bucle.


**Resumen del Flujo del Programa:**

1. **Configuraci√≥n:**

   * Inicializa WiringPi y SPI.
   * Configura los pines de los botones y los ajustes de MAX7219.
   * Inicializa el generador de n√∫meros aleatorios.

2. **Mostrar Flecha:**

   * Selecciona aleatoriamente una direcci√≥n de flecha (izquierda o derecha).
   * Muestra la flecha correspondiente en la matriz LED.

3. **Interacci√≥n del Usuario:**

   * Espera que el usuario presione el Bot√≥n A o el Bot√≥n B.
   * Determina si el bot√≥n presionado coincide con la direcci√≥n de la flecha.

4. **Mostrar Resultado:**

   * Muestra una marca de verificaci√≥n si la entrada del usuario es correcta.
   * Muestra una cruz si la entrada del usuario es incorrecta.
   * Espera 1 segundo antes de la siguiente ronda.

5. **Repetir:**

   * Vuelve a mostrar una nueva flecha y contin√∫a el juego.
