.. note::

    Ciao, benvenuto nella Community di appassionati di SunFounder Raspberry Pi & Arduino & ESP32 su Facebook! Approfondisci Raspberry Pi, Arduino ed ESP32 insieme ad altri appassionati.

    **Perch√© unirti a noi?**

    - **Supporto esperto**: Risolvi problemi post-vendita e sfide tecniche con l'aiuto della nostra comunit√† e del nostro team.
    - **Impara e condividi**: Scambia consigli e tutorial per migliorare le tue competenze.
    - **Anteprime esclusive**: Ottieni accesso anticipato agli annunci di nuovi prodotti e alle anteprime.
    - **Sconti speciali**: Approfitta di sconti esclusivi sui nostri prodotti pi√π recenti.
    - **Promozioni festive e omaggi**: Partecipa a omaggi e promozioni festive.

    üëâ Pronto a esplorare e creare con noi? Clicca su [|link_sf_facebook|] e unisciti oggi stesso!

.. _1.1.1_c_pi5:

1.1.1 LED Lampeggiante
=========================

Introduzione
-----------------

In questo progetto, impareremo come creare un LED lampeggiante tramite la 
programmazione. Attraverso le tue impostazioni, il tuo LED potr√† produrre 
una serie di fenomeni interessanti. Andiamo, inizia subito!

Componenti necessari
------------------------------

In questo progetto, abbiamo bisogno dei seguenti componenti. 

.. image:: ../img/blinking_led_list.png
    :width: 800
    :align: center

√à sicuramente conveniente acquistare un intero kit, ecco il link: 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nome	
        - COMPONENTI IN QUESTO KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Puoi anche acquistarli separatamente dai link sottostanti.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUZIONE COMPONENTI
        - LINK PER L'ACQUISTO

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|

Schema di collegamento
---------------------------

In questo esperimento, collega una resistenza da 220Œ© all'anodo 
(il pin lungo del LED), poi collega la resistenza a 3.3V, e collega 
il catodo (il pin corto) del LED a GPIO17 del Raspberry Pi. Quindi, 
per accendere il LED, dobbiamo impostare il livello basso (0V) su GPIO17. 
Questo fenomeno pu√≤ essere ottenuto tramite la programmazione.

.. note::

    **Pin11** si riferisce all'11¬∞ pin del Raspberry Pi da sinistra a destra, 
    e i numeri di pin corrispondenti **wiringPi** e **BCM** sono mostrati nella 
    tabella seguente.

Nel contenuto relativo al linguaggio C, facciamo corrispondere GPIO0 a 0 in wiringPi. 
Nel contenuto relativo al linguaggio Python, BCM 17 √® 17 nella colonna BCM della tabella 
seguente. Allo stesso tempo, essi corrispondono all'11¬∞ pin sul Raspberry Pi, Pin 11.

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
============ ======== ======== ===

.. image:: ../img/image48.png
    :width: 800
    :align: center

Procedure sperimentali
-----------------------------

**Passo 1:** Costruisci il circuito.

.. image:: ../img/image49.png
    :width: 800
    :align: center

**Passo 2:** Vai alla cartella del codice.

1) Se utilizzi uno schermo, ti consigliamo di seguire i seguenti passaggi.

Vai su **~/** e trova la cartella **raphael-kit**.

Trova **C** nella cartella, fai clic destro su di essa e seleziona **Apri nel Terminale**.

.. image:: ../img/image50.png
    :width: 800
    :align: center

Apparir√† una finestra come mostrato di seguito. Ora sei nel percorso del 
codice **1.1.1_BlinkingLed.c** .

.. image:: ../img/image51.png
    :width: 800
    :align: center

Nei progetti successivi, useremo il comando per entrare nel file di codice 
invece di fare clic destro. Ma puoi scegliere il metodo che preferisci.


2) Se accedi al Raspberry Pi da remoto, usa ``cd`` per cambiare directory:

.. raw:: html

   <run></run>

.. code-block::

   cd ~/raphael-kit/c/1.1.1/

.. note::
    Cambia directory nel percorso del codice di questo esperimento tramite cd.

In entrambi i modi, ora ti trovi nella cartella C. Le procedure successive si 
basano su questi due metodi e sono le stesse. Andiamo avanti.

**Passo 3:** Compila il codice

.. raw:: html

   <run></run>

.. code-block::

   gcc 1.1.1_BlinkingLed.c -o BlinkingLed -lwiringPi

.. note::
    gcc √® la Collezione di Compilatori GNU. Qui, funziona come compilatore del 
    file C ``1.1.1_BlinkingLed.c`` e produce un file eseguibile.

Nel comando, ``-o`` indica l'output (il carattere subito dopo -o √® il nome del 
file generato dopo la compilazione, e qui verr√† creato un eseguibile chiamato 
``BlinkingLed``) e ``-lwiringPi`` serve a caricare la libreria wiringPi (``l`` √® 
l'abbreviazione di library).

**Passo 4:** Esegui il file eseguibile prodotto nel passaggio precedente.

.. raw:: html

   <run></run>

.. code-block::

   sudo ./BlinkingLed

.. note::

   Se non funziona dopo l'esecuzione o viene visualizzato un errore come: \"wiringPi.h: No such file or directory\", consulta :ref:`install_wiringpi_pi5`.

Per controllare il GPIO, √® necessario eseguire il programma utilizzando il 
comando ``sudo`` (superuser do). Il comando ``./`` indica la directory corrente. 
L'intero comando serve a eseguire ``BlinkingLed`` nella directory corrente.


Dopo l'esecuzione del codice, vedrai il LED lampeggiare.

Se desideri modificare il file di codice ``1.1.1_BlinkingLed.c``, interrompi il 
codice e digita il seguente comando per aprirlo:

.. raw:: html

   <run></run>

.. code-block::

   nano 1.1.1_BlinkingLed.c


Premi ``Ctrl+X`` per uscire. Se hai modificato il codice, apparir√† un prompt che 
chieder√† se salvare o meno le modifiche. Digita ``Y`` (salva) o ``N`` (non salvare). 
Quindi premi ``Invio`` per uscire. Ripeti ``Passo 3`` e ``Passo 4`` per vedere l'effetto 
dopo la modifica.

.. image:: ../img/image53.png
    :width: 800
    :align: center

**Codice**

Il codice del programma √® mostrato di seguito:

.. code-block:: c

   #include <wiringPi.h>  
   #include <stdio.h>
   #define LedPin      0
   int main(void)
   {
      // Quando l'inizializzazione di wiring fallisce, stampa un messaggio a schermo
      if(wiringPiSetup() == -1){
         printf("setup wiringPi failed !");
         return 1;
      }
      pinMode(LedPin, OUTPUT);// Imposta LedPin come uscita per scriverci il valore.
      while(1){
         // Accensione LED
         digitalWrite(LedPin, LOW);
         printf("...LED on\n");
         delay(500);
         // Spegnimento LED
         digitalWrite(LedPin, HIGH);
         printf("LED off...\n");
         delay(500);
      }
      return 0;
   }

**Spiegazione del Codice**

.. code-block:: c

   #include <wiringPi.h>

La libreria di driver hardware √® progettata per il linguaggio C di Raspberry Pi. 
Aggiungere questa libreria facilita l'inizializzazione dell'hardware e l'output 
delle porte I/O, PWM, ecc.

.. code-block:: c

   #include <stdio.h>

Libreria di I/O standard. La funzione printf utilizzata per la stampa dei dati 
sullo schermo √® realizzata tramite questa libreria. Ci sono molte altre funzioni 
utili da esplorare.

.. code-block:: c

   #define LedPin 0

Il pin GPIO17 della T_Extension Board corrisponde a GPIO0 in wiringPi. Assegna GPIO0 
a LedPin, e LedPin rappresenta GPIO0 nel codice successivo.

.. code-block:: c

   if(wiringPiSetup() == -1){
      printf("setup wiringPi fallito!");
      return 1;

Questa funzione inizializza wiringPi e presume che il programma che la chiama utilizzi 
lo schema di numerazione dei pin di wiringPi.

Questa funzione deve essere chiamata con privilegi di root. Se l'inizializzazione di 
wiring fallisce, stampa un messaggio a schermo. La funzione ``return`` viene utilizzata 
per uscire dalla funzione corrente. Usare return nella funzione ``main()`` termina il programma.

.. code-block:: c

   pinMode(LedPin, OUTPUT);

Imposta ``LedPin`` come uscita per scriverci il valore.

.. code-block:: c

   digitalWrite(LedPin, LOW);

Imposta GPIO0 a 0V (livello basso). Poich√© il catodo del LED √® collegato a GPIO0, il LED 
si accender√† se GPIO0 √® impostato su basso. Al contrario, impostando GPIO0 su livello alto, 
il LED si spegner√†.

.. code-block:: c

   printf("...LED¬†off\n");

La funzione printf √® una funzione della libreria standard e il suo prototipo si trova 
nell'header file ``stdio.h``.

La forma generale della chiamata √®: ``printf(" stringa di controllo del formato ", 
colonne della tabella di output)``. La stringa di controllo del formato √® utilizzata 
per specificare il formato dell'output, che √® suddiviso in stringa formattata e stringa 
non formattata. La stringa formattata inizia con ``%`` seguita da caratteri di formato, 
come ``%d`` per l'output intero decimale. Le stringhe non formattate vengono stampate 
come sono. Qui viene utilizzata una stringa non formattata, seguita da ``\n`` che √® un 
carattere di nuova riga, che rappresenta il ritorno a capo automatico dopo la stampa 
di una stringa.

.. code-block:: c

   delay(500);

Mantiene lo stato attuale HIGH o LOW per 500 ms.

Questa √® una funzione che sospende il programma per un certo periodo di tempo. E la 
velocit√† del programma √® determinata dal nostro hardware. Qui accendiamo o spegniamo 
il LED. Se non ci fosse la funzione di ritardo, il programma eseguirebbe molto velocemente 
l'intero ciclo in loop continuo. Quindi abbiamo bisogno della funzione di ritardo per 
aiutarci a scrivere e testare il programma.

.. code-block:: c

   return 0;

Di solito viene posizionato alla fine della funzione principale, indicando che la 
funzione restituisce 0 al termine dell'esecuzione con successo.

Immagine del Fenomeno
----------------------------

.. image:: ../img/image54.jpeg
   :width: 800
   :align: center