.. _2.1.8_py:


2.1.8 キーパッド
=================

はじめに
-------------------

キーパッドはボタンが矩形に配置された配列です。このプロジェクトでは、文字を入力するためにそれを使用します。

必要な部品
------------------------------

このプロジェクトには、以下のコンポーネントが必要です。

.. image:: ../img/list_2.1.5_keypad.png

一式をまとめて購入する方が便利です。以下がリンクです：

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - 名前
        - このキットのアイテム
        - リンク
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

以下のリンクから、個別にも購入可能です。

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - コンポーネントの紹介
        - 購入リンク
    *   - :ref:`GPIO拡張ボード`
        - |link_gpio_board_buy|
    *   - :ref:`ブレッドボード`
        - |link_breadboard_buy|
    *   - :ref:`ジャンパーワイヤー`
        - |link_wires_buy|
    *   - :ref:`抵抗器`
        - |link_resistor_buy|
    *   - :ref:`キーパッド`
        - \-

回路図
-----------------

.. image:: ../img/image315.png


.. image:: ../img/image316.png


実験手順
-----------------------

**ステップ1:** 回路を組む。

.. image:: ../img/image186.png

**ステップ2:** コードファイルを開く。

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python/

**ステップ3:** 実行。

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 2.1.8_Keypad.py

コードが実行された後、キーパッドの押されたボタンの値（ボタン値）が画面に表示されます。

**コード**

.. note::

    下記のコードは、 **修正/リセット/コピー/実行/停止** が可能です。しかし、その前に ``raphael-kit/python`` などのソースコードパスに移動する必要があります。コードを修正した後、そのまま実行して効果を確認できます。

.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    class Keypad():

        def __init__(self, rowsPins, colsPins, keys):
            self.rowsPins = rowsPins
            self.colsPins = colsPins
            self.keys = keys
            GPIO.setwarnings(False)
            GPIO.setmode(GPIO.BCM)
            GPIO.setup(self.rowsPins, GPIO.OUT, initial=GPIO.LOW)
            GPIO.setup(self.colsPins, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

        def read(self):
            pressed_keys = []
            for i, row in enumerate(self.rowsPins):
                GPIO.output(row, GPIO.HIGH)
                for j, col in enumerate(self.colsPins):
                    index = i * len(self.colsPins) + j
                    if (GPIO.input(col) == 1):
                        pressed_keys.append(self.keys[index])
                GPIO.output(row, GPIO.LOW)
            return pressed_keys

    def setup():
        global keypad, last_key_pressed
        rowsPins = [18,23,24,25]
        colsPins = [10,22,27,17]
        keys = ["1","2","3","A",
                "4","5","6","B",
                "7","8","9","C",
                "*","0","#","D"]
        keypad = Keypad(rowsPins, colsPins, keys)
        last_key_pressed = []

    def loop():
        global keypad, last_key_pressed
        pressed_keys = keypad.read()
        if len(pressed_keys) != 0 and last_key_pressed != pressed_keys:
            print(pressed_keys)
        last_key_pressed = pressed_keys
        time.sleep(0.1)

    # Define a destroy function for clean up everything after the script finished
    def destroy():
        # Release resource
        GPIO.cleanup() 

    if __name__ == '__main__':     # Program start from here
        try:
            setup()
            while True:
                loop()
        except KeyboardInterrupt:   # When 'Ctrl+C' is pressed, the program destroy() will be executed.
            destroy()

**コード説明**

.. code-block:: python

    def setup():
        global keypad, last_key_pressed
        rowsPins = [18,23,24,25]
        colsPins = [10,22,27,17]
        keys = ["1","2","3","A",
                "4","5","6","B",
                "7","8","9","C",
                "*","0","#","D"]
        keypad = Keypad(rowsPins, colsPins, keys)
        last_key_pressed = []

各行と列のピンに対応するマトリクスキーボードの各キーを配列keys[]で宣言します。

.. code-block:: python

    def loop():
        global keypad, last_key_pressed
        pressed_keys = keypad.read()
        if len(pressed_keys) != 0 and last_key_pressed != pressed_keys:
            print(pressed_keys)
        last_key_pressed = pressed_keys
        time.sleep(0.1)

この部分は、ボタンの値を読み取って出力する主要な関数の一部です。

``keyRead()`` 関数は各ボタンの状態を読み取ります。

``if len(pressed_keys) != 0`` と ``last_key_pressed != pressed_keys`` の文は、
キーが押されたかどうか、および押されたボタンの状態を判断するために使用されます（'1'を押した状態で'3'を押すと、この判断は成立します）。

条件が成立すると、現在押されているキーの値が出力されます。

``last_key_pressed = pressed_keys`` の文は、各判断の状態を配列 ``last_key_pressed`` に格納して、次の条件判断を容易にします。

.. code-block:: python

    def read(self):
            pressed_keys = []
            for i, row in enumerate(self.rowsPins):
                GPIO.output(row, GPIO.HIGH)
                for j, col in enumerate(self.colsPins):
                    index = i * len(self.colsPins) + j
                    if (GPIO.input(col) == 1):
                        pressed_keys.append(self.keys[index])
                GPIO.output(row, GPIO.LOW)
            return pressed_keys

この関数は、各行に順番に高レベルを割り当て、列内のボタンが押されたときに、そのキーが存在する列に高レベルが与えられます。二重ループの判断が終わった後、状態が1であるボタンの値は配列 ``pressed_keys`` に格納されます。

'3'キーを押した場合：

.. image:: ../img/image187.png

rowPins[0]は高レベルに設定され、colPins[2]も高レベルになります。

colPins[0]、colPins[1]、colPins[3]は低レベルになります。

4つの状態があります：0, 0, 1, 0；そして'3'を ``pressed_keys`` に書き込みます。

rowPins[1]、rowPins[2]、rowPins[3]が高レベルに設定されたとき、colPins[0] ~ colPins[4]は低レベルになります。

ループが停止し、 ``pressed_keys = '3'`` が返されます。

ボタン'1'と'3'を押すと、pressed_keys = ['1','3']が返される。

現象の画像
------------------

.. image:: ../img/image188.jpeg


