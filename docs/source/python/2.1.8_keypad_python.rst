 
.. note::

    Bonjour et bienvenue dans la Communaut√© Facebook des passionn√©s de Raspberry Pi, Arduino et ESP32 de SunFounder ! Plongez plus profond√©ment dans l'univers des Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre et partager** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits et aux aper√ßus.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos produits les plus r√©cents.
    - **Promotions festives et cadeaux** : Participez √† des cadeaux et des promotions de vacances.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez [|link_sf_facebook|] et rejoignez-nous aujourd'hui !

.. _2.1.8_py:

2.1.8 Clavier
=================

Introduction
-----------------

Un clavier est une matrice rectangulaire de boutons. Dans ce projet, nous allons l'utiliser pour saisir des caract√®res.

Composants N√©cessaires
--------------------------

Pour ce projet, nous avons besoin des composants suivants :

.. image:: ../img/list_2.1.5_keypad.png

Il est tr√®s pratique d'acheter un kit complet, voici le lien :

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom
        - √âL√âMENTS DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez √©galement les acheter s√©par√©ment via les liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DES COMPOSANTS
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_keypad`
        - \-

Sch√©ma √âlectrique
--------------------

.. image:: ../img/image315.png


.. image:: ../img/image316.png

Proc√©dures Exp√©rimentales
----------------------------

**√âtape 1 :** Construire le circuit.

.. image:: ../img/image186.png

**√âtape 2 :** Ouvrir le fichier de code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python/

**√âtape 3 :** Ex√©cuter.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 2.1.8_Keypad.py

Apr√®s l'ex√©cution du code, les valeurs des boutons press√©s sur le clavier (valeur du bouton) seront affich√©es √† l'√©cran.

**Code**

.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez acc√©der au chemin du code source comme ``raphael-kit/python``. Apr√®s avoir modifi√© le code, vous pouvez l'ex√©cuter directement pour voir l'effet.

.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    class Keypad():

        def __init__(self, rowsPins, colsPins, keys):
            self.rowsPins = rowsPins
            self.colsPins = colsPins
            self.keys = keys
            GPIO.setwarnings(False)
            GPIO.setmode(GPIO.BCM)
            GPIO.setup(self.rowsPins, GPIO.OUT, initial=GPIO.LOW)
            GPIO.setup(self.colsPins, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

        def read(self):
            pressed_keys = []
            for i, row in enumerate(self.rowsPins):
                GPIO.output(row, GPIO.HIGH)
                for j, col in enumerate(self.colsPins):
                    index = i * len(self.colsPins) + j
                    if (GPIO.input(col) == 1):
                        pressed_keys.append(self.keys[index])
                GPIO.output(row, GPIO.LOW)
            return pressed_keys

    def setup():
        global keypad, last_key_pressed
        rowsPins = [18,23,24,25]
        colsPins = [10,22,27,17]
        keys = ["1","2","3","A",
                "4","5","6","B",
                "7","8","9","C",
                "*","0","#","D"]
        keypad = Keypad(rowsPins, colsPins, keys)
        last_key_pressed = []

    def loop():
        global keypad, last_key_pressed
        pressed_keys = keypad.read()
        if len(pressed_keys) != 0 and last_key_pressed != pressed_keys:
            print(pressed_keys)
        last_key_pressed = pressed_keys
        time.sleep(0.1)

    # Define a destroy function for clean up everything after the script finished
    def destroy():
        # Release resource
        GPIO.cleanup() 

    if __name__ == '__main__':     # Program start from here
        try:
            setup()
            while True:
                loop()
        except KeyboardInterrupt:   # When 'Ctrl+C' is pressed, the program destroy() will be executed.
            destroy()

**Explication du Code**

.. code-block:: python

    def setup():
        global keypad, last_key_pressed
        rowsPins = [18,23,24,25]
        colsPins = [10,22,27,17]
        keys = ["1","2","3","A",                
                "4","5","6","B",                
                "7","8","9","C",                
                "*","0","#","D"]
        keypad = Keypad(rowsPins, colsPins, keys)
        last_key_pressed = []

D√©clarez chaque touche du clavier matriciel dans le tableau keys[] et d√©finissez les broches de 
chaque rang√©e et colonne.

.. code-block:: python

    def loop():
        global keypad, last_key_pressed
        pressed_keys = keypad.read()
        if len(pressed_keys) != 0 and last_key_pressed != pressed_keys:
            print(pressed_keys)
        last_key_pressed = pressed_keys
        time.sleep(0.1)

Voici la partie de la fonction principale qui lit et affiche la valeur du bouton.

La fonction ``keyRead()`` lira l'√©tat de chaque bouton.

Les instructions ``if len(pressed_keys) != 0`` et ``last_key_pressed != pressed_keys`` sont utilis√©es pour d√©terminer

si une touche est enfonc√©e et l'√©tat du bouton enfonc√©. (Si vous appuyez sur '3' alors que '1' est enfonc√©, le jugement est valide.)

Affiche la valeur de la touche actuellement enfonc√©e lorsque la condition est remplie.

L'instruction ``last_key_pressed = pressed_keys`` assigne l'√©tat de chaque jugement √† un tableau ``last_key_pressed`` pour faciliter le prochain jugement conditionnel.

.. code-block:: python

    def read(self):
            pressed_keys = []
            for i, row in enumerate(self.rowsPins):
                GPIO.output(row, GPIO.HIGH)
                for j, col in enumerate(self.colsPins):
                    index = i * len(self.colsPins) + j
                    if (GPIO.input(col) == 1):
                        pressed_keys.append(self.keys[index])
                GPIO.output(row, GPIO.LOW)
            return pressed_keys

Cette fonction assigne un niveau haut √† chaque rang√©e √† tour de r√¥le, et lorsque le bouton de la 
colonne est enfonc√©, la colonne dans laquelle se trouve la touche obtient un niveau haut. Apr√®s 
que la boucle √† deux niveaux a jug√©, la valeur du bouton dont l'√©tat est 1 est stock√©e dans le 
tableau ``pressed_keys``.

Si vous appuyez sur la touche '3':

.. image:: ../img/image187.png

rowPins[0] est √©crit en niveau haut, et colPins[2] obtient un niveau haut.

colPins[0], colPins[1], colPins[3] obtiennent un niveau bas.

Il y a quatre √©tats : 0, 0, 1, 0 ; et nous √©crivons '3' dans ``pressed_keys``.

Lorsque rowPins[1], rowPins[2], rowPins[3] sont √©crits en niveau haut, colPins[0] √† colPins[4] obtiennent un niveau bas.

La boucle s'arr√™te, et retourne ``pressed_keys = ‚Äò3‚Äô``.

Si vous appuyez sur les boutons '1' et '3', il retournera pressed_keys = ['1', '3'].


Image du Ph√©nom√®ne
---------------------

.. image:: ../img/image188.jpeg
