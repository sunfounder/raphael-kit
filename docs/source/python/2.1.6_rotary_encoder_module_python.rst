.. note::

    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten.

    **Warum beitreten?**

    - **Expertenunterst√ºtzung**: L√∂sen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams.
    - **Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre F√§higkeiten zu verbessern.
    - **Exklusive Vorschauen**: Erhalten Sie fr√ºhzeitigen Zugang zu neuen Produktank√ºndigungen und exklusiven Einblicken.
    - **Spezialrabatte**: Genie√üen Sie exklusive Rabatte auf unsere neuesten Produkte.
    - **Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil.

    üëâ Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!

.. _2.1.6_py:

2.1.6 Drehgebermodul
====================

Einf√ºhrung
----------

In diesem Projekt lernen Sie den Drehgeber kennen. Ein Drehgeber ist
ein elektronischer Schalter mit einer Reihe regelm√§√üiger Impulse in einer streng zeitlichen
Abfolge. In Kombination mit einem IC k√∂nnen damit Inkrement-, Dekrement-, Seitenwechsel-
und andere Operationen wie Mausscrollen, Men√ºauswahl usw. durchgef√ºhrt werden.

Ben√∂tigte Komponenten
------------------------------

F√ºr dieses Projekt ben√∂tigen wir die folgenden Komponenten.

.. image:: ../img/Part_two_25.png

Es ist definitiv praktisch, ein ganzes Kit zu kaufen, hier ist der Link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Name	
        - ARTIKEL IN DIESEM KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Sie k√∂nnen sie auch einzeln √ºber die untenstehenden Links kaufen.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - KOMPONENTENBESCHREIBUNG
        - KAUF-LINK

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_rotary_encoder`
        - |link_rotary_encoder_buy|

Schaltplan
---------------------

.. image:: ../img/image349.png
   :align: center

Experimentelle Verfahren
----------------------------

**Schritt 1:** Schalten Sie den Stromkreis.

.. image:: ../img/2.1.6_fritzing.png
   :align: center

In diesem Beispiel k√∂nnen wir den Drehgeber-Pin direkt mit dem
Raspberry Pi √ºber ein Steckbrett und ein 40-poliges Kabel verbinden, verbinden Sie GND des Drehgebers mit GND, „Äå+„Äçmit 5V, SW mit digitalem GPIO27, DT mit digitalem GPIO18 und CLK mit digitalem GPIO
17.

**Schritt 2:** √ñffnen Sie die Code-Datei.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python/

**Schritt 3:** Ausf√ºhren.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.1.6_RotaryEncoder.py

Sie werden die Z√§hlung in der Konsole sehen. Wenn Sie den Drehgeber im Uhrzeigersinn drehen, wird die Z√§hlung erh√∂ht; drehen Sie ihn gegen den Uhrzeigersinn, wird die Z√§hlung verringert. Wenn Sie den Schalter am Drehgeber dr√ºcken, wird der Z√§hlwert auf null zur√ºckgesetzt.

**Code**

.. note::

   Sie k√∂nnen den untenstehenden Code **√Ñndern/Zur√ºcksetzen/Kopieren/Ausf√ºhren/Stoppen**. Bevor Sie das tun, m√ºssen Sie zum Quellcode-Pfad wie ``raphael-kit/python`` wechseln. Nach dem √Ñndern des Codes k√∂nnen Sie ihn direkt ausf√ºhren, um das Ergebnis zu sehen.


.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   import RPi.GPIO as GPIO
   import time

   clkPin = 17    # CLK Pin
   dtPin = 18    # DT Pin
   swPin = 27    # Button Pin

   globalCounter = 0

   flag = 0
   Last_dt_Status = 0
   Current_dt_Status = 0

   def setup():
      GPIO.setmode(GPIO.BCM)       # Numbers GPIOs by physical location
      GPIO.setup(clkPin, GPIO.IN)    # input mode
      GPIO.setup(dtPin, GPIO.IN)
      GPIO.setup(swPin, GPIO.IN, pull_up_down=GPIO.PUD_UP)

   def rotaryDeal():
      global flag
      global Last_dt_Status
      global Current_dt_Status
      global globalCounter
      Last_dt_Status = GPIO.input(dtPin)
      while(not GPIO.input(clkPin)):
         Current_dt_Status = GPIO.input(dtPin)
         flag = 1
      if flag == 1:
         flag = 0
         if (Last_dt_Status == 0) and (Current_dt_Status == 1):
            globalCounter = globalCounter - 1
         if (Last_dt_Status == 1) and (Current_dt_Status == 0):
            globalCounter = globalCounter + 1

   def swISR(channel):
      global globalCounter
      globalCounter = 0

   def loop():
      global globalCounter
      tmp = 0	# Rotary Temperary

      GPIO.add_event_detect(swPin, GPIO.FALLING, callback=swISR)
      while True:
         rotaryDeal()
         if tmp != globalCounter:
            print ('globalCounter = %d' % globalCounter)
            tmp = globalCounter

   def destroy():
      GPIO.cleanup()             # Release resource

   if __name__ == '__main__':     # Program start from here
      setup()
      try:
         loop()
      except KeyboardInterrupt:  # When 'Ctrl+C' is pressed, the child program destroy() will be  executed.
         destroy()


**Code-Erkl√§rung**

* Lese den dtPin-Wert, wenn clkPin niedrig ist.
* Wenn clkPin hoch ist und dtPin von niedrig auf hoch wechselt, verringert sich der Z√§hler, ansonsten erh√∂ht sich der Z√§hler.
* swPin gibt einen niedrigen Wert aus, wenn die Welle gedr√ºckt wird.

Daraus ergibt sich der unten dargestellte Programmablauf:

.. image:: ../img/2.1.6_flow.png
   :align: center

Ph√§nomen-Bild
--------------------

.. image:: ../img/2.1.6rotary_ecoder.JPG
   :align: center