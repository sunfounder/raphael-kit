 
.. _2.1.6_py:

2.1.6 Module de Codeur Rotatif
===================================

Introduction
---------------

Dans ce projet, vous allez découvrir le module de codeur rotatif. Un codeur rotatif est un interrupteur électronique qui génère une série d'impulsions régulières dans une séquence temporelle stricte. Utilisé avec un circuit intégré (CI), il peut réaliser des opérations telles que l'incrémentation, la décrémentation, le changement de page, ainsi que d'autres opérations comme le défilement de la souris, la sélection de menu, etc.



Composants Nécessaires
-------------------------

Pour ce projet, nous avons besoin des composants suivants :

.. image:: ../img/Part_two_25.png

Il est très pratique d'acheter un kit complet, voici le lien : 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom	
        - ÉLÉMENTS DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez également les acheter séparément via les liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DES COMPOSANTS
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_rotary_encoder`
        - |link_rotary_encoder_buy|

Schéma Électrique
--------------------

.. image:: ../img/image349.png
   :align: center

Procédures Expérimentales
----------------------------

**Étape 1 :** Construire le circuit.

.. image:: ../img/2.1.6_fritzing.png
   :align: center

Dans cet exemple, nous pouvons connecter directement les broches du codeur rotatif au Raspberry Pi 
en utilisant une breadboard et un câble à 40 broches. Connectez le GND du codeur rotatif à GND, 
「+」à 5V, SW à GPIO27 digital, DT à GPIO18 digital et CLK à GPIO17 digital.

**Étape 2 :** Ouvrir le fichier de code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python/

**Étape 3 :** Exécuter.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.1.6_RotaryEncoder.py

Vous verrez le compteur dans le terminal. Lorsque vous tournez le codeur rotatif dans le sens des 
aiguilles d'une montre, le compteur augmente ; lorsque vous le tournez dans le sens inverse, 
le compteur diminue. Si vous appuyez sur l'interrupteur du codeur rotatif, les valeurs reviendront 
à zéro.

**Code**

.. note::

   Vous pouvez **Modifier/Réinitialiser/Copier/Exécuter/Arrêter** le code ci-dessous. Mais avant cela, vous devez accéder au chemin du code source comme ``raphael-kit/python``. Après avoir modifié le code, vous pouvez l'exécuter directement pour voir l'effet.


.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   import RPi.GPIO as GPIO
   import time

   clkPin = 17    # CLK Pin
   dtPin = 18    # DT Pin
   swPin = 27    # Button Pin

   globalCounter = 0

   flag = 0
   Last_dt_Status = 0
   Current_dt_Status = 0

   def setup():
      GPIO.setmode(GPIO.BCM)       # Numbers GPIOs by physical location
      GPIO.setup(clkPin, GPIO.IN)    # input mode
      GPIO.setup(dtPin, GPIO.IN)
      GPIO.setup(swPin, GPIO.IN, pull_up_down=GPIO.PUD_UP)

   def rotaryDeal():
      global flag
      global Last_dt_Status
      global Current_dt_Status
      global globalCounter
      Last_dt_Status = GPIO.input(dtPin)
      while(not GPIO.input(clkPin)):
         Current_dt_Status = GPIO.input(dtPin)
         flag = 1
      if flag == 1:
         flag = 0
         if (Last_dt_Status == 0) and (Current_dt_Status == 1):
            globalCounter = globalCounter - 1
         if (Last_dt_Status == 1) and (Current_dt_Status == 0):
            globalCounter = globalCounter + 1

   def swISR(channel):
      global globalCounter
      globalCounter = 0

   def loop():
      global globalCounter
      tmp = 0	# Rotary Temperary

      GPIO.add_event_detect(swPin, GPIO.FALLING, callback=swISR)
      while True:
         rotaryDeal()
         if tmp != globalCounter:
            print ('globalCounter = %d' % globalCounter)
            tmp = globalCounter

   def destroy():
      GPIO.cleanup()             # Release resource

   if __name__ == '__main__':     # Program start from here
      setup()
      try:
         loop()
      except KeyboardInterrupt:  # When 'Ctrl+C' is pressed, the child program destroy() will be  executed.
         destroy()


**Analyse du Code**

* Lire la valeur de dtPin lorsque clkPin est bas.
* Lorsque clkPin est haut, si dtPin passe de bas à haut, le compteur diminue, sinon il augmente.
* swPin produira une sortie basse lorsque l'axe est pressé.

À partir de cela, le flux du programme est illustré ci-dessous :


.. image:: ../img/2.1.6_flow.png
   :align: center

Image du Phénomène
------------------

.. image:: ../img/2.1.6rotary_ecoder.JPG
   :align: center