.. note::

    こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。

    **参加する理由は？**

    - **エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。
    - **学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。
    - **独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。
    - **特別割引**：最新製品の独占割引をお楽しみください。
    - **祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。

    👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！

.. _4.1.4_py:

4.1.4 自動撮影カメラ
===================================

はじめに
-----------------

外出中に、森の中の小さなリスが窓辺を訪れるかもしれません。これらの小さなかわいらしい姿を撮影して残すための自動撮影カメラを作ってみましょう！

必要な部品
------------------------------

このプロジェクトでは、以下の部品が必要です。

.. image:: ../img/3.1.18components.png
  :width: 800
  :align: center

キット全体を購入すると非常に便利です。リンクはこちらです： 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - 名前
        - このキットのアイテム
        - リンク
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

以下のリンクから個別に購入することもできます。

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - コンポーネントの紹介
        - 購入リンク

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_camera_module`
        - |link_camera_buy|
    *   - :ref:`cpn_pir`
        - \-

回路図
-----------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
============ ======== ======== ===

.. image:: ../img/1.1.18_schematic.png
   :width: 400
   :align: center

実験手順
------------------------------

このプロジェクトを始める前に、 :ref:`3.1.1_py` を完了させてください。

**ステップ1:** 回路を組み立てる。

.. image:: ../img/3.1.18fritzing.png
  :width: 800
  :align: center

**ステップ2:** カメラモジュールを接続し、設定を完了させるための参照先： :ref:`cpn_camera_module`。

**ステップ3:** Raspberry Pi のデスクトップに移動します。より良い経験のためには画面が必要です。参照先： `Raspberry Piの接続 <https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up/3>`_ 。もしくは、Raspberry Piのデスクトップにリモートでアクセスする詳しいチュートリアルは、 :ref:`remote_desktop` を参照してください。

**ステップ4:** ターミナルを開き、コードのフォルダに移動します。

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python/

**ステップ5:** 実行する。

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 4.1.4_AutomaticCaptureCamera.py

コードが実行されると、PIRは周囲の環境を検出し、リスが通過するのを感知すると、カメラが写真を撮ります。
写真の間隔は3秒で、撮影された写真の総数はプリントウィンドウを通じて表示されます。

PIRモジュールには2つのポテンショメータがあり、1つは感度を調整するためのもので、もう1つは検出距離を調整するためのものです。PIRモジュールをよりよく機能させるためには、両方を反時計回りに最後まで回す必要があります。

.. image:: ../img/PIR_TTE.png
    :width: 400
    :align: center

.. note::

   ``4.1.4_AutomaticCaptureCamera.py`` を ``~/raphael-kit/python/`` のパスでPythonのIDEで開き、Runボタンをクリックして実行し、Stopボタンでコードを停止することもできます。

**コード**

.. note::
    以下のコードは **変更/リセット/コピー/実行/停止** が可能です。しかし、それを行う前に、 ``raphael-kit/python`` のようなソースコードのパスに移動する必要があります。コードを変更した後、その効果を直接確認するためにそれを実行することができます。

.. raw:: html

    <run></run>

.. code-block:: python

    #!/usr/bin/env python3
    import time
    import os
    import RPi.GPIO as GPIO
    from picamera2 import Picamera2

    # ----------------------------
    # USER DIRECTORY
    # ----------------------------
    user = os.getlogin()
    user_home = os.path.expanduser(f'~{user}')

    # ----------------------------
    # GPIO SETUP
    # ----------------------------
    PIR_PIN = 17  # PIR motion sensor connected to GPIO17

    GPIO.setmode(GPIO.BCM)
    GPIO.setup(PIR_PIN, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

    # ----------------------------
    # CAMERA SETUP
    # ----------------------------
    camera = Picamera2()
    camera.start()

    print("Motion detection started. Press Ctrl+C to exit.")

    # ----------------------------
    # MAIN LOOP
    # ----------------------------
    try:
        i = 1
        while True:
            if GPIO.input(PIR_PIN) == GPIO.HIGH:
                filename = f"{user_home}/capture{i}.jpg"
                camera.capture_file(filename)
                print(f"Motion detected. Saved image #{i}: {filename}")
                time.sleep(3)
                i += 1
            else:
                print("waiting")
                time.sleep(0.5)

    # ----------------------------
    # KEYBOARD INTERRUPT
    # ----------------------------
    except KeyboardInterrupt:
        print("\nKeyboard interrupt received. Exiting program...")

    # ----------------------------
    # CLEANUP
    # ----------------------------
    finally:
        try:
            camera.close()
        except:
            pass

        GPIO.cleanup()
        print("Program exited cleanly.")

**コード説明**

#. 現在のユーザーのホームディレクトリを取得し、撮影した画像の保存先として使用します。

   .. code-block:: python

       user = os.getlogin()
       user_home = os.path.expanduser(f'~{user}')

   これにより、アクティブユーザー名を取得し、ホームディレクトリへの完全パスを生成します。

#. GPIO を設定し、PIR モーションセンサーを ``GPIO17`` に入力として構成します。

   .. code-block:: python

       PIR_PIN = 17
       GPIO.setmode(GPIO.BCM)
       GPIO.setup(PIR_PIN, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

   プルダウン抵抗を使用することで、動きが検出されていないときはピンが ``LOW`` を読み取るようになります。

#. Picamera2 インスタンスを初期化し、カメラを起動します。

   .. code-block:: python

       camera = Picamera2()
       camera.start()

   カメラを起動しておくことで、動作検知時にすぐ撮影できる状態になります。

#. PIR センサーの入力状態を読み取り、動きを検出します。

   .. code-block:: python

       if GPIO.input(PIR_PIN) == GPIO.HIGH:

   PIR が動きを検知すると ``HIGH`` を出力し、撮影処理がトリガーされます。

#. 画像を撮影し、連番ファイル名で保存します。

   .. code-block:: python

       filename = f"{user_home}/capture{i}.jpg"
       camera.capture_file(filename)

   動きを検出するたびに ``capture1.jpg``、  ``capture2.jpg`` …というように連番で保存されます。

#. 動作検知後、3 秒間の遅延を入れます。

   .. code-block:: python

       time.sleep(3)

   これにより、1 回の動作で短時間に多数の画像が撮影されるのを防ぎます。

#. 動作が検知されない場合は「waiting」と表示し、少し待ってから再チェックします。

   .. code-block:: python

       else:
           print("waiting")
           time.sleep(0.5)

   これにより CPU 負荷を抑えながら、継続的な監視を実現します。

#. キーボード割り込み（Ctrl+C）を処理して安全に終了します。

   .. code-block:: python

       except KeyboardInterrupt:
           print("\nKeyboard interrupt received. Exiting program...")

   ユーザーが手動でプログラムを停止した際に、終了メッセージを表示します。

#. 終了前にカメラと GPIO リソースを解放します。

   .. code-block:: python

       finally:
           camera.close()
           GPIO.cleanup()

   これにより、カメラは正しくシャットダウンされ、GPIO ピンも安全な状態に戻されます。

現象の画像
------------------------

.. image:: ../img/4.1.4spycamera.JPG
   :align: center
