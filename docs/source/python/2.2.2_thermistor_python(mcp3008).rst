.. note::

    こんにちは、SunFounder Raspberry Pi & Arduino & ESP32 愛好者コミュニティ (Facebook) へようこそ！  
    Raspberry Pi、Arduino、ESP32 を仲間と共にさらに深く学びましょう。

    **参加する理由**

    - **専門サポート**: 購入後の問題や技術的な課題をコミュニティとチームで解決  
    - **学びと共有**: ヒントやチュートリアルを交換し、スキルを向上  
    - **限定プレビュー**: 新製品発表や先行情報に早期アクセス  
    - **特別割引**: 新製品を特別価格で購入可能  
    - **イベントとプレゼント企画**: プレゼントや季節ごとのキャンペーンに参加  

    👉 一緒に探求し、創造しましょう。今すぐ [|link_sf_facebook|] をクリックして参加！

.. _2.2.2_py_mcp3008:

2.2.2 サーミスタ (MCP3008)
===========================

.. note::

   .. image:: ../img/mcp3008_and_adc0834.jpg
      :width: 25%
      :align: left
    

   キットのバージョンにより **ADC0834** または **MCP3008** が含まれています。自分のキットに対応するセクションに従ってください。

概要
----

フォトレジスタが光を検出できるのと同様に、サーミスタは温度に応じて抵抗値が変化する電子部品です。  
これを利用して温度制御や熱警報などの機能を実現できます。

必要な部品
----------

このプロジェクトで必要な部品は以下の通りです。

.. image:: ../img/list2_2.2.2_thermistor.png

キット一式を購入するのが便利です。リンクはこちら：

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - 名前
        - キット内の部品数
        - リンク
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

個別購入する場合は以下のリンクを参照してください。

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - 部品名
        - 購入リンク

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_thermistor`
        - |link_thermistor_buy|
    *   - :ref:`cpn_mcp3008`
        - \-

回路図
------

.. image:: ../img/schematic_2.2.2_thermistor_mcp3008.png

実験手順
--------

**ステップ 1:** 回路を組み立てます。

.. image:: ../img/july24_2.2.2_thermistor_mcp3008.png

**ステップ 2:** SPI インターフェースを設定し、 ``spidev`` ライブラリをインストールします（詳細は :ref:`spi_configuration` を参照）。すでに完了している場合はこのステップを省略できます。

**ステップ 3:** コードのフォルダに移動します。

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python

**ステップ 4:** 実行ファイルを実行します。

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 2.2.2-2_thermistor.py

コードを実行すると、サーミスタが周囲の温度を検出し、計算結果が画面に表示されます。

.. warning::

    ``RuntimeError: Cannot determine SOC peripheral base address`` というエラーが出た場合は、:ref:`faq_soc` を参照してください。

コード
------

.. raw:: html

    <run></run>

.. code-block:: python
    
    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-

    import spidev
    import time
    import math
    import RPi.GPIO as GPIO

    GPIO.setmode(GPIO.BCM)

    spi = spidev.SpiDev()
    spi.open(0, 0)  
    spi.max_speed_hz = 1000000

    def read_adc(channel):
        if channel < 0 or channel > 7:
            return -1
        adc = spi.xfer2([1, (8 + channel) << 4, 0])
        value = ((adc[1] & 0x03) << 8) | adc[2]
        return value

    try:
        while True:
            analogVal = read_adc(0)
            Vr = 3.3 * analogVal / 1023.0
            Rt = 10000.0 * Vr / (3.3 - Vr)
            tempK = 1.0 / (((math.log(Rt / 10000.0)) / 3950.0) + (1.0 / (273.15 + 25.0)))
            Cel = tempK - 273.15
            Fah = Cel * 1.8 + 32
            print('Celsius: %.2f °C  Fahrenheit: %.2f °F' % (Cel, Fah))
            time.sleep(0.2)
    except KeyboardInterrupt:
        pass
    finally:
        spi.close()
        GPIO.cleanup()

コード解説
----------

1. 必要なライブラリをインポート:

   - ``spidev``: MCP3008 との SPI 通信
   - ``time``: 遅延処理
   - ``math``: Steinhart–Hart 式の対数計算
   - ``RPi.GPIO``: GPIO 初期化とクリーンアップ

2. GPIO を BCM モードに設定し、MCP3008 の SPI (バス0, CE0) を 1MHz で初期化。

3. ``read_adc(channel)`` 関数で MCP3008 の指定チャネル (0–7) からアナログ値を取得し、10ビット値 (0–1023) を返す。

4. メインループでは:

   - チャネル0から電圧値を読み取る
   - サーミスタの抵抗値を計算
   - Steinhart–Hart 式を用いて温度を計算 (ケルビン → 摂氏 → 華氏)
   - 計算結果を 0.2秒ごとに出力

5. Ctrl+C で停止すると、SPI と GPIO が正しく解放されます。
