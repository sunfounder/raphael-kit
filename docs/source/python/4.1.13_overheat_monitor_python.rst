.. nota::

    Â¡Hola! Bienvenido a la comunidad de entusiastas de SunFounder Raspberry Pi, Arduino y ESP32 en Facebook. Profundiza en Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **Â¿Por quÃ© unirse?**

    - **Soporte experto**: Resuelve problemas postventa y desafÃ­os tÃ©cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprender y compartir**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Avances exclusivos**: Accede anticipadamente a nuevos anuncios de productos y vistas previas.
    - **Descuentos especiales**: Disfruta de descuentos exclusivos en nuestros productos mÃ¡s recientes.
    - **Promociones y sorteos festivos**: Participa en sorteos y promociones durante las festividades.

    ğŸ‘‰ Â¿Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y Ãºnete hoy mismo.

.. _4.1.13_py:

4.1.13 Monitor de Sobrecalentamiento
=========================================

IntroducciÃ³n
---------------------

QuizÃ¡s quieras hacer un dispositivo de monitoreo de sobrecalentamiento 
que se aplique a diversas situaciones, por ejemplo, en la fÃ¡brica, si 
queremos tener una alarma y el apagado automÃ¡tico oportuno de la mÃ¡quina 
cuando hay un sobrecalentamiento del circuito. En este proyecto, utilizaremos 
un termistor, un joystick, un zumbador, un LED y una pantalla LCD para hacer 
un dispositivo inteligente de monitoreo de temperatura cuyo umbral es ajustable.

Componentes Necesarios
------------------------------

En este proyecto, necesitamos los siguientes componentes.

.. image:: ../img/list_Overheat_Monitor.png
    :align: center

Es definitivamente conveniente comprar un kit completo, aquÃ­ estÃ¡ el enlace: 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre	
        - ARTÃCULOS EN ESTE KIT
        - ENLACE
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

TambiÃ©n puedes comprarlos por separado desde los enlaces a continuaciÃ³n.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCIÃ“N DEL COMPONENTE
        - ENLACE DE COMPRA

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_joystick`
        - \-
    *   - :ref:`cpn_adc0834`
        - \-
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|
    *   - :ref:`cpn_i2c_lcd`
        - |link_i2clcd1602_buy|
    *   - :ref:`cpn_thermistor`
        - |link_thermistor_buy|
    *   - :ref:`cpn_buzzer`
        - \-

Diagrama EsquemÃ¡tico
--------------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin15    3        22
GPIO23       Pin16    4        23
GPIO24       Pin18    5        24
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: ../img/Schematic_three_one8.png
   :align: center

Procedimientos Experimentales
-----------------------------

**Paso 1:** Construir el circuito.

.. image:: ../img/image258.png


**Paso 2**: Ir a la carpeta del cÃ³digo.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python/

**Paso 3**: Ejecutar el archivo ejecutable.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 4.1.13_OverheatMonitor.py

Al ejecutar el cÃ³digo, la temperatura actual y el umbral de alta temperatura **40** 
se muestran en el **I2C LCD1602**. Si la temperatura actual es mayor que el umbral, 
el zumbador y el LED se activan para alertarte.

**Joystick** se utiliza aquÃ­ para ajustar el umbral de alta temperatura. Mover el **Joystick** 
en la direcciÃ³n del eje X y el eje Y puede ajustar (aumentar o disminuir) el umbral de alta 
temperatura actual. Presiona el **Joystick** una vez mÃ¡s para restablecer el umbral al valor inicial.

.. nota::

    * Si obtienes el error ``FileNotFoundError: [Errno 2] No such file or directory: '/dev/i2c-1'``, necesitas consultar :ref:`i2c_config` para habilitar el I2C.
    * Si obtienes el error ``ModuleNotFoundError: No module named 'smbus2'``, por favor ejecuta ``sudo pip3 install smbus2``.
    * Si aparece el error ``OSError: [Errno 121] Remote I/O error``, significa que el mÃ³dulo estÃ¡ mal conectado o estÃ¡ roto.
    * Si el cÃ³digo y el cableado estÃ¡n bien, pero la LCD aÃºn no muestra contenido, puedes girar el potenciÃ³metro en la parte posterior para aumentar el contraste.

**CÃ³digo**

.. note::
    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el cÃ³digo a continuaciÃ³n. Pero antes de eso, necesitas ir a la ruta del cÃ³digo fuente como ``raphael-kit/python``. DespuÃ©s de modificar el cÃ³digo, puedes ejecutarlo directamente para ver el efecto.

.. raw:: html

    <run></run>

.. code-block:: python

    #!/usr/bin/env python3

    import LCD1602
    import RPi.GPIO as GPIO
    import ADC0834
    import time
    import math

    Joy_BtnPin = 22
    buzzPin = 23
    ledPin = 24

    upperTem = 40

    def setup():
        ADC0834.setup()
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(ledPin, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(buzzPin, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(Joy_BtnPin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        LCD1602.init(0x27, 1)

    def get_joystick_value():
        x_val = ADC0834.getResult(1)
        y_val = ADC0834.getResult(2)
        if(x_val > 200):
            return 1
        elif(x_val < 50):
            return -1
        elif(y_val > 200):
            return -10
        elif(y_val < 50):
            return 10
        else:
            return 0

    def upper_tem_setting():
        global upperTem
        LCD1602.write(0, 0, 'Upper Adjust: ')
        change = int(get_joystick_value())
        upperTem = upperTem + change
        strUpperTem = str(upperTem)
        LCD1602.write(0, 1, strUpperTem)
        LCD1602.write(len(strUpperTem),1, '              ')
        time.sleep(0.1)

    def temperature():
        analogVal = ADC0834.getResult()
        Vr = 5 * float(analogVal) / 255
        Rt = 10000 * Vr / (5 - Vr)
        temp = 1/(((math.log(Rt / 10000)) / 3950) + (1 / (273.15+25)))
        Cel = temp - 273.15
        Fah = Cel * 1.8 + 32
        return round(Cel,2)

    def monitoring_temp():
        global upperTem
        Cel=temperature()
        LCD1602.write(0, 0, 'Temp: ')
        LCD1602.write(0, 1, 'Upper: ')
        LCD1602.write(6, 0, str(Cel))
        LCD1602.write(7, 1, str(upperTem))
        time.sleep(0.1)
        if Cel >= upperTem:
            GPIO.output(buzzPin, GPIO.HIGH)
            GPIO.output(ledPin, GPIO.HIGH)
        else:
            GPIO.output(buzzPin, GPIO.LOW)
            GPIO.output(ledPin, GPIO.LOW)       

    def loop():
        lastState=1
        stage=0
        while True:
            currentState=GPIO.input(Joy_BtnPin)
            if currentState==1 and lastState ==0:
                stage=(stage+1)%2
                time.sleep(0.1)    
                LCD1602.clear()
            lastState=currentState
            if stage == 1:
                upper_tem_setting()
            else:
                monitoring_temp()
        
    def destroy():
        LCD1602.clear() 
        ADC0834.destroy()
        GPIO.cleanup()

    if __name__ == '__main__':     # Program start from here
        try:
            setup()
            while True:
                loop()
        except KeyboardInterrupt:   # When 'Ctrl+C' is pressed, the program destroy() will be executed.
            destroy()

**ExplicaciÃ³n del CÃ³digo**

.. code-block:: python

    defÂ get_joystick_value():
    Â Â Â Â x_valÂ =Â ADC0834.getResult(1)
    Â Â Â Â y_valÂ =Â ADC0834.getResult(2)
    Â Â Â Â if(x_valÂ >Â 200):
    Â Â Â Â Â Â Â Â returnÂ 1
    Â Â Â Â elif(x_valÂ <Â 50):
    Â Â Â Â Â Â Â Â returnÂ -1
    Â Â Â Â elif(y_valÂ >Â 200):
    Â Â Â Â Â Â Â Â returnÂ -10
    Â Â Â Â elif(y_valÂ <Â 50):
    Â Â Â Â Â Â Â Â returnÂ 10
        else:
            return 0

Esta funciÃ³n lee los valores de X e Y. Si **X > 200**, devolverÃ¡ â€œ\ **1**\ â€; si **X < 50**, 
devolverÃ¡ â€œ\ **-1**\ â€; si **Y > 200**, devolverÃ¡ â€œ\ **-10**\ â€, y si **Y < 50**, devolverÃ¡ 
â€œ\ **10**\ â€.

.. code-block:: python

    defÂ upper_tem_setting():
    Â Â Â Â globalÂ upperTem
    Â Â Â Â LCD1602.write(0,Â 0,Â 'UpperÂ Adjust:Â ')
    Â Â Â Â changeÂ =Â int(get_joystick_value())
    Â Â Â Â upperTemÂ =Â upperTemÂ +Â change
    LCD1602.write(0,Â 1,Â str(upperTem))
    LCD1602.write(len(strUpperTem),1, '              ')
        time.sleep(0.1)

Esta funciÃ³n ajusta el umbral y lo muestra en la pantalla I2C LCD1602.

.. code-block:: python

    defÂ temperature():
    Â Â Â Â analogValÂ =Â ADC0834.getResult()
    Â Â Â Â VrÂ =Â 5Â *Â float(analogVal)Â /Â 255
    Â Â Â Â RtÂ =Â 10000Â *Â VrÂ /Â (5Â -Â Vr)
    Â Â Â Â tempÂ =Â 1/(((math.log(RtÂ /Â 10000))Â /Â 3950)Â +Â (1Â /Â (273.15+25)))
    Â Â Â Â CelÂ =Â tempÂ -Â 273.15
    Â Â Â Â FahÂ =Â CelÂ *Â 1.8Â +Â 32
    Â Â Â Â returnÂ round(Cel,2)

Lee el valor analÃ³gico del **CH0** (termistor) del **ADC0834** y luego lo convierte en un valor de temperatura.

.. code-block:: python

    defÂ monitoring_temp():
    Â Â Â Â globalÂ upperTem
    Â Â Â Â Cel=temperature()
    Â Â Â Â LCD1602.write(0,Â 0,Â 'Temp:Â ')
    Â Â Â Â LCD1602.write(0,Â 1,Â 'Upper:Â ')
    Â Â Â Â LCD1602.write(6,Â 0,Â str(Cel))
    Â Â Â Â LCD1602.write(7,Â 1,Â str(upperTem))
        time.sleep(0.1)
    Â Â Â Â ifÂ CelÂ >=Â upperTem:
    Â Â Â Â Â Â Â Â GPIO.output(buzzPin,Â GPIO.HIGH)
    Â Â Â Â Â Â Â Â GPIO.output(ledPin,Â GPIO.HIGH)
        else:
    Â Â Â Â Â Â Â Â GPIO.output(buzzPin,Â GPIO.LOW)
    Â Â Â Â Â Â Â Â GPIO.output(ledPin,Â GPIO.LOW)

Cuando el cÃ³digo se ejecuta, la temperatura actual y el umbral de alta 
temperatura **40** se muestran en la **I2C LCD1602**. Si la temperatura 
actual es mayor que el umbral, el buzzer y el LED se activan para alertarte.

.. code-block:: python

    defÂ loop():
    Â Â Â Â lastState=1
    Â Â Â Â stage=0
    Â Â Â Â whileÂ True:
    Â Â Â Â Â Â Â Â currentState=GPIO.input(Joy_BtnPin)
    Â Â Â Â Â Â Â Â ifÂ currentState==1Â andÂ lastStateÂ ==0:
    Â Â Â Â Â Â Â Â Â Â Â Â stage=(stage+1)%2
                time.sleep(0.1)
                LCD1602.clear()
    Â Â Â Â Â Â Â Â lastState=currentState
    Â Â Â Â Â Â Â Â ifÂ stageÂ ==Â 1:
                upper_tem_setting()
            else:
                monitoring_temp()

La funciÃ³n ``loop()`` contiene el proceso completo del programa como se muestra:

1) Cuando el programa comienza, el valor inicial de **stage** es **0**, y la temperatura 
actual y el umbral de alta temperatura **40** se muestran en la **I2C LCD1602**. Si la 
temperatura actual es mayor que el umbral, el buzzer y el LED se activan para alertarte.

2) Presiona el joystick, y **stage** serÃ¡ **1**, pudiendo ajustar el umbral de alta
 temperatura. Mover el joystick en la direcciÃ³n del eje X e Y ajusta (aumenta o disminuye) 
 el umbral de alta temperatura actual. Presiona nuevamente el joystick para restablecer el 
 umbral al valor inicial.


Imagen del FenÃ³meno
-------------------------

.. image:: ../img/image259.jpeg
   :align: center