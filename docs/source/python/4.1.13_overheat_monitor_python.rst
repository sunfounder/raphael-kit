.. note::

    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten.

    **Warum beitreten?**

    - **ExpertenunterstÃ¼tzung**: LÃ¶sen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams.
    - **Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre FÃ¤higkeiten zu verbessern.
    - **Exklusive Vorschauen**: Erhalten Sie frÃ¼hzeitigen Zugang zu neuen ProduktankÃ¼ndigungen und exklusiven Einblicken.
    - **Spezialrabatte**: GenieÃŸen Sie exklusive Rabatte auf unsere neuesten Produkte.
    - **Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil.

    ğŸ‘‰ Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!

.. _4.1.13_py:

4.1.13 ÃœberhitzungsÃ¼berwachung
================================

EinfÃ¼hrung
-------------------

MÃ¶glicherweise mÃ¶chten Sie ein ÃœberhitzungsÃ¼berwachungsgerÃ¤t erstellen, das fÃ¼r 
verschiedene Situationen geeignet ist, z. B. in einer Fabrik, wenn wir einen Alarm 
wÃ¼nschen und die Maschine bei einer SchaltkreisÃ¼berhitzung rechtzeitig automatisch 
ausschalten mÃ¶chten. In diesem Projekt werden wir einen Thermistor, einen Joystick, 
einen Summer, eine LED und ein LCD verwenden, um ein intelligentes TemperaturÃ¼berwachungsgerÃ¤t 
zu erstellen, dessen Schwellenwert einstellbar ist.

BenÃ¶tigte Komponenten
------------------------------

FÃ¼r dieses Projekt benÃ¶tigen wir die folgenden Komponenten.

.. image:: ../img/list_Overheat_Monitor.png
    :align: center

Es ist definitiv praktisch, ein ganzes Kit zu kaufen, hier ist der Link: 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Name	
        - ARTIKEL IN DIESEM KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Sie kÃ¶nnen sie auch separat Ã¼ber die untenstehenden Links kaufen.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - KOMPONENTENBESCHREIBUNG
        - KAUF-LINK

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_joystick`
        - \-
    *   - :ref:`cpn_adc0834`
        - \-
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|
    *   - :ref:`cpn_i2c_lcd1602`
        - |link_i2clcd1602_buy|
    *   - :ref:`cpn_thermistor`
        - |link_thermistor_buy|
    *   - :ref:`cpn_buzzer`
        - \-

Schaltplan
--------------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin15    3        22
GPIO23       Pin16    4        23
GPIO24       Pin18    5        24
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: ../img/Schematic_three_one8.png
   :align: center

Experimentelle Verfahren
-----------------------------

**Schritt 1:** Bauen Sie den Schaltkreis auf.

.. image:: ../img/image258.png


**Schritt 2**: Navigieren Sie zum Ordner des Codes.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python/

**Schritt 3**: FÃ¼hren Sie die ausfÃ¼hrbare Datei aus.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 4.1.13_ÃœberhitzungsMonitor.py

Wenn der Code ausgefÃ¼hrt wird, werden die aktuelle Temperatur und der Hochtemperaturschwellenwert **40** auf dem **I2C LCD1602** angezeigt. Wenn die aktuelle Temperatur grÃ¶ÃŸer als der Schwellenwert ist, werden der Summer und die LED gestartet, um Sie zu alarmieren.

Der **Joystick** dient hier zum Einstellen des Hochtemperaturschwellenwerts. Das Kippen des **Joysticks** in Richtung der X- und Y-Achse kann den aktuellen Hochtemperaturschwellenwert anpassen (erhÃ¶hen oder verringern). DrÃ¼cken Sie den **Joystick** erneut, um den Schwellenwert auf den Anfangswert zurÃ¼ckzusetzen.

.. note::

    * Bei dem Fehler ``FileNotFoundError: [Errno 2] No such file or directory: '/dev/i2c-1'`` mÃ¼ssen Sie :ref:`i2c_config` konsultieren, um den I2C zu aktivieren.
    * Wenn der Fehler ``ModuleNotFoundError: No module named 'smbus2'`` auftritt, fÃ¼hren Sie bitte ``sudo pip3 install smbus2`` aus.
    * Wenn der Fehler ``OSError: [Errno 121] Remote I/O error`` erscheint, bedeutet dies, dass das Modul falsch verdrahtet ist oder das Modul defekt ist.
    * Wenn der Code und die Verkabelung in Ordnung sind, das LCD jedoch weiterhin keinen Inhalt anzeigt, kÃ¶nnen Sie das Potentiometer auf der RÃ¼ckseite drehen, um den Kontrast zu erhÃ¶hen.

**Code**

.. note::
    Sie kÃ¶nnen den untenstehenden Code **Ã„ndern/ZurÃ¼cksetzen/Kopieren/AusfÃ¼hren/Stoppen**. Aber zuerst mÃ¼ssen Sie zum Quellcode-Pfad wie ``raphael-kit/python`` navigieren. Nach dem Ã„ndern des Codes kÃ¶nnen Sie ihn direkt ausfÃ¼hren, um den Effekt zu sehen.


.. raw:: html

    <run></run>

.. code-block:: python

    #!/usr/bin/env python3

    import LCD1602
    import RPi.GPIO as GPIO
    import ADC0834
    import time
    import math

    Joy_BtnPin = 22
    buzzPin = 23
    ledPin = 24

    upperTem = 40

    def setup():
        ADC0834.setup()
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(ledPin, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(buzzPin, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(Joy_BtnPin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        LCD1602.init(0x27, 1)

    def get_joystick_value():
        x_val = ADC0834.getResult(1)
        y_val = ADC0834.getResult(2)
        if(x_val > 200):
            return 1
        elif(x_val < 50):
            return -1
        elif(y_val > 200):
            return -10
        elif(y_val < 50):
            return 10
        else:
            return 0

    def upper_tem_setting():
        global upperTem
        LCD1602.write(0, 0, 'Upper Adjust: ')
        change = int(get_joystick_value())
        upperTem = upperTem + change
        strUpperTem = str(upperTem)
        LCD1602.write(0, 1, strUpperTem)
        LCD1602.write(len(strUpperTem),1, '              ')
        time.sleep(0.1)

    def temperature():
        analogVal = ADC0834.getResult()
        Vr = 5 * float(analogVal) / 255
        Rt = 10000 * Vr / (5 - Vr)
        temp = 1/(((math.log(Rt / 10000)) / 3950) + (1 / (273.15+25)))
        Cel = temp - 273.15
        Fah = Cel * 1.8 + 32
        return round(Cel,2)

    def monitoring_temp():
        global upperTem
        Cel=temperature()
        LCD1602.write(0, 0, 'Temp: ')
        LCD1602.write(0, 1, 'Upper: ')
        LCD1602.write(6, 0, str(Cel))
        LCD1602.write(7, 1, str(upperTem))
        time.sleep(0.1)
        if Cel >= upperTem:
            GPIO.output(buzzPin, GPIO.HIGH)
            GPIO.output(ledPin, GPIO.HIGH)
        else:
            GPIO.output(buzzPin, GPIO.LOW)
            GPIO.output(ledPin, GPIO.LOW)       

    def loop():
        lastState=1
        stage=0
        while True:
            currentState=GPIO.input(Joy_BtnPin)
            if currentState==1 and lastState ==0:
                stage=(stage+1)%2
                time.sleep(0.1)    
                LCD1602.clear()
            lastState=currentState
            if stage == 1:
                upper_tem_setting()
            else:
                monitoring_temp()
        
    def destroy():
        LCD1602.clear() 
        ADC0834.destroy()
        GPIO.cleanup()

    if __name__ == '__main__':     # Program start from here
        try:
            setup()
            while True:
                loop()
        except KeyboardInterrupt:   # When 'Ctrl+C' is pressed, the program destroy() will be executed.
            destroy()

**Code-ErklÃ¤rung**

.. code-block:: python

    defÂ get_joystick_value():
    Â Â Â Â x_valÂ =Â ADC0834.getResult(1)
    Â Â Â Â y_valÂ =Â ADC0834.getResult(2)
    Â Â Â Â if(x_valÂ >Â 200):
    Â Â Â Â Â Â Â Â returnÂ 1
    Â Â Â Â elif(x_valÂ <Â 50):
    Â Â Â Â Â Â Â Â returnÂ -1
    Â Â Â Â elif(y_valÂ >Â 200):
    Â Â Â Â Â Â Â Â returnÂ -10
    Â Â Â Â elif(y_valÂ <Â 50):
    Â Â Â Â Â Â Â Â returnÂ 10
    Â Â Â Â else:
    Â Â Â Â Â Â Â Â returnÂ 0

Diese Funktion liest die Werte von X und Y. Wenn **X>200**, wird â€\ **1**\ â€ zurÃ¼ckgegeben; **X<50**, RÃ¼ckgabe von â€\ **-1**\ â€; **y>200**, RÃ¼ckgabe von â€\ **-10**\ â€ und **y<50**, RÃ¼ckgabe von â€\ **10**\ â€.

.. code-block:: python

    defÂ upper_tem_setting():
    Â Â Â Â globalÂ upperTem
    Â Â Â Â LCD1602.write(0,Â 0,Â 'UpperÂ Adjust:Â ')
    Â Â Â Â changeÂ =Â int(get_joystick_value())
    Â Â Â Â upperTemÂ =Â upperTemÂ +Â change
    LCD1602.write(0,Â 1,Â str(upperTem))
    LCD1602.write(len(strUpperTem),1, '              ')
    Â Â Â Â time.sleep(0.1)

Diese Funktion dient zur Anpassung des Schwellenwerts und zur Anzeige auf dem I2C LCD1602.

.. code-block:: python

    defÂ temperature():
    Â Â Â Â analogValÂ =Â ADC0834.getResult()
    Â Â Â Â VrÂ =Â 5Â *Â float(analogVal)Â /Â 255
    Â Â Â Â RtÂ =Â 10000Â *Â VrÂ /Â (5Â -Â Vr)
    Â Â Â Â tempÂ =Â 1/(((math.log(RtÂ /Â 10000))Â /Â 3950)Â +Â (1Â /Â (273.15+25)))
    Â Â Â Â CelÂ =Â tempÂ -Â 273.15
    Â Â Â Â FahÂ =Â CelÂ *Â 1.8Â +Â 32
    Â Â Â Â returnÂ round(Cel,2)

Liest den Analogwert des **CH0** (Thermistor) von **ADC0834** und konvertiert ihn dann in einen Temperaturwert.

.. code-block:: python

    defÂ monitoring_temp():
    Â Â Â Â globalÂ upperTem
    Â Â Â Â Cel=temperature()
    Â Â Â Â LCD1602.write(0,Â 0,Â 'Temp:Â ')
    Â Â Â Â LCD1602.write(0,Â 1,Â 'Upper:Â ')
    Â Â Â Â LCD1602.write(6,Â 0,Â str(Cel))
    Â Â Â Â LCD1602.write(7,Â 1,Â str(upperTem))
    Â Â Â Â time.sleep(0.1)
    Â Â Â Â ifÂ CelÂ >=Â upperTem:
    Â Â Â Â Â Â Â Â GPIO.output(buzzPin,Â GPIO.HIGH)
    Â Â Â Â Â Â Â Â GPIO.output(ledPin,Â GPIO.HIGH)
    Â Â Â Â else:
    Â Â Â Â Â Â Â Â GPIO.output(buzzPin,Â GPIO.LOW)
    Â Â Â Â Â Â Â Â GPIO.output(ledPin,Â GPIO.LOW)

WÃ¤hrend der Code ausgefÃ¼hrt wird, werden die aktuelle Temperatur und der Hochtemperaturschwellenwert **40** auf dem **I2C LCD1602** angezeigt. Wenn die aktuelle Temperatur Ã¼ber dem Schwellenwert liegt, werden der Summer und die LED aktiviert, um Sie zu alarmieren.

.. code-block:: python

    defÂ loop():
    Â Â Â Â lastState=1
    Â Â Â Â stage=0
    Â Â Â Â whileÂ True:
    Â Â Â Â Â Â Â Â currentState=GPIO.input(Joy_BtnPin)
    Â Â Â Â Â Â Â Â ifÂ currentState==1Â andÂ lastStateÂ ==0:
    Â Â Â Â Â Â Â Â Â Â Â Â stage=(stage+1)%2
    Â Â Â Â Â Â Â Â Â Â Â Â time.sleep(0.1)Â Â Â Â 
    Â Â Â Â Â Â Â Â Â Â Â Â LCD1602.clear()
    Â Â Â Â Â Â Â Â lastState=currentState
    Â Â Â Â Â Â Â Â ifÂ stageÂ ==Â 1:
    Â Â Â Â Â Â Â Â Â Â Â Â upper_tem_setting()
    Â Â Â Â Â Â Â Â else:
    Â Â Â Â Â Â Â Â Â Â Â Â monitoring_temp()

Die Funktion ``main()`` enthÃ¤lt den gesamten Ablauf des Programms wie dargestellt:

1) Wenn das Programm startet, ist der Anfangswert von **stage** **0** und die aktuelle Temperatur sowie der Hochtemperaturschwellenwert **40** werden auf dem **I2C LCD1602** angezeigt. Wenn die aktuelle Temperatur Ã¼ber dem Schwellenwert liegt, werden der Summer und die LED aktiviert, um Sie zu alarmieren.

2) DrÃ¼cken Sie den Joystick, dann wird **stage** auf **1** gesetzt und Sie kÃ¶nnen den Hochtemperaturschwellenwert anpassen. Das Kippen des Joysticks in Richtung der X- und Y-Achse kann den aktuellen Hochtemperaturschwellenwert anpassen (erhÃ¶hen oder verringern). DrÃ¼cken Sie den Joystick erneut, um den Schwellenwert auf den Anfangswert zurÃ¼ckzusetzen.

PhÃ¤nomen-Bild
-------------------------

.. image:: ../img/image259.jpeg
   :align: center