 
.. note::

    Bonjour et bienvenue dans la CommunautÃ© Facebook des passionnÃ©s de Raspberry Pi, Arduino et ESP32 de SunFounder ! Plongez plus profondÃ©ment dans l'univers des Raspberry Pi, Arduino et ESP32 avec d'autres passionnÃ©s.

    **Pourquoi rejoindre ?**

    - **Support d'experts** : RÃ©solvez les problÃ¨mes aprÃ¨s-vente et les dÃ©fis techniques avec l'aide de notre communautÃ© et de notre Ã©quipe.
    - **Apprendre et partager** : Ã‰changez des astuces et des tutoriels pour amÃ©liorer vos compÃ©tences.
    - **AperÃ§us exclusifs** : AccÃ©dez en avant-premiÃ¨re aux annonces de nouveaux produits et aux aperÃ§us.
    - **RÃ©ductions spÃ©ciales** : Profitez de rÃ©ductions exclusives sur nos produits les plus rÃ©cents.
    - **Promotions festives et cadeaux** : Participez Ã  des cadeaux et des promotions de vacances.

    ğŸ‘‰ PrÃªt Ã  explorer et Ã  crÃ©er avec nous ? Cliquez [|link_sf_facebook|] et rejoignez-nous aujourd'hui !

.. _4.1.13_py:

4.1.13 Moniteur de Surchauffe
==================================

.. note::

   .. image:: ../img/mcp3008_and_adc0834.jpg
      :width: 25%
      :align: left
    

   Selon la version de votre kit, identifiez si vous disposez dâ€™un **ADC0834** ou dâ€™un **MCP3008** et suivez la section correspondante.

Introduction
-------------------

Vous pouvez vouloir fabriquer un dispositif de surveillance de surchauffe applicable Ã  
diverses situations, par exemple, dans une usine, si nous voulons avoir une alarme et l'arrÃªt 
automatique de la machine en cas de surchauffe du circuit. Dans ce projet, nous utiliserons un 
thermistor, un joystick, un buzzer, une LED et un Ã©cran LCD pour fabriquer un dispositif de 
surveillance de la tempÃ©rature intelligent dont le seuil est rÃ©glable.


Composants Requis
------------------------------

Pour ce projet, nous avons besoin des composants suivants.

.. image:: ../img/list_Overheat_Monitor.png
    :align: center

Il est certainement pratique d'acheter un kit complet, voici le lien : 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom	
        - Ã‰LÃ‰MENTS DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez Ã©galement les acheter sÃ©parÃ©ment Ã  partir des liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DU COMPOSANT
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_joystick`
        - \-
    *   - :ref:`cpn_adc0834`
        - \-
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|
    *   - :ref:`cpn_i2c_lcd`
        - |link_i2clcd1602_buy|
    *   - :ref:`cpn_thermistor`
        - |link_thermistor_buy|
    *   - :ref:`cpn_buzzer`
        - \-

SchÃ©ma de CÃ¢blage
--------------------------

============ ======== ======== ===
Nom T-Board  physique wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin15    3        22
GPIO23       Pin16    4        23
GPIO24       Pin18    5        24
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: ../img/Schematic_three_one8.png
   :align: center

ProcÃ©dures ExpÃ©rimentales
-----------------------------

**Ã‰tape 1 :** Construisez le circuit.

.. image:: ../img/image258.png

**Ã‰tape 2** : AccÃ©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python/

**Ã‰tape 3** : ExÃ©cutez le fichier exÃ©cutable.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 4.1.13_OverheatMonitor.py

Lorsque le code s'exÃ©cute, la tempÃ©rature actuelle et le seuil de haute tempÃ©rature **40** s'affichent 
sur l'Ã©cran **I2C LCD1602**. Si la tempÃ©rature actuelle dÃ©passe le seuil, le buzzer et la LED s'allument pour vous alerter.

**Le joystick** est utilisÃ© ici pour ajuster le seuil de haute tempÃ©rature. En dÃ©plaÃ§ant 
le **joystick** dans les directions de l'axe X et de l'axe Y, vous pouvez augmenter ou 
diminuer le seuil de haute tempÃ©rature actuel. Appuyez Ã  nouveau sur le **joystick** pour 
rÃ©initialiser le seuil Ã  sa valeur initiale.

.. note::

    * Si vous obtenez l'erreur ``FileNotFoundError: [Errno 2] No such file or directory: '/dev/i2c-1'``, vous devez vous rÃ©fÃ©rer Ã  :ref:`i2c_config` pour activer l'I2C.
    * Si vous obtenez l'erreur ``ModuleNotFoundError: No module named 'smbus2'``, veuillez exÃ©cuter ``sudo apt install python3-smbus2``.
    * Si l'erreur ``OSError: [Errno 121] Remote I/O error`` apparaÃ®t, cela signifie que le module est mal cÃ¢blÃ© ou qu'il est dÃ©fectueux.
    * Si le code et le cÃ¢blage sont corrects, mais que l'Ã©cran LCD ne s'affiche toujours pas, vous pouvez tourner le potentiomÃ¨tre Ã  l'arriÃ¨re pour augmenter le contraste.

**Code**

.. note::
    Vous pouvez **Modifier/RÃ©initialiser/Copier/ExÃ©cuter/ArrÃªter** le code ci-dessous. Mais avant 
    cela, vous devez aller dans le chemin du code source comme ``raphael-kit/python``. AprÃ¨s avoir 
    modifiÃ© le code, vous pouvez l'exÃ©cuter directement pour voir l'effet.

.. raw:: html

    <run></run>

.. code-block:: python

    #!/usr/bin/env python3

    import LCD1602
    import RPi.GPIO as GPIO
    import ADC0834
    import time
    import math

    Joy_BtnPin = 22
    buzzPin = 23
    ledPin = 24

    upperTem = 40

    def setup():
        ADC0834.setup()
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(ledPin, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(buzzPin, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(Joy_BtnPin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        LCD1602.init(0x27, 1)

    def get_joystick_value():
        x_val = ADC0834.getResult(1)
        y_val = ADC0834.getResult(2)
        if(x_val > 200):
            return 1
        elif(x_val < 50):
            return -1
        elif(y_val > 200):
            return -10
        elif(y_val < 50):
            return 10
        else:
            return 0

    def upper_tem_setting():
        global upperTem
        LCD1602.write(0, 0, 'Upper Adjust: ')
        change = int(get_joystick_value())
        upperTem = upperTem + change
        strUpperTem = str(upperTem)
        LCD1602.write(0, 1, strUpperTem)
        LCD1602.write(len(strUpperTem),1, '              ')
        time.sleep(0.1)

    def temperature():
        analogVal = ADC0834.getResult()
        Vr = 5 * float(analogVal) / 255
        Rt = 10000 * Vr / (5 - Vr)
        temp = 1/(((math.log(Rt / 10000)) / 3950) + (1 / (273.15+25)))
        Cel = temp - 273.15
        Fah = Cel * 1.8 + 32
        return round(Cel,2)

    def monitoring_temp():
        global upperTem
        Cel=temperature()
        LCD1602.write(0, 0, 'Temp: ')
        LCD1602.write(0, 1, 'Upper: ')
        LCD1602.write(6, 0, str(Cel))
        LCD1602.write(7, 1, str(upperTem))
        time.sleep(0.1)
        if Cel >= upperTem:
            GPIO.output(buzzPin, GPIO.HIGH)
            GPIO.output(ledPin, GPIO.HIGH)
        else:
            GPIO.output(buzzPin, GPIO.LOW)
            GPIO.output(ledPin, GPIO.LOW)

    def loop():
        lastState=1
        stage=0
        while True:
            currentState=GPIO.input(Joy_BtnPin)
            if currentState==1 and lastState ==0:
                stage=(stage+1)%2
                time.sleep(0.1)    
                LCD1602.clear()
            lastState=currentState
            if stage == 1:
                upper_tem_setting()
            else:
                monitoring_temp()

    def destroy():
        LCD1602.clear() 
        ADC0834.destroy()
        GPIO.cleanup()

    if __name__ == '__main__':     # Program start from here
        try:
            setup()
            while True:
                loop()
        except KeyboardInterrupt:   # When 'Ctrl+C' is pressed, the program destroy() will be executed.
            destroy()

**Explication du Code**

.. code-block:: python

    defÂ get_joystick_value():
    Â Â Â Â x_valÂ =Â ADC0834.getResult(1)
    Â Â Â Â y_valÂ =Â ADC0834.getResult(2)
    Â Â Â Â if(x_valÂ >Â 200):
    Â Â Â Â Â Â Â Â returnÂ 1
    Â Â Â Â elif(x_valÂ <Â 50):
    Â Â Â Â Â Â Â Â returnÂ -1
    Â Â Â Â elif(y_valÂ >Â 200):
    Â Â Â Â Â Â Â Â returnÂ -10
    Â Â Â Â elif(y_valÂ <Â 50):
    Â Â Â Â Â Â Â Â returnÂ 10
    Â Â Â Â else:
    Â Â Â Â Â Â Â Â returnÂ 0

Cette fonction lit les valeurs de X et Y. Si **X>200**, elle renverra â€œ\ **1**\ â€; **X<50**, 
renverra â€œ\ **-1**\ â€; **y>200**, renverra â€œ\ **-10**\ â€, et **y<50**, renverra â€œ\ **10**\ â€.

.. code-block:: python

    defÂ upper_tem_setting():
    Â Â Â Â globalÂ upperTem
    Â Â Â Â LCD1602.write(0,Â 0,Â 'UpperÂ Adjust:Â ')
    Â Â Â Â changeÂ =Â int(get_joystick_value())
    Â Â Â Â upperTemÂ =Â upperTemÂ +Â change
    Â Â Â Â LCD1602.write(0,Â 1,Â str(upperTem))
    LCD1602.write(len(strUpperTem),1, '              ')
    Â Â Â Â time.sleep(0.1)

Cette fonction sert Ã  ajuster le seuil et Ã  l'afficher sur l'Ã©cran I2C LCD1602.

.. code-block:: python

    defÂ temperature():
    Â Â Â Â analogValÂ =Â ADC0834.getResult()
    Â Â Â Â VrÂ =Â 5Â *Â float(analogVal)Â /Â 255
    Â Â Â Â RtÂ =Â 10000Â *Â VrÂ /Â (5Â -Â Vr)
    Â Â Â Â tempÂ =Â 1/(((math.log(RtÂ /Â 10000))Â /Â 3950)Â +Â (1Â /Â (273.15+25)))
    Â Â Â Â CelÂ =Â tempÂ -Â 273.15
    Â Â Â Â FahÂ =Â CelÂ *Â 1.8Â +Â 32
    Â Â Â Â returnÂ round(Cel,2)

Lire la valeur analogique de **CH0** (thermistor) de **ADC0834** puis la 
convertir en valeur de tempÃ©rature.

.. code-block:: python

    defÂ monitoring_temp():
    Â Â Â Â globalÂ upperTem
    Â Â Â Â Cel=temperature()
    Â Â Â Â LCD1602.write(0,Â 0,Â 'Temp:Â ')
    Â Â Â Â LCD1602.write(0,Â 1,Â 'Upper:Â ')
    Â Â Â Â LCD1602.write(6,Â 0,Â str(Cel))
    Â Â Â Â LCD1602.write(7,Â 1,Â str(upperTem))
    Â Â Â Â time.sleep(0.1)
    Â Â Â Â ifÂ CelÂ >=Â upperTem:
    Â Â Â Â Â Â Â Â GPIO.output(buzzPin,Â GPIO.HIGH)
    Â Â Â Â Â Â Â Â GPIO.output(ledPin,Â GPIO.HIGH)
    Â Â Â Â else:
    Â Â Â Â Â Â Â Â GPIO.output(buzzPin,Â GPIO.LOW)
    Â Â Â Â Â Â Â Â GPIO.output(ledPin,Â GPIO.LOW)

Lorsque le code s'exÃ©cute, la tempÃ©rature actuelle et le seuil de haute 
tempÃ©rature **40** s'affichent sur l'Ã©cran **I2C LCD1602**. Si la tempÃ©rature 
actuelle dÃ©passe le seuil, le buzzer et la LED s'allument pour vous alerter.

.. code-block:: python

    defÂ loop():
    Â Â Â Â lastState=1
    Â Â Â Â stage=0
    Â Â Â Â whileÂ True:
    Â Â Â Â Â Â Â Â currentState=GPIO.input(Joy_BtnPin)
    Â Â Â Â Â Â Â Â ifÂ currentState==1Â andÂ lastStateÂ ==0:
    Â Â Â Â Â Â Â Â Â Â Â Â stage=(stage+1)%2
    Â Â Â Â Â Â Â Â Â Â Â Â time.sleep(0.1)Â Â Â Â 
    Â Â Â Â Â Â Â Â Â Â Â Â LCD1602.clear()
    Â Â Â Â Â Â Â Â lastState=currentState
    Â Â Â Â Â Â Â Â ifÂ stageÂ ==Â 1:
    Â Â Â Â Â Â Â Â Â Â Â Â upper_tem_setting()
    Â Â Â Â Â Â Â Â else:
    Â Â Â Â Â Â Â Â Â Â Â Â monitoring_temp()

La fonction ``main()`` contient l'ensemble du processus du programme comme suit :

1) Lorsque le programme dÃ©marre, la valeur initiale de **stage** est **0**, et la tempÃ©rature 
actuelle ainsi que le seuil de haute tempÃ©rature **40** s'affichent sur l'Ã©cran **I2C LCD1602**. 
Si la tempÃ©rature actuelle dÃ©passe le seuil, le buzzer et la LED s'allument pour vous alerter.

2) Appuyez sur le joystick, et **stage** deviendra **1** et vous pourrez ajuster le seuil de haute 
tempÃ©rature. En dÃ©plaÃ§ant le joystick dans les directions de l'axe X et de l'axe Y, vous pouvez 
augmenter ou diminuer le seuil de haute tempÃ©rature actuel. Appuyez Ã  nouveau sur le joystick pour 
rÃ©initialiser le seuil Ã  sa valeur initiale.


Image du PhÃ©nomÃ¨ne
-------------------------

.. image:: ../img/image259.jpeg
   :align: center