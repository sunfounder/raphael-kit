 
.. _1.1.1_py:

1.1.1 LED Clignotante
=========================

Introduction
-----------------

Dans ce projet, nous apprendrons comment créer une LED clignotante par programmation.
Grâce à vos réglages, votre LED peut produire une série de phénomènes intéressants. Maintenant, allons-y.

Composants Nécessaires
------------------------------

Dans ce projet, nous avons besoin des composants suivants.

.. image:: ../img/blinking_led_list.png
    :width: 800
    :align: center

Il est certainement pratique d'acheter un kit complet, voici le lien :

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom	
        - ARTICLES DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez également les acheter séparément aux liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DES COMPOSANTS
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|

Schéma de Circuit
---------------------

Dans cette expérience, connectez une résistance de 220Ω à l'anode (la patte longue de la LED), 
puis la résistance à 3,3 V, et connectez la cathode (la patte courte) de la LED à GPIO17 du 
Raspberry Pi. Par conséquent, pour allumer une LED, nous devons mettre GPIO17 au niveau bas (0V). 
Nous pouvons obtenir ce phénomène par programmation.

.. note::

    **Pin11** fait référence à la 11e broche du Raspberry Pi de gauche à droite, et ses numéros de 
    broche correspondants **wiringPi** et **BCM** sont indiqués dans le tableau suivant.

Dans le contenu lié au langage C, nous faisons en sorte que GPIO0 soit équivalent à 0 dans 
wiringPi. Dans le contenu lié au langage Python, BCM 17 est 17 dans la colonne BCM du tableau 
suivant. En même temps, ils sont les mêmes que la 11e broche sur le Raspberry Pi, Pin 11.

============ ======== ======== ===
Nom T-Board  physique wiringPi BCM
GPIO17       Pin 11   0        17
============ ======== ======== ===

.. image:: ../img/image48.png
    :width: 800
    :align: center

Procédures Expérimentales
-----------------------------

**Étape 1 :** Construisez le circuit.

.. image:: ../img/image49.png
    :width: 800
    :align: center

**Étape 2 :** Allez dans le dossier du code et exécutez-le.

1. Si vous utilisez un écran, il est recommandé de suivre les étapes suivantes.

Trouvez 1.1.1_BlinkingLed.py et double-cliquez dessus pour l'ouvrir. Vous êtes maintenant dans le fichier.

Cliquez sur **Run** ->\ **Run Module** dans la fenêtre et les contenus suivants apparaîtront.

Pour arrêter l'exécution, cliquez simplement sur le bouton X en haut à droite pour le fermer 
et vous reviendrez au code. Si vous modifiez le code, avant de cliquer sur **Run Module (F5)**, 
vous devez d'abord le sauvegarder. Ensuite, vous pouvez voir les résultats.

2. Si vous vous connectez au Raspberry Pi à distance, tapez la commande suivante :

.. raw:: html

   <run></run>

.. code-block::

   cd ~/raphael-kit/python

.. note::
    Changez de répertoire vers le chemin du code dans cette expérience via ``cd``.

**Étape 3 :** Exécutez le code

.. raw:: html

   <run></run>

.. code-block::

   sudo python3 1.1.1_BlinkingLed.py

.. note::
    Ici sudo - superuser do, et python signifie exécuter le fichier avec Python.

Après l'exécution du code, vous verrez la LED clignoter.

**Étape 4 :** Si vous souhaitez modifier le fichier de code 1.1.1_BlinkingLed.py, 
appuyez sur ``Ctrl + C`` pour arrêter l'exécution du code. Puis tapez la commande 
suivante pour ouvrir 1.1.1_BlinkingLed.py :

.. raw:: html

   <run></run>

.. code-block::

   nano 1.1.1_BlinkingLed.py

.. note::
    nano est un outil d'édition de texte. La commande est utilisée pour ouvrir le fichier 
    de code 1.1.1_BlinkingLed.py avec cet outil.

Appuyez sur ``Ctrl+X`` pour quitter. Si vous avez modifié le code, une invite vous demandera 
si vous souhaitez enregistrer les modifications ou non. Tapez ``Y`` (enregistrer) ou ``N`` 
(ne pas enregistrer).

Puis appuyez sur ``Enter`` pour quitter. Tapez à nouveau nano 1.1.1_BlinkingLed.py 
pour voir l'effet après la modification.
**Code**

Le programme suivant est le code :

.. note::

   Vous pouvez **Modifier/Réinitialiser/Copier/Exécuter/Arrêter** le code ci-dessous. Mais avant cela, vous devez vous rendre dans le chemin du code source comme ``raphael-kit/python``. Après avoir modifié le code, vous pouvez l'exécuter directement pour voir l'effet.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   import RPi.GPIO as GPIO
   import time
   LedPin = 17
   def setup():
      # Set the GPIO modes to BCM Numbering
      GPIO.setmode(GPIO.BCM)
      # Set LedPin's mode to output,and initial level to High(3.3v)
      GPIO.setup(LedPin, GPIO.OUT, initial=GPIO.HIGH)
   # Define a main function for main process
   def main():
      while True:
         print ('...LED ON')
         # Turn on LED
         GPIO.output(LedPin, GPIO.LOW)
         time.sleep(0.5)
         print ('LED OFF...')
         # Turn off LED
         GPIO.output(LedPin, GPIO.HIGH)
         time.sleep(0.5)
   # Define a destroy function for clean up everything after the script finished
   def destroy():
      # Turn off LED
      GPIO.output(LedPin, GPIO.HIGH)
      # Release resource
      GPIO.cleanup()                   
   # If run this script directly, do:
   if __name__ == '__main__':
      setup()
      try:
         main()
      # When 'Ctrl+C' is pressed, the program destroy() will be  executed.
      except KeyboardInterrupt:
         destroy()

**Explication du code**

.. code-block:: python

   #!/usr/bin/env python3

Lorsque le système détecte cela, il recherchera le chemin d'installation de python dans le 
paramètre env, puis appellera l'interpréteur correspondant pour compléter l'opération. Cela 
permet d'éviter que l'utilisateur n'installe pas python dans le chemin par défaut ``/usr/bin``.

.. code-block:: python

   import RPi.GPIO as GPIO

De cette façon, importez la bibliothèque RPi.GPIO, puis définissez une variable, GPIO, pour 
remplacer RPI.GPIO dans le code suivant.

.. code-block:: python

   import time

Importez le package time, pour la fonction de délai temporel dans le programme suivant.

.. code-block:: python

   LedPin = 17

La LED est connectée au GPIO17 de la carte d'extension en forme de T, c'est-à-dire, BCM 17.

.. code-block:: python

   def setup():
      GPIO.setmode(GPIO.BCM)
      GPIO.setup(LedPin, GPIO.OUT, initial=GPIO.HIGH)

Définir le mode de LedPin en sortie, et le niveau initial à High (3,3v).

Il existe deux façons de numéroter les broches IO sur un Raspberry Pi avec 
RPi.GPIO : les numéros BOARD et les numéros BCM. Dans nos projets, nous 
utilisons les numéros BCM. Vous devez configurer chaque canal que vous utilisez 
comme entrée ou sortie.

.. code-block:: python

   GPIO.output(LedPin, GPIO.LOW)

Définir GPIO17 (BCM17) à 0V (niveau bas). Puisque la cathode de la LED est connectée à GPIO17, 
la LED s'allumera.

.. code-block:: python

   time.sleep(0.5)

Délai de 0,5 seconde. Ici, l'instruction est une fonction de délai en langage C, l'unité est la seconde.

.. code-block:: python

   def destroy():
      GPIO.cleanup()  

Définir une fonction destroy pour nettoyer tout après la fin du script.

.. code-block:: python

   if __name__ == '__main__':
      setup()
      try:
         main()
      # When 'Ctrl+C' is pressed, the program destroy() will be  executed.
      except KeyboardInterrupt:
         destroy()

C'est la structure générale de l'exécution du code. Lorsque le programme commence à s'exécuter, 
il initialise la broche en exécutant setup(), puis exécute le code dans la fonction main() pour 
définir la broche en niveaux haut et bas. Lorsque ``Ctrl+C`` est pressé, la fonction destroy() 
sera exécutée.

Image du phénomène
--------------------

.. image:: ../img/image54.jpeg
    :width: 800
    :align: center
