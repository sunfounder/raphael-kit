 
.. _4.1.10_py:

4.1.10 Ventilateur Intelligent
===================================

Introduction
-----------------

Dans ce projet, nous allons utiliser des moteurs, des boutons et des thermistances pour fabriquer un ventilateur intelligent manuel + automatique dont la vitesse du vent est réglable.

Composants Nécessaires
--------------------------------

Pour ce projet, nous avons besoin des composants suivants.

.. image:: ../img/list_Smart_Fan.png
    :align: center

Il est certainement pratique d'acheter un kit complet, voici le lien :

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom	
        - ARTICLES DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez également les acheter séparément aux liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DU COMPOSANT
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_power_module`
        - \-
    *   - :ref:`cpn_thermistor`
        - |link_thermistor_buy|
    *   - :ref:`cpn_l293d`
        - \-
    *   - :ref:`cpn_adc0834`
        - \-
    *   - :ref:`cpn_button`
        - |link_button_buy|
    *   - :ref:`cpn_motor`
        - |link_motor_buy|


Schéma de Circuit
------------------------

============ ======== ======== ===
Nom T-Board  Physique WiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin 15   3        22
GPIO5        Pin 29   21       5
GPIO6        Pin 31   22       6
GPIO13       Pin 33   23       13
============ ======== ======== ===

.. image:: ../img/Schematic_three_one4.png
   :align: center

Procédures Expérimentales
-----------------------------

**Étape 1:** Construisez le circuit.

.. image:: ../img/image245.png

.. note::
    Le module d'alimentation peut utiliser une pile de 9V avec la boucle de batterie 9V dans le kit. 
    Insérez le capuchon du module d'alimentation dans les bandes de bus 5V de la plaque d'essai.

.. image:: ../img/image118.jpeg
   :align: center

**Étape 2**: Accédez au dossier du code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python

**Étape 3**: Exécutez.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 4.1.10_SmartFan.py

Lorsque le code s'exécute, démarrez le ventilateur en appuyant sur le bouton. Chaque fois que 
vous appuyez, la vitesse augmente ou diminue d'un niveau. Il y a **5** niveaux de vitesse : **0~4**. 
Lorsque le niveau de vitesse atteint le 4\ :sup:`ème` et que vous appuyez sur le bouton, 
le ventilateur s'arrête avec une vitesse de **0**.

Une fois que la température augmente ou diminue de plus de 2℃, la vitesse augmente ou diminue 
automatiquement d'un niveau.

Code
--------

.. note::
    Vous pouvez **Modifier/Réinitialiser/Copier/Exécuter/Arrêter** le code ci-dessous. Mais avant cela, vous devez accéder au chemin du code source comme ``raphael-kit/python``. Après avoir modifié le code, vous pouvez l'exécuter directement pour voir l'effet.

.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time
    import ADC0834
    import math

    # Set up pins
    MotorPin1   = 5
    MotorPin2   = 6
    MotorEnable = 13
    BtnPin  = 22


    def setup():
        global p_M1,p_M2
        ADC0834.setup()
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(MotorPin1, GPIO.OUT)
        GPIO.setup(MotorPin2, GPIO.OUT)
        p_M1=GPIO.PWM(MotorPin1,2000)
        p_M2=GPIO.PWM(MotorPin2,2000)
        p_M1.start(0)
        p_M2.start(0)
        GPIO.setup(MotorEnable, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(BtnPin, GPIO.IN)

    def temperature():
        analogVal = ADC0834.getResult()
        Vr = 5 * float(analogVal) / 255
        Rt = 10000 * Vr / (5 - Vr)
        temp = 1/(((math.log(Rt / 10000)) / 3950) + (1 / (273.15+25)))
        Cel = temp - 273.15
        Fah = Cel * 1.8 + 32
        return Cel

    def motor(level):
        if level == 0:
            GPIO.output(MotorEnable, GPIO.LOW)
            return 0
        if level>=4:
            level = 4
        GPIO.output(MotorEnable, GPIO.HIGH)
        p_M1.ChangeDutyCycle(level*25)
        return level


    def main():
        lastState=0
        level=0
        markTemp = temperature()
        while True:
            currentState =GPIO.input(BtnPin)
            currentTemp=temperature()
            if currentState == 1 and lastState == 0:
                level=(level+1)%5
                markTemp = currentTemp
                time.sleep(0.5)
            lastState=currentState
            if level!=0:
                if currentTemp-markTemp <= -2:
                    level = level -1
                    markTemp=currentTemp            
                if currentTemp-markTemp >= 2:
                    level = level +1
                    markTemp=currentTemp             
            level = motor(level)


    def destroy():
        GPIO.output(MotorEnable, GPIO.LOW)
        p_M1.stop()
        p_M2.stop()
        GPIO.cleanup()    

    if __name__ == '__main__':
        setup()
        try:
            main()
        except KeyboardInterrupt:
            destroy()


Explication du code
------------------------

.. code-block:: python

    def temperature():
        analogVal = ADC0834.getResult()
        Vr = 5 * float(analogVal) / 255
        Rt = 10000 * Vr / (5 - Vr)
        temp = 1/(((math.log(Rt / 10000)) / 3950) + (1 / (273.15+25)))
        Cel = temp - 273.15
        Fah = Cel * 1.8 + 32
        return Cel

La fonction ``temperature()`` convertit les valeurs du thermistor lues par **ADC0834** en valeurs 
de température. Référez-vous à :ref:`2.2.2_py` pour plus de détails.

.. code-block:: python

    def motor(level):
        if level == 0:
            GPIO.output(MotorEnable, GPIO.LOW)
            return 0
        if level>=4:
            level = 4
        GPIO.output(MotorEnable, GPIO.HIGH)
        p_M1.ChangeDutyCycle(level*25)
        return level

Cette fonction contrôle la vitesse de rotation du moteur. La plage de **level** : **0-4** 
(le niveau **0** arrête le moteur). Chaque niveau représente un changement de **25%** de la 
vitesse du ventilateur.

.. code-block:: python

    def main():
        lastState=0
        level=0
        markTemp = temperature()
        while True:
            currentState =GPIO.input(BtnPin)
            currentTemp=temperature()
            if currentState == 1 and lastState == 0:
                level=(level+1)%5
                markTemp = currentTemp
                time.sleep(0.5)
            lastState=currentState
            if level!=0:
                if currentTemp-markTemp <= -2:
                    level = level -1
                    markTemp=currentTemp            
                if currentTemp-markTemp >= 2:
                    level = level +1
                    markTemp=currentTemp             
            level = motor(level)


La fonction **main()** contient le processus complet du programme comme suit :

1) Lecture constante de l'état du bouton et de la température actuelle.

2) Chaque pression augmente le niveau de **+1** et en même temps, la température est mise à jour. 
Le **niveau** varie de **1 à 4**.

3) Lorsque le ventilateur fonctionne (le niveau n'est **pas 0**), la température est surveillée. 
Un changement de **2℃\ +** provoque une augmentation ou une diminution du niveau.

4) Le moteur ajuste la vitesse de rotation en fonction du **niveau**.


Image du phénomène
------------------------

.. image:: ../img/image246.png
   :align: center