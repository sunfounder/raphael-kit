.. note::

    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten.

    **Warum beitreten?**

    - **ExpertenunterstÃ¼tzung**: LÃ¶sen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams.
    - **Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre FÃ¤higkeiten zu verbessern.
    - **Exklusive Vorschauen**: Erhalten Sie frÃ¼hzeitigen Zugang zu neuen ProduktankÃ¼ndigungen und exklusiven Einblicken.
    - **Spezialrabatte**: GenieÃŸen Sie exklusive Rabatte auf unsere neuesten Produkte.
    - **Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil.

    ðŸ‘‰ Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!

.. _4.1.10_py:

4.1.10 Intelligenter Ventilator
================================

.. note::

   .. image:: ../img/mcp3008_and_adc0834.jpg
      :width: 25%
      :align: left

   AbhÃ¤ngig von Ihrer Kit-Version identifizieren Sie bitte, ob Sie **ADC0834** oder **MCP3008** haben, und fahren Sie mit dem entsprechenden Abschnitt fort.



EinfÃ¼hrung
-----------------

In diesem Projekt werden wir Motoren, Tasten und Thermistoren verwenden, um einen manuellen + automatischen intelligenten Ventilator zu bauen, dessen Windgeschwindigkeit einstellbar ist.

BenÃ¶tigte Komponenten
------------------------------

FÃ¼r dieses Projekt benÃ¶tigen wir folgende Komponenten.

.. image:: ../img/list_Smart_Fan.png
    :align: center

Es ist sicherlich praktisch, ein ganzes Kit zu kaufen. Hier ist der Link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Name
        - ARTIKEL IN DIESEM KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Sie kÃ¶nnen sie auch einzeln Ã¼ber die untenstehenden Links kaufen.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - KOMPONENTENBESCHREIBUNG
        - KAUF-LINK

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_power_module`
        - \-
    *   - :ref:`cpn_thermistor`
        - |link_thermistor_buy|
    *   - :ref:`cpn_l293d`
        - \-
    *   - :ref:`cpn_adc0834`
        - \-
    *   - :ref:`cpn_button`
        - |link_button_buy|
    *   - :ref:`cpn_motor`
        - |link_motor_buy|

Schaltplan
------------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin 15   3        22
GPIO5        Pin 29   21       5
GPIO6        Pin 31   22       6
GPIO13       Pin 33   23       13
============ ======== ======== ===

.. image:: ../img/Schematic_three_one4.png
   :align: center

Experimentelle Verfahren
-----------------------------

**Schritt 1:** Bauen Sie den Schaltkreis.

.. image:: ../img/image245.png

.. note::
    Das Strommodul kann eine 9V-Batterie mit der 9V-Batteriehalterung aus dem Kit verwenden. Setzen Sie den Jumper des Strommoduls in die 5V-Busleisten des Breadboards.

.. image:: ../img/image118.jpeg
   :align: center

**Schritt 2**: Wechseln Sie in den Ordner des Codes.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python

**Schritt 3**: Starten.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 4.1.10_SmartFan.py

Wenn der Code ausgefÃ¼hrt wird, starten Sie den Ventilator durch DrÃ¼cken der Taste. Jedes Mal, wenn Sie drÃ¼cken, wird die Geschwindigkeitsstufe um 1 erhÃ¶ht oder verringert. Es gibt **5** Geschwindigkeitsstufen: **0~4**. Wenn auf die 4. Geschwindigkeitsstufe eingestellt ist und Sie die Taste drÃ¼cken, stoppt der Ventilator mit einer Windgeschwindigkeit von **0**.

Wenn sich die Temperatur um mehr als 2â„ƒ erhÃ¶ht oder verringert, wird die Geschwindigkeit automatisch um 1 Stufe schneller oder langsamer.

Code
--------

.. note::
    Sie kÃ¶nnen den untenstehenden Code **Ã„ndern/ZurÃ¼cksetzen/Kopieren/AusfÃ¼hren/Stoppen**. Aber zuerst mÃ¼ssen Sie zum Quellcode-Pfad wie ``raphael-kit/python`` gehen. Nach dem Ã„ndern des Codes kÃ¶nnen Sie ihn direkt ausfÃ¼hren, um den Effekt zu sehen.

.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time
    import ADC0834
    import math

    # Set up pins
    MotorPin1   = 5
    MotorPin2   = 6
    MotorEnable = 13
    BtnPin  = 22


    def setup():
        global p_M1,p_M2
        ADC0834.setup()
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(MotorPin1, GPIO.OUT)
        GPIO.setup(MotorPin2, GPIO.OUT)
        p_M1=GPIO.PWM(MotorPin1,2000)
        p_M2=GPIO.PWM(MotorPin2,2000)
        p_M1.start(0)
        p_M2.start(0)
        GPIO.setup(MotorEnable, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(BtnPin, GPIO.IN)

    def temperature():
        analogVal = ADC0834.getResult()
        Vr = 5 * float(analogVal) / 255
        Rt = 10000 * Vr / (5 - Vr)
        temp = 1/(((math.log(Rt / 10000)) / 3950) + (1 / (273.15+25)))
        Cel = temp - 273.15
        Fah = Cel * 1.8 + 32
        return Cel

    def motor(level):
        if level == 0:
            GPIO.output(MotorEnable, GPIO.LOW)
            return 0
        if level>=4:
            level = 4
        GPIO.output(MotorEnable, GPIO.HIGH)
        p_M1.ChangeDutyCycle(level*25)
        return level


    def main():
        lastState=0
        level=0
        markTemp = temperature()
        while True:
            currentState =GPIO.input(BtnPin)
            currentTemp=temperature()
            if currentState == 1 and lastState == 0:
                level=(level+1)%5
                markTemp = currentTemp
                time.sleep(0.5)
            lastState=currentState
            if level!=0:
                if currentTemp-markTemp <= -2:
                    level = level -1
                    markTemp=currentTemp            
                if currentTemp-markTemp >= 2:
                    level = level +1
                    markTemp=currentTemp             
            level = motor(level)
            

    def destroy():
        GPIO.output(MotorEnable, GPIO.LOW)
        p_M1.stop()
        p_M2.stop()
        GPIO.cleanup()    

    if __name__ == '__main__':
        setup()
        try:
            main()
        except KeyboardInterrupt:
            destroy()


**Code-ErklÃ¤rung**

.. code-block:: python

    defÂ temperature():
    Â Â Â Â analogValÂ =Â ADC0834.getResult()
    Â Â Â Â VrÂ =Â 5Â *Â float(analogVal)Â /Â 255
    Â Â Â Â RtÂ =Â 10000Â *Â VrÂ /Â (5Â -Â Vr)
    Â Â Â Â tempÂ =Â 1/(((math.log(RtÂ /Â 10000))Â /Â 3950)Â +Â (1Â /Â (273.15+25)))
    Â Â Â Â CelÂ =Â tempÂ -Â 273.15
    Â Â Â Â FahÂ =Â CelÂ *Â 1.8Â +Â 32
    Â Â Â Â returnÂ Cel

``temperture()`` funktioniert, indem es Thermistor-Werte, die vom **ADC0834** gelesen werden, in Temperaturwerte umwandelt. Weitere Details finden Sie unter :ref:`2.2.2_py`.

.. code-block:: python

    defÂ motor(level):
    Â Â Â Â ifÂ levelÂ ==Â 0:
    Â Â Â Â Â Â Â Â GPIO.output(MotorEnable,Â GPIO.LOW)
    Â Â Â Â Â Â Â Â returnÂ 0
    Â Â Â Â ifÂ level>=4:
    Â Â Â Â Â Â Â Â levelÂ =Â 4
    Â Â Â Â GPIO.output(MotorEnable,Â GPIO.HIGH)
    Â Â Â Â p_M1.ChangeDutyCycle(level*25)
    Â Â Â Â returnÂ level


Diese Funktion steuert die Drehgeschwindigkeit des Motors. Der Bereich des **Hebels**: **0-4** (Stufe **0** stoppt den arbeitenden Motor). Eine Stufenanpassung entspricht einer **25%** Ã„nderung der Windgeschwindigkeit.

.. code-block:: python

    defÂ main():
    Â Â Â Â lastState=0
    Â Â Â Â level=0
    Â Â Â Â markTempÂ =Â temperature()
    Â Â Â Â whileÂ True:
    Â Â Â Â Â Â Â Â currentStateÂ =GPIO.input(BtnPin)
    Â Â Â Â Â Â Â Â currentTemp=temperature()
    Â Â Â Â Â Â Â Â ifÂ currentStateÂ ==Â 1Â andÂ lastStateÂ ==Â 0:
    Â Â Â Â Â Â Â Â Â Â Â Â level=(level+1)%5
    Â Â Â Â Â Â Â Â Â Â Â Â markTempÂ =Â currentTemp
    Â Â Â Â Â Â Â Â Â Â Â Â time.sleep(0.5)
    Â Â Â Â Â Â Â Â lastState=currentState
    Â Â Â Â Â Â Â Â ifÂ level!=0:
    Â Â Â Â Â Â Â Â Â Â Â Â ifÂ currentTemp-markTempÂ <=Â -2:
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â levelÂ =Â levelÂ -1
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â markTemp=currentTempÂ Â Â Â Â Â Â Â Â Â Â Â 
    Â Â Â Â Â Â Â Â Â Â Â Â ifÂ currentTemp-markTempÂ >=Â 2:
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â levelÂ =Â levelÂ +1
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â markTemp=currentTempÂ Â Â Â Â Â Â Â Â Â Â Â Â 
    Â Â Â Â Â Â Â Â levelÂ =Â motor(level)


Die Funktion **main()** enthÃ¤lt den gesamten Programmvorgang, wie folgt dargestellt:

1) StÃ¤ndiges Auslesen des Tastenzustands und der aktuellen Temperatur.

2) Jeder Tastendruck erhÃ¶ht die Stufe um **+1** und gleichzeitig wird die Temperatur aktualisiert. Der **Level** reicht von **1~4**.

3) WÃ¤hrend der Ventilator arbeitet (die Stufe ist **nicht 0**), wird die Temperatur Ã¼berwacht. Eine Ã„nderung von **+2â„ƒ** fÃ¼hrt zur ErhÃ¶hung oder Verringerung der Stufe.

4) Der Motor Ã¤ndert die Drehgeschwindigkeit entsprechend dem **Level**.

PhÃ¤nomen-Bild
------------------------

.. image:: ../img/image246.png
   :align: center