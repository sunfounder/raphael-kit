 
.. note::

    Bonjour et bienvenue dans la CommunautÃ© Facebook des passionnÃ©s de Raspberry Pi, Arduino et ESP32 de SunFounder ! Plongez plus profondÃ©ment dans l'univers des Raspberry Pi, Arduino et ESP32 avec d'autres passionnÃ©s.

    **Pourquoi rejoindre ?**

    - **Support d'experts** : RÃ©solvez les problÃ¨mes aprÃ¨s-vente et les dÃ©fis techniques avec l'aide de notre communautÃ© et de notre Ã©quipe.
    - **Apprendre et partager** : Ã‰changez des astuces et des tutoriels pour amÃ©liorer vos compÃ©tences.
    - **AperÃ§us exclusifs** : AccÃ©dez en avant-premiÃ¨re aux annonces de nouveaux produits et aux aperÃ§us.
    - **RÃ©ductions spÃ©ciales** : Profitez de rÃ©ductions exclusives sur nos produits les plus rÃ©cents.
    - **Promotions festives et cadeaux** : Participez Ã  des cadeaux et des promotions de vacances.

    ğŸ‘‰ PrÃªt Ã  explorer et Ã  crÃ©er avec nous ? Cliquez [|link_sf_facebook|] et rejoignez-nous aujourd'hui !

.. _4.1.17_py:

4.1.17 JEU - Devinez le Nombre
==============================================

Introduction
------------------

Devinez le Nombre est un jeu amusant pour les fÃªtes oÃ¹ vous et vos amis tour Ã  tour 
saisissez un nombre (0~99). La plage de nombres devient plus petite Ã  chaque saisie 
jusqu'Ã  ce qu'un joueur trouve le bon nombre. Ensuite, le joueur est battu et puni. 
Par exemple, si le nombre chanceux est 51 que les joueurs ne peuvent pas voir, et 
que le joueur â‘  saisit 50, l'intervalle de nombres change Ã  50~99 ; si le joueur â‘¡ 
saisit 70, l'intervalle de nombres devient 50~70 ; si le joueur â‘¢ saisit 51, ce 
joueur est le malchanceux. Ici, nous utilisons un pavÃ© numÃ©rique pour entrer les 
nombres et un Ã©cran LCD pour afficher les rÃ©sultats.


Composants Requis
------------------------------

Pour ce projet, nous avons besoin des composants suivants.

.. image:: ../img/list_GAME_Guess_Number.png
    :align: center

Il est certainement pratique d'acheter un kit complet, voici le lien :

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom	
        - Ã‰LÃ‰MENTS DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez Ã©galement les acheter sÃ©parÃ©ment Ã  partir des liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DU COMPOSANT
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_keypad`
        - \-
    *   - :ref:`cpn_i2c_lcd`
        - |link_i2clcd1602_buy|


SchÃ©ma de CÃ¢blage
-----------------------

============ ======== ======== =======
Nom T-Board  physique wiringPi BCM
GPIO18       Pin 12   1        18
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
GPIO25       Pin 22   6        25
SPIMOSI      Pin 19   12       10
GPIO22       Pin 15   3        22
GPIO27       Pin 13   2        27
GPIO17       Pin 11   0        17
SDA1         Pin 3    SDA1(8)  SDA1(2)
SCL1         Pin 5    SCL1(9)  SDA1(3)
============ ======== ======== =======

.. image:: ../img/Schematic_three_one12.png
   :align: center

ProcÃ©dures ExpÃ©rimentales
-----------------------------

**Ã‰tape 1 :** Construisez le circuit.

.. image:: ../img/image273.png

**Ã‰tape 2** : Configurer l'I2C (voir :ref:`i2c_config`.)

**Ã‰tape 3** : Changez de rÃ©pertoire.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python/

**Ã‰tape 4** : ExÃ©cutez.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 4.1.17_GAME_GuessNumber.py

AprÃ¨s l'exÃ©cution du programme, la page initiale s'affiche sur le LCD :

.. code-block:: 

   Welcome!
   PressÂ AÂ toÂ go!

Appuyez sur â€˜Aâ€™, et le jeu commencera et la page de jeu apparaÃ®tra sur le LCD.

.. code-block:: 

   Enter number:
   0 â€¹pointâ€¹ 99

Un nombre alÃ©atoire â€˜\ **point**\ â€™ est produit mais non affichÃ© sur le LCD lorsque 
le jeu commence, et ce que vous devez faire est de le deviner. Le nombre que vous 
avez tapÃ© apparaÃ®t Ã  la fin de la premiÃ¨re ligne jusqu'Ã  ce que le calcul final soit 
terminÃ©. (Appuyez sur â€˜Dâ€™ pour dÃ©marrer la comparaison, et si le nombre saisi est supÃ©rieur 
Ã  **10**, la comparaison automatique commencera.)

La plage de nombres de â€˜pointâ€™ est affichÃ©e sur la deuxiÃ¨me ligne. Et vous devez taper le 
nombre dans la plage. Lorsque vous tapez un nombre, la plage se rÃ©trÃ©cit ; si vous avez trouvÃ© 
le nombre chanceux par chance ou par malchance, il y aura l'affichage â€œYou'veÂ gotÂ it!â€

.. note::

    * Si vous obtenez l'erreur ``FileNotFoundError: [Errno 2] No such file or directory: '/dev/i2c-1'``, vous devez vous rÃ©fÃ©rer Ã  :ref:`i2c_config` pour activer l'I2C.
    * Si vous obtenez l'erreur ``ModuleNotFoundError: No module named 'smbus2'``, veuillez exÃ©cuter ``sudo pip3 install smbus2``.
    * Si l'erreur ``OSError: [Errno 121] Remote I/O error`` apparaÃ®t, cela signifie que le module est mal cÃ¢blÃ© ou qu'il est dÃ©fectueux.
    * Si le code et le cÃ¢blage sont corrects, mais que l'Ã©cran LCD ne s'affiche toujours pas, vous pouvez tourner le potentiomÃ¨tre Ã  l'arriÃ¨re pour augmenter le contraste.

**Code**

.. note::
    Vous pouvez **Modifier/RÃ©initialiser/Copier/ExÃ©cuter/ArrÃªter** le code ci-dessous. Mais avant cela, vous devez aller dans le chemin du code source comme ``raphael-kit/python``. AprÃ¨s avoir modifiÃ© le code, vous pouvez l'exÃ©cuter directement pour voir l'effet.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3

   import RPi.GPIO as GPIO
   import time
   import LCD1602
   import random

   ##################### HERE IS THE KEYPAD LIBRARY TRANSPLANTED FROM Arduino ############
   #class Key:Define some of the properties of Key
   class Keypad():

      def __init__(self, rowsPins, colsPins, keys):
         self.rowsPins = rowsPins
         self.colsPins = colsPins
         self.keys = keys
         GPIO.setwarnings(False)
         GPIO.setmode(GPIO.BCM)
         GPIO.setup(self.rowsPins, GPIO.OUT, initial=GPIO.LOW)
         GPIO.setup(self.colsPins, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

      def read(self):
         pressed_keys = []
         for i, row in enumerate(self.rowsPins):
               GPIO.output(row, GPIO.HIGH)
               for j, col in enumerate(self.colsPins):
                  index = i * len(self.colsPins) + j
                  if (GPIO.input(col) == 1):
                     pressed_keys.append(self.keys[index])
               GPIO.output(row, GPIO.LOW)
         return pressed_keys

   ################ EXAMPLE CODE START HERE ################  

   count = 0
   pointValue = 0
   upper=99
   lower=0

   def setup():
      global keypad, last_key_pressed,keys
      rowsPins = [18,23,24,25]
      colsPins = [10,22,27,17]
      keys = ["1","2","3","A",
               "4","5","6","B",
               "7","8","9","C",
               "*","0","#","D"]
      keypad = Keypad(rowsPins, colsPins, keys)
      last_key_pressed = []
      LCD1602.init(0x27, 1)    # init(slave address, background light)
      LCD1602.clear()
      LCD1602.write(0, 0, 'Welcome!')
      LCD1602.write(0, 1, 'Press A to Start!')

   def init_new_value():
      global pointValue,upper,count,lower
      pointValue = random.randint(0,99)
      upper = 99
      lower = 0
      count = 0
      print('point is %d' %(pointValue))
      
   def detect_point():
      global count,upper,lower
      if count > pointValue:
         if count < upper:
               upper = count 
      elif count < pointValue:
         if count > lower:
               lower = count
      elif count == pointValue:
         count = 0
         return 1
      count = 0
      return 0

   def lcd_show_input(result):
      LCD1602.clear()
      if result == 1:
         LCD1602.write(0,1,'You have got it!')
         time.sleep(5)
         init_new_value()
         lcd_show_input(0)
         return
      LCD1602.write(0,0,'Enter number:')
      LCD1602.write(13,0,str(count))
      LCD1602.write(0,1,str(lower))
      LCD1602.write(3,1,' < Point < ')
      LCD1602.write(13,1,str(upper))

   def loop():
      global keypad, last_key_pressed,count
      while(True):
         result = 0
         pressed_keys = keypad.read()
         if len(pressed_keys) != 0 and last_key_pressed != pressed_keys:
               if pressed_keys == ["A"]:
                  init_new_value()
                  lcd_show_input(0)
               elif pressed_keys == ["D"]:
                  result = detect_point()
                  lcd_show_input(result)
               elif pressed_keys[0] in keys:
                  if pressed_keys[0] in list(["A","B","C","D","#","*"]):
                     continue
                  count = count * 10
                  count += int(pressed_keys[0])
                  if count >= 10:
                     result = detect_point()
                  lcd_show_input(result)
               print(pressed_keys)
         last_key_pressed = pressed_keys
         time.sleep(0.1)

   # Define a destroy function for clean up everything after the script finished
   def destroy():
      # Release resource
      GPIO.cleanup()
      LCD1602.clear() 

   if __name__ == '__main__':     # Program start from here
      try:
         setup()
         while True:
               loop()
      except KeyboardInterrupt:   # When 'Ctrl+C' is pressed, the program destroy() will be executed.
         destroy()

**Explication du Code**

Au dÃ©but du code, il y a les fonctions de **keypad** et **I2C LCD1602**. Vous pouvez en apprendre 
plus sur elles dans :ref:`1.1.7_py` et :ref:`2.1.8_py`.

Voici ce que nous devons savoir :

.. code-block:: python

    defÂ init_new_value():
    Â Â Â Â globalÂ pointValue,upper,count,lower
    Â Â Â Â pointValueÂ =Â random.randint(0,99)
    Â Â Â Â upperÂ =Â 99
    Â Â Â Â lowerÂ =Â 0
    Â Â Â Â countÂ =Â 0
    Â Â Â Â print('pointÂ isÂ %d'Â %(pointValue))

Cette fonction gÃ©nÃ¨re le nombre alÃ©atoire â€˜\ **point**\ â€™ et rÃ©initialise l'indication de 
la plage du point.

.. code-block:: python

    defÂ detect_point():
    Â Â Â Â globalÂ count,upper,lower
    Â Â Â Â ifÂ countÂ >Â pointValue:
    Â Â Â Â Â Â Â Â ifÂ countÂ <Â upper:
    Â Â Â Â Â Â Â Â Â Â Â Â upperÂ =Â countÂ 
    Â Â Â Â elifÂ countÂ <Â pointValue:
    Â Â Â Â Â Â Â Â ifÂ countÂ >Â lower:
    Â Â Â Â Â Â Â Â Â Â Â Â lowerÂ =Â count
    Â Â Â Â elifÂ countÂ ==Â pointValue:
    Â Â Â Â Â Â Â Â countÂ =Â 0
    Â Â Â Â Â Â Â Â returnÂ 1
    Â Â Â Â countÂ =Â 0
    Â Â Â Â returnÂ 0

``detect_point()`` compare le nombre entrÃ© (**count**) avec le nombre gÃ©nÃ©rÃ© â€œ\ **point**\ â€. 
Si le rÃ©sultat de la comparaison est diffÃ©rent, **count** attribuera des valeurs Ã  **upper** et **lower** et retournera â€˜\ **0**\ â€™; sinon, 
s'ils sont identiques, la fonction retourne â€˜\ **1**\ â€™.

.. code-block:: python

    defÂ lcd_show_input(result):
    Â Â Â Â LCD1602.clear()
    Â Â Â Â ifÂ resultÂ ==Â 1:
    Â Â Â Â Â Â Â Â LCD1602.write(0,1,'YouÂ haveÂ gotÂ it!')
    Â Â Â Â Â Â Â Â time.sleep(5)
    Â Â Â Â Â Â Â Â init_new_value()
    Â Â Â Â Â Â Â Â lcd_show_input(0)
    Â Â Â Â Â Â Â Â return
    Â Â Â Â LCD1602.write(0,0,'EnterÂ number:')
    Â Â Â Â LCD1602.write(13,0,str(count))
    Â Â Â Â LCD1602.write(0,1,str(lower))
    Â Â Â Â LCD1602.write(3,1,'Â <Â PointÂ <Â ')
    Â Â Â Â LCD1602.write(13,1,str(upper))

Cette fonction sert Ã  afficher la page du jeu.

``str(count)``: Parce que ``write()`` ne supporte que le type de donnÃ©es â€” **string**, 
``str()`` est nÃ©cessaire pour convertir le **nombre** en **chaÃ®ne**.

.. code-block:: python

    defÂ loop():
    Â Â Â Â globalÂ keypad,Â last_key_pressed,count
    Â Â Â Â while(True):
    Â Â Â Â Â Â Â Â resultÂ =Â 0
    Â Â Â Â Â Â Â Â pressed_keysÂ =Â keypad.read()
    Â Â Â Â Â Â Â Â ifÂ len(pressed_keys)Â !=Â 0Â andÂ last_key_pressedÂ !=Â pressed_keys:
    Â Â Â Â Â Â Â Â Â Â Â Â ifÂ pressed_keysÂ ==Â ["A"]:
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â init_new_value()
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â lcd_show_input(0)
    Â Â Â Â Â Â Â Â Â Â Â Â elifÂ pressed_keysÂ ==Â ["D"]:
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resultÂ =Â detect_point()
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â lcd_show_input(result)
    Â Â Â Â Â Â Â Â Â Â Â Â elifÂ pressed_keys[0]Â inÂ keys:
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ pressed_keys[0]Â inÂ list(["A","B","C","D","#","*"]):
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â continue
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â countÂ =Â countÂ *Â 10
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â countÂ +=Â int(pressed_keys[0])
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ countÂ >=Â 10:
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resultÂ =Â detect_point()
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â lcd_show_input(result)
    Â Â Â Â Â Â Â Â Â Â Â Â print(pressed_keys)
    Â Â Â Â Â Â Â Â last_key_pressedÂ =Â pressed_keys
    Â Â Â Â Â Â Â Â time.sleep(0.1)
Â Â Â 

``main()`` contient tout le processus du programme, comme montrÃ© ci-dessous :

1) Initialiser **I2C LCD1602** et **Keypad**.

2) VÃ©rifier si un bouton est pressÃ© et obtenir la lecture du bouton.

3) Si le bouton â€˜\ **A**\ â€™ est pressÃ©, un nombre alÃ©atoire **0-99** apparaÃ®tra et le jeu commence.

4) Si le bouton â€˜\ **D**\ â€™ est dÃ©tectÃ© comme Ã©tant pressÃ©, le programme passera au jugement du rÃ©sultat.

5) Si le bouton **0-9** est pressÃ©, la valeur de **count** changera ; si le **count** est supÃ©rieur Ã  **10**, le jugement commence.

6) Les changements du jeu et ses valeurs sont affichÃ©s sur **LCD1602**.

Image du PhÃ©nomÃ¨ne
------------------------

.. image:: ../img/image274.jpeg
   :align: center