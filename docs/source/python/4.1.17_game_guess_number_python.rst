.. nota::

    Â¡Hola! Bienvenido a la Comunidad de Entusiastas de SunFounder Raspberry Pi & Arduino & ESP32 en Facebook. SumÃ©rgete mÃ¡s en Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **Â¿Por quÃ© unirse?**

    - **Soporte experto**: Resuelve problemas postventa y desafÃ­os tÃ©cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprende y comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Previsualizaciones exclusivas**: ObtÃ©n acceso anticipado a nuevos anuncios de productos y adelantos.
    - **Descuentos especiales**: Disfruta de descuentos exclusivos en nuestros productos mÃ¡s nuevos.
    - **Promociones y sorteos festivos**: Participa en sorteos y promociones navideÃ±as.

    ğŸ‘‰ Â¿Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y Ãºnete hoy mismo.

.. _4.1.17_py:

4.1.17 JUEGO â€“ Adivina el NÃºmero
==============================================

IntroducciÃ³n
------------------

Adivinar NÃºmeros es un divertido juego de fiesta donde tÃº y tus amigos toman 
turnos para ingresar un nÃºmero (0~99). El rango serÃ¡ mÃ¡s pequeÃ±o con la entrada 
del nÃºmero hasta que un jugador responda el acertijo correctamente. Entonces el 
jugador es derrotado y castigado. Por ejemplo, si el nÃºmero de la suerte es 51, 
que los jugadores no pueden ver, y el jugador â‘  ingresa 50, el rango de nÃºmeros 
cambia a 50~99; si el jugador â‘¡ ingresa 70, el rango de nÃºmeros puede ser 50~70; 
si el jugador â‘¢ ingresa 51, este jugador es el desafortunado. AquÃ­, usamos un 
teclado para ingresar nÃºmeros y una pantalla LCD para mostrar los resultados.


Componentes necesarios
------------------------------

En este proyecto, necesitamos los siguientes componentes.

.. image:: ../img/list_GAME_Guess_Number.png
    :align: center

Es definitivamente conveniente comprar un kit completo, aquÃ­ estÃ¡ el enlace: 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre	
        - ARTÃCULOS EN ESTE KIT
        - ENLACE
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

TambiÃ©n puedes comprarlos por separado en los enlaces a continuaciÃ³n.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCIÃ“N DEL COMPONENTE
        - ENLACE DE COMPRA

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_keypad`
        - \-
    *   - :ref:`cpn_i2c_lcd`
        - |link_i2clcd1602_buy|


Diagrama esquemÃ¡tico
-------------------------

============== ========== ======== =======
Nombre T-Board Pin fÃ­sico wiringPi BCM
GPIO18         Pin 12     1        18
GPIO23         Pin 16     4        23
GPIO24         Pin 18     5        24
GPIO25         Pin 22     6        25
SPIMOSI        Pin 19     12       10
GPIO22         Pin 15     3        22
GPIO27         Pin 13     2        27
GPIO17         Pin 11     0        17
SDA1           Pin 3      SDA1(8)  SDA1(2)
SCL1           Pin 5      SCL1(9)  SDA1(3)
============== ========== ======== =======

.. image:: ../img/Schematic_three_one12.png
   :align: center

Procedimientos Experimentales
---------------------------------

**Paso 1:** Construye el circuito.

.. image:: ../img/image273.png

**Paso 2**: Configura I2C (ver :ref:`i2c_config`).

**Paso 3**: Cambia de directorio.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python/

**Paso 4**: Ejecuta.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 4.1.17_GAME_GuessNumber.py

DespuÃ©s de que el programa se ejecute, se muestra la pÃ¡gina inicial en la LCD:

.. code-block:: 

   Welcome!
   Press A to go!

Presiona 'A' y el juego comenzarÃ¡ y la pÃ¡gina del juego aparecerÃ¡ en la LCD.

.. code-block:: 

   Enter number:
   0 â€¹puntoâ€¹ 99

Se produce un nÃºmero aleatorio 'punto' pero no se muestra en la LCD cuando el 
juego comienza, y lo que necesitas hacer es adivinarlo. El nÃºmero que has escrito 
aparece al final de la primera lÃ­nea hasta que se finaliza el cÃ¡lculo. (Presiona 
'D' para iniciar la comparaciÃ³n, y si el nÃºmero ingresado es mayor que 10, la 
comparaciÃ³n automÃ¡tica comenzarÃ¡).

El rango de nÃºmeros de 'punto' se muestra en la segunda lÃ­nea. Y debes escribir el 
nÃºmero dentro del rango. Cuando escribes un nÃºmero, el rango se reduce; si adivinaste 
el nÃºmero de la suerte afortunada o desafortunadamente, aparecerÃ¡ "Â¡Lo conseguiste!".



.. nota::

    * Si obtienes el error ``FileNotFoundError: [Errno 2] No such file or directory: '/dev/i2c-1'``, necesitas consultar :ref:`i2c_config` para habilitar el I2C.
    * Si obtienes el error ``ModuleNotFoundError: No module named 'smbus2'``, por favor ejecuta ``sudo pip3 install smbus2``.
    * Si aparece el error ``OSError: [Errno 121] Remote I/O error``, significa que el mÃ³dulo estÃ¡ mal conectado o estÃ¡ daÃ±ado.
    * Si el cÃ³digo y las conexiones estÃ¡n bien, pero la LCD aÃºn no muestra contenido, puedes girar el potenciÃ³metro en la parte posterior para aumentar el contraste.

**CÃ³digo**

.. nota::
    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el cÃ³digo a continuaciÃ³n. Pero antes de eso, necesitas ir a la ruta del cÃ³digo fuente como ``raphael-kit/python``. DespuÃ©s de modificar el cÃ³digo, puedes ejecutarlo directamente para ver el efecto.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3

   import RPi.GPIO as GPIO
   import time
   import LCD1602
   import random

   ##################### AQUÃ ESTÃ LA LIBRERÃA DE TECLADO TRANSPLANTADA DESDE Arduino ############
   #class Key: Define algunas propiedades de Key
   class Keypad():

      def __init__(self, rowsPins, colsPins, keys):
         self.rowsPins = rowsPins
         self.colsPins = colsPins
         self.keys = keys
         GPIO.setwarnings(False)
         GPIO.setmode(GPIO.BCM)
         GPIO.setup(self.rowsPins, GPIO.OUT, initial=GPIO.LOW)
         GPIO.setup(self.colsPins, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

      def read(self):
         pressed_keys = []
         for i, row in enumerate(self.rowsPins):
               GPIO.output(row, GPIO.HIGH)
               for j, col in enumerate(self.colsPins):
                  index = i * len(self.colsPins) + j
                  if (GPIO.input(col) == 1):
                     pressed_keys.append(self.keys[index])
               GPIO.output(row, GPIO.LOW)
         return pressed_keys

   ################ EL CÃ“DIGO DE EJEMPLO EMPIEZA AQUÃ ################  

   count = 0
   pointValue = 0
   upper=99
   lower=0

   def setup():
      global keypad, last_key_pressed,keys
      rowsPins = [18,23,24,25]
      colsPins = [10,22,27,17]
      keys = ["1","2","3","A",
               "4","5","6","B",
               "7","8","9","C",
               "*","0","#","D"]
      keypad = Keypad(rowsPins, colsPins, keys)
      last_key_pressed = []
      LCD1602.init(0x27, 1)    # init(slave address, background light)
      LCD1602.clear()
      LCD1602.write(0, 0, 'Welcome!')
      LCD1602.write(0, 1, 'Press A to Start!')

   def init_new_value():
      global pointValue,upper,count,lower
      pointValue = random.randint(0,99)
      upper = 99
      lower = 0
      count = 0
      print('point is %d' %(pointValue))
      
   def detect_point():
      global count,upper,lower
      if count > pointValue:
         if count < upper:
               upper = count 
      elif count < pointValue:
         if count > lower:
               lower = count
      elif count == pointValue:
         count = 0
         return 1
      count = 0
      return 0

   def lcd_show_input(result):
      LCD1602.clear()
      if result == 1:
         LCD1602.write(0,1,'You have got it!')
         time.sleep(5)
         init_new_value()
         lcd_show_input(0)
         return
      LCD1602.write(0,0,'Enter number:')
      LCD1602.write(13,0,str(count))
      LCD1602.write(0,1,str(lower))
      LCD1602.write(3,1,' < Point < ')
      LCD1602.write(13,1,str(upper))

   def loop():
      global keypad, last_key_pressed,count
      while(True):
         result = 0
         pressed_keys = keypad.read()
         if len(pressed_keys) != 0 and last_key_pressed != pressed_keys:
               if pressed_keys == ["A"]:
                  init_new_value()
                  lcd_show_input(0)
               elif pressed_keys == ["D"]:
                  result = detect_point()
                  lcd_show_input(result)
               elif pressed_keys[0] in keys:
                  if pressed_keys[0] in list(["A","B","C","D","#","*"]):
                     continue
                  count = count * 10
                  count += int(pressed_keys[0])
                  if count >= 10:
                     result = detect_point()
                  lcd_show_input(result)
               print(pressed_keys)
         last_key_pressed = pressed_keys
         time.sleep(0.1)

   # Define una funciÃ³n destroy para limpiar todo despuÃ©s de que el script termine
   def destroy():
      # Liberar recursos
      GPIO.cleanup()
      LCD1602.clear() 

   if __name__ == '__main__':     # Program start from here
      try:
         setup()
         while True:
               loop()
      except KeyboardInterrupt:   # Cuando se presiona 'Ctrl+C', se ejecutarÃ¡ la funciÃ³n destroy().
         destroy()

**ExplicaciÃ³n del CÃ³digo**

En la parte inicial del cÃ³digo se encuentran las funciones funcionales 
del **teclado** y del **I2C LCD1602**. Puedes aprender mÃ¡s detalles sobre 
ellas en :ref:`1.1.7_py` y :ref:`2.1.8_py`.

AquÃ­, lo que necesitamos saber es lo siguiente:

.. code-block:: python

    defÂ init_new_value():
    Â Â Â Â globalÂ pointValue,upper,count,lower
    Â Â Â Â pointValueÂ =Â random.randint(0,99)
    Â Â Â Â upperÂ =Â 99
    Â Â Â Â lowerÂ =Â 0
    Â Â Â Â countÂ =Â 0
    Â Â Â Â print('pointÂ isÂ %d'Â %(pointValue))

La funciÃ³n produce el nÃºmero aleatorio â€˜\ **point**\ â€™ y restablece el rango de pistas del punto.

.. code-block:: python

    defÂ detect_point():
    Â Â Â Â globalÂ count,upper,lower
    Â Â Â Â ifÂ countÂ >Â pointValue:
    Â Â Â Â Â Â Â Â ifÂ countÂ <Â upper:
    Â Â Â Â Â Â Â Â Â Â Â Â upperÂ =Â countÂ 
    Â Â Â Â elifÂ countÂ <Â pointValue:
    Â Â Â Â Â Â Â Â ifÂ countÂ >Â lower:
    Â Â Â Â Â Â Â Â Â Â Â Â lowerÂ =Â count
    Â Â Â Â elifÂ countÂ ==Â pointValue:
    Â Â Â Â Â Â Â Â countÂ =Â 0
    Â Â Â Â Â Â Â Â returnÂ 1
    Â Â Â Â countÂ =Â 0
    Â Â Â Â returnÂ 0

``detect_point()`` compara el nÃºmero ingresado (**count**) con el nÃºmero 
producido â€œ\ **point**\ â€. Si el resultado de la comparaciÃ³n indica que no 
son iguales, **count** asignarÃ¡ valores a **upper** y **lower** y devolverÃ¡ 
â€˜\ **0**\ â€™; de lo contrario, si el resultado indica que son iguales, se devolverÃ¡ â€˜\ **1**\ â€™.

.. code-block:: python

    defÂ lcd_show_input(result):
        LCD1602.clear()
    Â Â Â Â ifÂ resultÂ ==Â 1:
    Â Â Â Â Â Â Â Â LCD1602.write(0,1,'YouÂ haveÂ gotÂ it!')
            time.sleep(5)
            init_new_value()
            lcd_show_input(0)
            return
    Â Â Â Â LCD1602.write(0,0,'EnterÂ number:')
    Â Â Â Â LCD1602.write(13,0,str(count))
    Â Â Â Â LCD1602.write(0,1,str(lower))
    Â Â Â Â LCD1602.write(3,1,'Â <Â PointÂ <Â ')
    Â Â Â Â LCD1602.write(13,1,str(upper))

Esta funciÃ³n se utiliza para mostrar la pÃ¡gina del juego.

``str(count)``: Debido a que ``write()`` solo puede soportar el tipo de 
dato â€” **cadena** , se necesita ``str()`` para convertir el **nÃºmero** en **cadena**.

.. code-block:: python

    defÂ loop():
    Â Â Â Â globalÂ keypad,Â last_key_pressed,count
        while(True):
    Â Â Â Â Â Â Â Â resultÂ =Â 0
    Â Â Â Â Â Â Â Â pressed_keysÂ =Â keypad.read()
    Â Â Â Â Â Â Â Â ifÂ len(pressed_keys)Â !=Â 0Â andÂ last_key_pressedÂ !=Â pressed_keys:
    Â Â Â Â Â Â Â Â Â Â Â Â ifÂ pressed_keysÂ ==Â ["A"]:
                    init_new_value()
                    lcd_show_input(0)
    Â Â Â Â Â Â Â Â Â Â Â Â elifÂ pressed_keysÂ ==Â ["D"]:
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resultÂ =Â detect_point()
                    lcd_show_input(result)
    Â Â Â Â Â Â Â Â Â Â Â Â elifÂ pressed_keys[0]Â inÂ keys:
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ pressed_keys[0]Â inÂ list(["A","B","C","D","#","*"]):
                        continue
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â countÂ =Â countÂ *Â 10
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â countÂ +=Â int(pressed_keys[0])
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ countÂ >=Â 10:
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resultÂ =Â detect_point()
                    lcd_show_input(result)
                print(pressed_keys)
    Â Â Â Â Â Â Â Â last_key_pressedÂ =Â pressed_keys
            time.sleep(0.1)

``main()`` contiene todo el proceso del programa, como se muestra a continuaciÃ³n:

1) Inicializa **I2C LCD1602** y **Keypad**.

2) Juzga si se ha presionado el botÃ³n y obtiene la lectura del botÃ³n.

3) Si se presiona el botÃ³n â€˜\ **A**\ â€™, aparecerÃ¡ un nÃºmero aleatorio **0-99** y 
   luego comenzarÃ¡ el juego.

4) Si se detecta que el botÃ³n â€˜\ **D**\ â€™ ha sido presionado, el programa entrarÃ¡ 
   en el juicio del resultado.

5) Si se presiona el botÃ³n **0-9**, el valor de **count** cambiarÃ¡; si **count** es 
   mayor que **10**, entonces comenzarÃ¡ el juicio.

6) Los cambios del juego y sus valores se muestran en **LCD1602**.

Imagen del FenÃ³meno
------------------------

.. image:: ../img/image274.jpeg
   :align: center
