.. note::

    Bonjour et bienvenue dans la communautÃ© SunFounder RaspberryÂ Pi & Arduino & ESP32 sur FacebookÂ ! 
    Plongez plus profondÃ©ment dans lâ€™univers RaspberryÂ Pi, Arduino et ESP32 avec dâ€™autres passionnÃ©s.

    **Pourquoi rejoindreÂ ?**

    - **Support dâ€™expertsÂ :** RÃ©solvez les problÃ¨mes aprÃ¨sâ€‘vente et les dÃ©fis techniques avec lâ€™aide de notre communautÃ© et de notre Ã©quipe.
    - **Apprendre et partagerÂ :** Ã‰changez des astuces et des tutoriels pour amÃ©liorer vos compÃ©tences.
    - **AperÃ§us exclusifsÂ :** Obtenez un accÃ¨s anticipÃ© aux annonces de nouveaux produits et aux avantâ€‘premiÃ¨res.
    - **RÃ©ductions spÃ©cialesÂ :** Profitez de remises exclusives sur nos derniers produits.
    - **Promotions et concours festifsÂ :** Participez Ã  des concours et promotions de vacances.

    ğŸ‘‰ PrÃªt Ã  explorer et crÃ©er avec nousÂ ? Cliquez sur [|link_sf_facebook|] et rejoignezâ€‘nous dÃ¨s aujourdâ€™huiÂ !

.. _4.1.11_py_mcp3008:

4.1.11 Indicateur de batterie (MCP3008)
=======================================

.. note::

   .. image:: ../img/mcp3008_and_adc0834.jpg
      :width: 25%
      :align: left
    

   Selon la version de votre kit, veuillez identifier si vous avez **ADC0834** ou **MCP3008** et suivre la section correspondante.

Introduction
------------

Dans ce projet, nous allons crÃ©er un indicateur de batterie qui peut afficher visuellement 
le niveau de charge sur une barre de LED.

.. warning::

    Nâ€™utilisez pas de composants de batterie dÃ©passant 3,3Â V afin dâ€™Ã©viter une surcharge, ce qui pourrait endommager la puce ou le RaspberryÂ Pi.

Composants requis
-----------------

Dans ce projet, nous avons besoin des composants suivantsÂ :

.. image:: ../img/list2_Battery_Indicator.png
    :align: center

Il est Ã©videmment plus pratique dâ€™acheter un kit complet, voici le lienÂ :

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom
        - Ã‰LÃ‰MENTS DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez Ã©galement les acheter sÃ©parÃ©ment via les liens ciâ€‘dessousÂ :

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DU COMPOSANT
        - LIEN Dâ€™ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_bar_graph`
        - \-
    *   - :ref:`cpn_mcp3008`
        - \-

SchÃ©ma
------

============ ======== ======== ===
Nom T-Board  physique WiringPi BCM
SPICE0       PinÂ 24   10       8
SPIMOSI      PinÂ 19   12       10
SPIMISO      PinÂ 21   13       9
SPISCLK      PinÂ 23   14       11
GPIO25       PinÂ 22   6        25
GPIO12       PinÂ 32   26       12
GPIO16       PinÂ 36   27       16
GPIO20       PinÂ 38   28       20
GPIO21       PinÂ 40   29       21
GPIO5        PinÂ 29   21       5
GPIO6        PinÂ 31   22       6
GPIO13       PinÂ 33   23       13
GPIO19       PinÂ 35   24       19
GPIO26       PinÂ 37   25       26
============ ======== ======== ===

.. image:: ../img/schematic_battery_indicator_mcp3008.png
   :align: center

ProcÃ©dure expÃ©rimentale
-----------------------

**Ã‰tapeÂ 1Â :** Construire le circuit.

.. image:: ../img/july24_3.1.5_battery_indicator_mcp3008.png

**Ã‰tapeÂ 2Â :** Configurer lâ€™interface SPI et installer la bibliothÃ¨que ``spidev`` (voir :ref:`spi_configuration` pour des instructions dÃ©taillÃ©es).  
Si vous avez dÃ©jÃ  effectuÃ© ces Ã©tapes, vous pouvez les ignorer.

**Ã‰tapeÂ 3Â :** AccÃ©der au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python

**Ã‰tapeÂ 4Â :** ExÃ©cuter le fichier.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 4.1.11-2_BatteryIndicator.py

Une fois le programme lancÃ©, connectez un fil entre la 3áµ‰Â broche du MCP3008 et la borne positive de la batterie, 
et un autre fil entre le GND et la borne nÃ©gative. Vous verrez la barre de LED sâ€™allumer pour afficher le niveau de charge (plage de mesureÂ :Â 0Â â€“Â 5Â V).

.. warning::

    Si un message dâ€™erreur sâ€™afficheÂ : ``RuntimeError: Cannot determine SOC peripheral base address``, reportezâ€‘vous Ã  :ref:`faq_soc`.

Code
----

.. note::
    Vous pouvez **Modifier/RÃ©initialiser/Copier/ExÃ©cuter/ArrÃªter** le code ciâ€‘dessous.  
    Mais avant cela, vous devez aller dans le chemin du code source comme ``raphael-kit/python``.  
    AprÃ¨s modification, vous pouvez exÃ©cuter directement le code pour voir lâ€™effet.

.. raw:: html

    <run></run>

.. code-block:: python

    #!/usr/bin/env python3

    import RPi.GPIO as GPIO
    import spidev
    import time

    # Broches GPIO connectÃ©es aux 10Â LED (de gauche Ã  droite)
    led_pins = [25, 12, 16, 20, 21, 5, 6, 13, 19, 26]  # NumÃ©rotation BCM

    # Configuration des GPIO
    GPIO.setmode(GPIO.BCM)
    for pin in led_pins:
        GPIO.setup(pin, GPIO.OUT)
        GPIO.output(pin, GPIO.LOW)

    # Initialisation SPI
    spi = spidev.SpiDev()
    spi.open(0, 0)  # BusÂ 0, CE0
    spi.max_speed_hz = 1000000  # 1Â MHz

    # Lecture dâ€™une valeur depuis le MCP3008
    def read_adc(channel):
        if channel < 0 or channel > 7:
            return -1
        r = spi.xfer2([1, (8 + channel) << 4, 0])
        value = ((r[1] & 0x03) << 8) | r[2]
        return value

    # Allumer les LED en fonction du niveau
    def led_bar_graph(level):
        for i, pin in enumerate(led_pins):
            if i < level:
                GPIO.output(pin, GPIO.HIGH)
            else:
                GPIO.output(pin, GPIO.LOW)

    # Boucle principale
    try:
        while True:
            analog_val = read_adc(0)  # Lecture sur le canalÂ 0
            level = int(analog_val * 10 / 1023)
            led_bar_graph(level)
            print(f"ADCÂ : {analog_val}, NiveauÂ : {level}")
            time.sleep(0.2)

    except KeyboardInterrupt:
        pass

    finally:
        for pin in led_pins:
            GPIO.output(pin, GPIO.LOW)
        GPIO.cleanup()
        spi.close()

Explication du code
-------------------

Ce programme lit la tension analogique via un MCP3008 et affiche le rÃ©sultat sur une barre de 10Â LED Ã  lâ€™aide dâ€™un RaspberryÂ Pi (mode BCM).

1. **Importation des modules**

   - ``RPi.GPIO`` pour le contrÃ´le des GPIO du RaspberryÂ Pi.
   - ``spidev`` pour la communication SPI avec MCP3008.
   - ``time`` pour la gestion des temporisations.

   .. code-block:: python

       #!/usr/bin/env python3

       import RPi.GPIO as GPIO
       import spidev
       import time



2. **Configuration des LED GPIO**

   Une liste de 10 broches est dÃ©finie pour la commande des LED.  
   Ces broches sont configurÃ©es en sortie et initialisÃ©es Ã  lâ€™Ã©tat bas (LED Ã©teintes).

   .. code-block:: python

       # GPIO pins connected to 10 LEDs, ordered from left to right
       led_pins = [25, 12, 16, 20, 21, 5, 6, 13, 19, 26]  # BCM numbering

       GPIO.setmode(GPIO.BCM)
       for pin in led_pins:
           GPIO.setup(pin, GPIO.OUT)
           GPIO.output(pin, GPIO.LOW)

3. **Initialisation SPI**

   Ouverture du bus SPIÂ 0 et activation de CE0 pour communiquer avec MCP3008.  
   La vitesse de communication est dÃ©finie Ã  1Â MHz.

   .. code-block:: python

       spi = spidev.SpiDev()
       spi.open(0, 0)  # Bus 0, CE0
       spi.max_speed_hz = 1000000  # 1 MHz

4. **Fonction de lecture ADC**

   Lecture dâ€™une valeur analogique depuis un canal (0â€“7) du MCP3008.  
   La fonction envoie une commande SPI de 3Â octets et dÃ©code un rÃ©sultat 10Â bits.

   .. code-block:: python

       def read_adc(channel):
           if channel < 0 or channel > 7:
               return -1
           r = spi.xfer2([1, (8 + channel) << 4, 0])
           value = ((r[1] & 0x03) << 8) | r[2]
           return value

5. **Fonction de commande de la barre de LED**

   Allume les LED en fonction du niveau calculÃ©.  
   Par exemple, si le niveau vautÂ 7, les 7Â premiÃ¨res LED sont allumÃ©es et les autres Ã©teintes.

   .. code-block:: python

       def led_bar_graph(level):
           for i, pin in enumerate(led_pins):
               if i < level:
                   GPIO.output(pin, GPIO.HIGH)
               else:
                   GPIO.output(pin, GPIO.LOW)


6. **Boucle principale**

   Lit en continu la valeur analogique du canalÂ 0, calcule un niveau entreÂ 0 etÂ 10, 
   met Ã  jour lâ€™affichage des LED et imprime les valeurs dans la console toutes les 0,2Â s.

   .. code-block:: python

       try:
           while True:
               analog_val = read_adc(0)
               level = int(analog_val * 10 / 1023)
               led_bar_graph(level)
               print(f"ADC: {analog_val}, Level: {level}")
               time.sleep(0.2)


7. **Nettoyage Ã  la sortie**

   Lorsque ``Ctrl+C`` est pressÃ©, toutes les LED sont Ã©teintes, lâ€™Ã©tat des GPIO est rÃ©initialisÃ© et lâ€™interface SPI est fermÃ©e.

   .. code-block:: python

       except KeyboardInterrupt:
           pass

       finally:
           for pin in led_pins:
               GPIO.output(pin, GPIO.LOW)
           GPIO.cleanup()
           spi.close()