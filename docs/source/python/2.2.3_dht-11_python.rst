.. _2.2.3_py:

2.2.3 DHT-11
============

Einführung
----------

Der digitale Temperatur- und Feuchtigkeitssensor DHT11 ist ein Verbundsensor, 
der einen kalibrierten digitalen Signal-Ausgang für Temperatur und 
Feuchtigkeit enthält. Die Technologie einer speziellen digitalen Modulsammlung 
sowie die Technologie der Temperatur- und Feuchtigkeitserfassung werden 
angewendet, um sicherzustellen, dass das Produkt eine hohe Zuverlässigkeit 
und hervorragende Stabilität aufweist.

Die Sensoren beinhalten einen feuchteempfindlichen Widerstandssensor und einen 
NTC-Temperatursensor, die an einen leistungsstarken 8-Bit-Mikrocontroller 
angeschlossen sind.

Benötigte Komponenten
---------------------

Für dieses Projekt benötigen wir die folgenden Komponenten.

.. image:: ../img/list_2.2.3_dht-11.png

Es ist definitiv praktisch, ein ganzes Kit zu kaufen. Hier ist der Link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Name	
        - ARTIKEL IN DIESEM KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Sie können diese auch einzeln über die untenstehenden Links kaufen.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - KOMPONENTENBESCHREIBUNG
        - KAUF-LINK

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_humiture_sensor`
        - |link_humiture_buy|

Schaltplan
----------

.. image:: ../img/image326.png

Experimentelle Verfahren
----------------------------

**Schritt 1:** Schalten Sie den Schaltkreis.

.. image:: ../img/image207.png

**Schritt 2:** Navigieren Sie zu dem Ordner mit dem Code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python/

**Schritt 3:** Führen Sie die ausführbare Datei aus.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.2.3_DHT.py

Nachdem der Code ausgeführt wurde, wird das Programm die von DHT11 erfasste 
Temperatur und Feuchtigkeit auf dem Computerbildschirm anzeigen.

**Code**

.. note::

    Sie können den untenstehenden Code **Ändern/Zurücksetzen/Kopieren/Ausführen/Stoppen**. 
    Bevor Sie das tun, müssen Sie jedoch zum Quellcode-Pfad wie ``raphael-kit/python`` navigieren. 
    Nachdem Sie den Code geändert haben, können Sie ihn direkt ausführen, um das Ergebnis zu sehen.


.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    dhtPin = 17

    GPIO.setmode(GPIO.BCM)

    MAX_UNCHANGE_COUNT = 100

    STATE_INIT_PULL_DOWN = 1
    STATE_INIT_PULL_UP = 2
    STATE_DATA_FIRST_PULL_DOWN = 3
    STATE_DATA_PULL_UP = 4
    STATE_DATA_PULL_DOWN = 5

    def readDht11():
        GPIO.setup(dhtPin, GPIO.OUT)
        GPIO.output(dhtPin, GPIO.HIGH)
        time.sleep(0.05)
        GPIO.output(dhtPin, GPIO.LOW)
        time.sleep(0.02)
        GPIO.setup(dhtPin, GPIO.IN, GPIO.PUD_UP)

        unchanged_count = 0
        last = -1
        data = []
        while True:
            current = GPIO.input(dhtPin)
            data.append(current)
            if last != current:
                unchanged_count = 0
                last = current
            else:
                unchanged_count += 1
                if unchanged_count > MAX_UNCHANGE_COUNT:
                    break

        state = STATE_INIT_PULL_DOWN

        lengths = []
        current_length = 0

        for current in data:
            current_length += 1

            if state == STATE_INIT_PULL_DOWN:
                if current == GPIO.LOW:
                    state = STATE_INIT_PULL_UP
                else:
                    continue
            if state == STATE_INIT_PULL_UP:
                if current == GPIO.HIGH:
                    state = STATE_DATA_FIRST_PULL_DOWN
                else:
                    continue
            if state == STATE_DATA_FIRST_PULL_DOWN:
                if current == GPIO.LOW:
                    state = STATE_DATA_PULL_UP
                else:
                    continue
            if state == STATE_DATA_PULL_UP:
                if current == GPIO.HIGH:
                    current_length = 0
                    state = STATE_DATA_PULL_DOWN
                else:
                    continue
            if state == STATE_DATA_PULL_DOWN:
                if current == GPIO.LOW:
                    lengths.append(current_length)
                    state = STATE_DATA_PULL_UP
                else:
                    continue
        if len(lengths) != 40:
            #print ("Data not good, skip")
            return False

        shortest_pull_up = min(lengths)
        longest_pull_up = max(lengths)
        halfway = (longest_pull_up + shortest_pull_up) / 2
        bits = []
        the_bytes = []
        byte = 0

        for length in lengths:
            bit = 0
            if length > halfway:
                bit = 1
            bits.append(bit)
        #print ("bits: %s, length: %d" % (bits, len(bits)))
        for i in range(0, len(bits)):
            byte = byte << 1
            if (bits[i]):
                byte = byte | 1
            else:
                byte = byte | 0
            if ((i + 1) % 8 == 0):
                the_bytes.append(byte)
                byte = 0
        #print (the_bytes)
        checksum = (the_bytes[0] + the_bytes[1] + the_bytes[2] + the_bytes[3]) & 0xFF
        if the_bytes[4] != checksum:
            #print ("Data not good, skip")
            return False

        return the_bytes[0], the_bytes[2]

    def main():

        while True:
            result = readDht11()
            if result:
                humidity, temperature = result
                print ("humidity: %s %%,  Temperature: %s ℃" % (humidity, temperature))
            time.sleep(1)

    def destroy():
        GPIO.cleanup()

    if __name__ == '__main__':
        try:
            main()
        except KeyboardInterrupt:
            destroy() 

**Code-Erklärung**

.. code-block:: python

    def readDht11():
        GPIO.setup(dhtPin, GPIO.OUT)
        GPIO.output(dhtPin, GPIO.HIGH)
        time.sleep(0.05)
        GPIO.output(dhtPin, GPIO.LOW)
        time.sleep(0.02)
        GPIO.setup(dhtPin, GPIO.IN, GPIO.PUD_UP)
        unchanged_count = 0
        last = -1
        data = []
        #...

Diese Funktion dient zur Implementierung der Funktionen des DHT11. Die 
detektierten Daten werden im Array the_bytes[] gespeichert. Der DHT11 
überträgt jeweils 40 Bits an Daten. Die ersten 16 Bits beziehen sich auf 
die Feuchtigkeit, die mittleren 16 Bits beziehen sich auf die Temperatur 
und die letzten acht Bits werden zur Überprüfung verwendet. Das 
Datenformat lautet:

**8bit Feuchtigkeits-Ganzzahldaten** +\ **8bit Feuchtigkeits-Nachkommadaten**
+\ **8bit Temperatur-Ganzzahldaten** + **8bit Temperatur-Nachkommadaten**
+ **8bit Prüfbit**.

Wenn die Gültigkeit über das Prüfbit erkannt wird, gibt die Funktion 
zwei Ergebnisse zurück: 1. Fehler; 2. Feuchtigkeit und Temperatur.

.. code-block:: python

    checksum = (the_bytes[0] + the_bytes[1] + the_bytes[2] + the_bytes[3]) & 0xFF
    if the_bytes[4] != checksum:
        #print ("Data not good, skip")
        return False

    return the_bytes[0], the_bytes[2]

Beispielsweise, wenn das empfangene Datum 00101011 (8-Bit-Wert der 
Feuchtigkeitsganzzahl) 00000000 (8-Bit-Wert der Feuchtigkeits-Nachkommazahl) 
00111100 (8-Bit-Wert der Temperaturganzzahl) 00000000 (8-Bit-Wert der 
Temperatur-Nachkommazahl) 01100111 (Prüfbit) ist.

**Berechnung:**

00101011+00000000+00111100+00000000=01100111.

Wenn das Endergebnis mit den Prüfbitdaten übereinstimmt, ist die 
Datenübertragung abnormal: Rückgabe False.

Wenn das Endergebnis mit den Prüfbitdaten übereinstimmt, sind die 
empfangenen Daten korrekt, dann wird the_bytes[0] und the_bytes[2] 
zurückgegeben und "Luftfeuchtigkeit =43%, Temperatur =60C" ausgegeben.

Phänomen-Bild
--------------------

.. image:: ../img/image209.jpeg