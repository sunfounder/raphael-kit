 
.. note::

    Bonjour et bienvenue dans la Communaut√© Facebook des passionn√©s de Raspberry Pi, Arduino et ESP32 de SunFounder ! Plongez plus profond√©ment dans l'univers des Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre et partager** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits et aux aper√ßus.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos produits les plus r√©cents.
    - **Promotions festives et cadeaux** : Participez √† des cadeaux et des promotions de vacances.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez [|link_sf_facebook|] et rejoignez-nous aujourd'hui !

.. _2.2.3_py:

2.2.3 DHT-11
===============

Introduction
---------------

Le capteur de temp√©rature et d'humidit√© num√©rique DHT11 est un capteur composite qui contient une 
sortie de signal num√©rique calibr√©e de temp√©rature et d'humidit√©. La technologie de collecte de 
modules num√©riques d√©di√©s et la technologie de d√©tection de temp√©rature et d'humidit√© sont 
appliqu√©es pour garantir que le produit poss√®de une haute fiabilit√© et une excellente stabilit√©.

Les capteurs incluent un capteur r√©sistif d'√©l√©ment humide et un capteur de temp√©rature NTC et ils 
sont connect√©s √† un microcontr√¥leur 8 bits haute performance.

Composants N√©cessaires
------------------------

Pour ce projet, nous avons besoin des composants suivants :

.. image:: ../img/list_2.2.3_dht-11.png

Il est tr√®s pratique d'acheter un kit complet, voici le lien :

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom
        - √âL√âMENTS DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez √©galement les acheter s√©par√©ment via les liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DES COMPOSANTS
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_humiture_sensor`
        - |link_humiture_buy|

Sch√©ma √âlectrique
----------------------

.. image:: ../img/image326.png


Proc√©dures Exp√©rimentales
-------------------------

**√âtape 1 :** Construire le circuit.

.. image:: ../img/image207.png

**√âtape 2 :** Aller dans le dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python/

**√âtape 3 :** Ex√©cuter le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.2.3_DHT.py

Apr√®s l'ex√©cution du code, le programme affichera la temp√©rature et l'humidit√© d√©tect√©es par 
le DHT11 sur l'√©cran de l'ordinateur.

**Code**

.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez acc√©der au chemin du code source comme ``raphael-kit/python``. Apr√®s avoir modifi√© le code, vous pouvez l'ex√©cuter directement pour voir l'effet.

.. raw:: html

    <run></run>

.. code-block:: python


   from gpiozero import OutputDevice, InputDevice
   import time


   class DHT11():
      MAX_DELAY_COUINT = 100
      BIT_1_DELAY_COUNT = 10
      BITS_LEN = 40

      def __init__(self, pin, pull_up=False):
         self._pin = pin
         self._pull_up = pull_up


      def read_data(self):
         bit_count = 0
         delay_count = 0
         bits = ""

         # -------------- send start --------------
         gpio = OutputDevice(self._pin)
         gpio.off()
         time.sleep(0.02)

         gpio.close()
         gpio = InputDevice(self._pin, pull_up=self._pull_up)

         # -------------- wait response --------------
         while gpio.value == 1:
               pass
         
         # -------------- read data --------------
         while bit_count < self.BITS_LEN:
               while gpio.value == 0:
                  pass

               # st = time.time()
               while gpio.value == 1:
                  delay_count += 1
                  # break
                  if delay_count > self.MAX_DELAY_COUINT:
                     break
               if delay_count > self.BIT_1_DELAY_COUNT:
                  bits += "1"
               else:
                  bits += "0"

               delay_count = 0
               bit_count += 1

         # -------------- verify --------------
         humidity_integer = int(bits[0:8], 2)
         humidity_decimal = int(bits[8:16], 2)
         temperature_integer = int(bits[16:24], 2)
         temperature_decimal = int(bits[24:32], 2)
         check_sum = int(bits[32:40], 2)

         _sum = humidity_integer + humidity_decimal + temperature_integer + temperature_decimal

         # print(bits)
         # print(humidity_integer, humidity_decimal, temperature_integer, temperature_decimal)
         # print(f'sum:{_sum}, check_sum:{check_sum}')
         # print()

         if check_sum != _sum:
               humidity = 0.0
               temperature = 0.0
         else:
               humidity = float(f'{humidity_integer}.{humidity_decimal}')
               temperature = float(f'{temperature_integer}.{temperature_decimal}')

         # -------------- return --------------
         return humidity, temperature


   if __name__ == '__main__':
      dht11 = DHT11(17)
      while True:
         humidity, temperature = dht11.read_data()
         print(f"{time.time():.3f}  temperature:{temperature}¬∞C  humidity: {humidity}%")
         time.sleep(2)

**Explication du Code**

.. code-block:: python

    def read_data(self):
        bit_count = 0
        delay_count = 0
        bits = ""

        # -------------- send start --------------
        gpio = OutputDevice(self._pin)
        gpio.off()
        time.sleep(0.02)

        gpio.close()
        gpio = InputDevice(self._pin, pull_up=self._pull_up)
        #...

Cette fonction est utilis√©e pour impl√©menter les fonctions du DHT11. Elle stocke les donn√©es 
d√©tect√©es dans le tableau bits[]. Le DHT11 transmet des donn√©es de 40 bits √† la fois. 
Les 16 premiers bits sont li√©s √† l'humidit√©, les 16 bits du milieu sont li√©s √† la temp√©rature, 
et les huit derniers bits sont utilis√©s pour la v√©rification. 


Le format des donn√©es est le suivant :

**8 bits de donn√©es enti√®res d'humidit√©** + **8 bits de donn√©es d√©cimales d'humidit√©** 
+ **8 bits de donn√©es enti√®res de temp√©rature** + **8 bits de donn√©es d√©cimales de temp√©rature** 
+ **8 bits de bit de contr√¥le**.

Lorsque la validit√© est d√©tect√©e via le bit de contr√¥le, la fonction renvoie 
deux r√©sultats : 1. erreur ; 2. humidit√© et temp√©rature.

.. code-block:: python

   _sum = humidity_integer + humidity_decimal + temperature_integer + temperature_decimal

   if check_sum != _sum:
      humidity = 0.0
      temperature = 0.0
   else:
      humidity = float(f'{humidity_integer}.{humidity_decimal}')
      temperature = float(f'{temperature_integer}.{temperature_decimal}')


Par exemple, si les donn√©es re√ßues sont 00101011 (valeur de 8 bits de l'entier d'humidit√©) 
00000000 (valeur de 8 bits de la d√©cimale d'humidit√©) 00111100 (valeur de 8 bits de l'entier 
de temp√©rature) 00000000 (valeur de 8 bits de la d√©cimale de temp√©rature) 01100111 (bit de contr√¥le)

**Calcul :**

00101011+00000000+00111100+00000000=01100111.

Si le r√©sultat final est √©gal aux donn√©es du bit de contr√¥le, la transmission des donn√©es est 
anormale : retour False.

Si le r√©sultat final est √©gal aux donn√©es du bit de contr√¥le, les donn√©es re√ßues sont correctes, 
alors il y aura un retour de ``humidity`` et ``temperature`` et l'affichage 
"Humidit√© = 43%, Temp√©rature = 60‚ÑÉ".

Image du Ph√©nom√®ne
------------------------

.. image:: ../img/image209.jpeg