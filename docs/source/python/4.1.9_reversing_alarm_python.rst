.. note::

    ¡Hola! Bienvenido a la comunidad de entusiastas de SunFounder Raspberry Pi, Arduino y ESP32 en Facebook. Sumérgete más en Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **¿Por qué unirse?**

    - **Soporte experto**: Resuelve problemas postventa y desafíos técnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprender y compartir**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Avances exclusivos**: Accede anticipadamente a nuevos anuncios de productos y adelantos exclusivos.
    - **Descuentos especiales**: Disfruta de descuentos exclusivos en nuestros productos más recientes.
    - **Promociones y sorteos festivos**: Participa en sorteos y promociones navideñas.

    👉 ¿Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y únete hoy mismo.

.. _4.1.9_py:

4.1.9 Alarma de Reversa
=======================================

Introducción
-----------------

En este proyecto, utilizaremos una pantalla LCD, un zumbador y sensores ultrasónicos 
para crear un sistema de asistencia de reversa. Podemos colocarlo en un vehículo a 
control remoto para simular el proceso real de reversa en un garaje.

Componentes Necesarios
------------------------------

En este proyecto, necesitamos los siguientes componentes.

.. image:: ../img/list_Reversing_Alarm.png
    :align: center

Es muy conveniente comprar un kit completo, aquí está el enlace:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre
        - ELEMENTOS EN ESTE KIT
        - ENLACE
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

También puedes comprarlos por separado en los enlaces a continuación.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCIÓN DEL COMPONENTE
        - ENLACE DE COMPRA

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_buzzer`
        - \-
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|
    *   - :ref:`cpn_ultrasonic_sensor`
        - |link_ultrasonic_buy|
    *   - :ref:`cpn_i2c_lcd`
        - |link_i2clcd1602_buy|

Diagrama Esquemático
------------------------

El sensor ultrasónico detecta la distancia entre él y el obstáculo que se mostrará 
en la pantalla LCD en forma de código. Al mismo tiempo, el sensor ultrasónico permite 
que el zumbador emita un sonido de advertencia de frecuencia diferente según el valor 
de la distancia.

============== =============== ======== ===
Nombre T-Board cableado físico wiringPi BCM
GPIO23         Pin 16          4        23
GPIO24         Pin 18          5        24
GPIO17         Pin 11          0        17
SDA1           Pin 3             
SCL1           Pin 5             
============== =============== ======== ===

.. image:: ../img/Schematic_three_one3.png
   :align: center

Procedimientos Experimentales
----------------------------------

**Paso 1:** Construye el circuito.

.. image:: ../img/image242.png
    :width: 400
    :align: center

**Paso 2:** Cambia de directorio.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python/

**Paso 3:** Ejecuta.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 4.1.9_ReversingAlarm.py

Mientras el código se ejecuta, el módulo del sensor ultrasónico detecta la 
distancia al obstáculo y luego muestra la información sobre la distancia 
en el LCD1602; además, el zumbador emite un tono de advertencia cuya frecuencia 
cambia con la distancia.

.. note::

    * Si obtienes el error ``FileNotFoundError: [Errno 2] No such file or directory: '/dev/i2c-1'``, necesitas referirte a :ref:`i2c_config` para habilitar el I2C.
    * Si obtienes el error ``ModuleNotFoundError: No module named 'smbus2'``, por favor ejecuta ``sudo pip3 install smbus2``.
    * Si aparece el error ``OSError: [Errno 121] Remote I/O error``, significa que el módulo está mal cableado o el módulo está roto.
    * Si el código y el cableado están bien, pero el LCD aún no muestra contenido, puedes girar el potenciómetro en la parte trasera para aumentar el contraste.


**Código**

.. note::
    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el código a continuación. Pero antes de eso, necesitas ir a la ruta del código fuente como ``raphael-kit/python``. Después de modificar el código, puedes ejecutarlo directamente para ver el efecto.

.. raw:: html

    <run></run>

.. code-block:: python

    import LCD1602
    import time
    import RPi.GPIO as GPIO

    TRIG = 16
    ECHO = 18
    BUZZER = 11

    def lcdsetup():
        LCD1602.init(0x27, 1)   # init(slave address, background light)
        LCD1602.clear()   
        LCD1602.write(0, 0, 'Ultrasonic Starting')
        LCD1602.write(1, 1, 'By SunFounder')
        time.sleep(2)

    def setup():
        GPIO.setmode(GPIO.BOARD)
        GPIO.setup(TRIG, GPIO.OUT)
        GPIO.setup(ECHO, GPIO.IN)
        GPIO.setup(BUZZER, GPIO.OUT, initial=GPIO.LOW)
        lcdsetup()

    def distance():
        GPIO.output(TRIG, 0)
        time.sleep(0.000002)

        GPIO.output(TRIG, 1)
        time.sleep(0.00001)
        GPIO.output(TRIG, 0)

        while GPIO.input(ECHO) == 0:
            a = 0
        time1 = time.time()
        while GPIO.input(ECHO) == 1:
            a = 1
        time2 = time.time()

        during = time2 - time1
        return during * 340 / 2 * 100

    def destroy():
        GPIO.output(BUZZER, GPIO.LOW)
        GPIO.cleanup()
        LCD1602.clear()

    def loop():
        while True:
            dis = distance()
            print (dis, 'cm')
            print ('')
            GPIO.output(BUZZER, GPIO.LOW)
            if (dis > 400):
                LCD1602.clear()
                LCD1602.write(0, 0, 'Error')
                LCD1602.write(3, 1, 'Out of range')
                time.sleep(0.5)
            else:
                LCD1602.clear()
                LCD1602.write(0, 0, 'Distance is')
                LCD1602.write(5, 1, str(round(dis,2)) +' cm')
            if(dis>=50):
                    time.sleep(0.5)
            elif(dis<50 and dis>20):
                for i in range(0,2,1):
                        GPIO.output(BUZZER, GPIO.HIGH)
                        time.sleep(0.05)
                        GPIO.output(BUZZER, GPIO.LOW)
                        time.sleep(0.2)
            elif(dis<=20):
                for i in range(0,5,1):
                        GPIO.output(BUZZER, GPIO.HIGH)
                        time.sleep(0.05)
                        GPIO.output(BUZZER, GPIO.LOW)
                        time.sleep(0.05)


    if __name__ == "__main__":
        setup()
        try:       
            loop()
        except KeyboardInterrupt:
            destroy()



**Explicación del Código**

.. code-block:: python

    def lcdsetup():
        LCD1602.init(0x27, 1)   # init(slave address, background light)

    def setup():
        GPIO.setmode(GPIO.BOARD)
        GPIO.setup(TRIG, GPIO.OUT)
        GPIO.setup(ECHO, GPIO.IN)
        GPIO.setup(BUZZER, GPIO.OUT, initial=GPIO.LOW)
        lcdsetup()

En este programa, aplicamos de manera sintética los componentes utilizados anteriormente. 
Aquí usamos zumbadores, LCD y ultrasonido. Podemos inicializarlos de la misma manera que 
hicimos antes.

.. code-block:: python

    dis = distance()
    print (dis, 'cm')
    print ('')
    GPIO.output(BUZZER, GPIO.LOW)
    if (dis > 400):
        LCD1602.clear()
        LCD1602.write(0, 0, 'Error')
        LCD1602.write(3, 1, 'Out of range')
        time.sleep(0.5)
    else:
        LCD1602.clear()
        LCD1602.write(0, 0, 'Distance is')
        LCD1602.write(5, 1, str(round(dis,2)) +' cm')

Aquí obtenemos los valores del sensor ultrasónico y calculamos la distancia. 
Si el valor de la distancia es mayor que el rango de detección, se imprime un 
mensaje de error en el LCD. Y si la distancia está dentro del rango de trabajo, 
se mostrarán los resultados correspondientes.

.. code-block:: python

    LCD1602.write(5, 1, str(round(dis,2)) +' cm')

Dado que la salida del LCD solo soporta tipos de caracteres, necesitamos usar **str()** 
para convertir los valores numéricos a caracteres. Vamos a redondearlo a dos decimales.

.. code-block:: python

    if(dis>=50):
        time.sleep(0.5)
    elif(dis<50 and dis>20):
        for i in range(0,2,1):
            GPIO.output(BUZZER, GPIO.HIGH)
            time.sleep(0.05)
            GPIO.output(BUZZER, GPIO.LOW)
            time.sleep(0.2)
    elif(dis<=20):
        for i in range(0,5,1):
            GPIO.output(BUZZER, GPIO.HIGH)
            time.sleep(0.05)
            GPIO.output(BUZZER, GPIO.LOW)
            time.sleep(0.05)

Esta condición de juicio se utiliza para controlar el sonido del zumbador. Según la diferencia 
en la distancia, se puede dividir en tres casos, en los cuales habrá diferentes frecuencias de 
sonido. Dado que el valor total de retardo es de 500 ms, todos ellos pueden proporcionar un 
intervalo de 500 ms para que el sensor ultrasónico funcione.


Imagen del Fenómeno
-----------------------

.. image:: ../img/image243.jpeg
   :align: center
