.. note::

    Bonjour, bienvenue dans la communautÃ© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur FacebookÂ ! Approfondissez vos connaissances sur RaspberryÂ Pi, Arduino et ESP32 avec dâ€™autres passionnÃ©s.

    **Pourquoi rejoindreÂ ?**

    - **Support dâ€™experts**Â : RÃ©solvez les problÃ¨mes aprÃ¨sâ€‘vente et les dÃ©fis techniques avec lâ€™aide de notre communautÃ© et de notre Ã©quipe.
    - **Apprendre et partager**Â : Ã‰changez des astuces et des tutoriels pour amÃ©liorer vos compÃ©tences.
    - **AperÃ§us exclusifs**Â : AccÃ©dez en avantâ€‘premiÃ¨re aux annonces de nouveaux produits et aux aperÃ§us.
    - **RÃ©ductions spÃ©ciales**Â : Profitez de rÃ©ductions exclusives sur nos tout derniers produits.
    - **Promotions et cadeaux festifs**Â : Participez Ã  des concours et promotions spÃ©ciales pendant les fÃªtes.

    ðŸ‘‰ PrÃªt Ã  explorer et Ã  crÃ©er avec nousÂ ? Cliquez sur [|link_sf_facebook|] et rejoignezâ€‘nous dÃ¨s aujourdâ€™huiÂ !

.. _3.1.4_c_mcp3008:

3.1.4 Ventilateur intelligent (MCP3008)
=======================================

.. note::

   .. image:: ../img/mcp3008_and_adc0834.jpg
      :width: 25%
      :align: left
    

   Selon la version de votre kit, identifiez si vous disposez dâ€™un **ADC0834** ou dâ€™un **MCP3008** et suivez la section correspondante.

Introduction
------------

Dans ce projet, nous allons utiliser des moteurs, des boutons et une thermistance pour rÃ©aliser un ventilateur intelligent manuel + automatique dont la vitesse de rotation est rÃ©glable.

Composants requis
-----------------

Dans ce projet, nous avons besoin des composants suivants. 

.. image:: ../img/list2_Smart_Fan.png
    :align: center

Il est bien sÃ»r pratique dâ€™acheter un kit complet, voici le lienÂ : 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom	
        - Ã‰LÃ‰MENTS DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez Ã©galement les acheter sÃ©parÃ©ment via les liens ciâ€‘dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DU COMPOSANT
        - LIEN Dâ€™ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_power_module`
        - \-
    *   - :ref:`cpn_thermistor`
        - |link_thermistor_buy|
    *   - :ref:`cpn_l293d`
        - \-
    *   - :ref:`cpn_mcp3008`
        - \-
    *   - :ref:`cpn_button`
        - |link_button_buy|
    *   - :ref:`cpn_motor`
        - |link_motor_buy|

SchÃ©ma de cÃ¢blage
-----------------

============ ======== ======== ===
Nom Tâ€‘Board  Physique WiringPi BCM
SPICE0       PinÂ 24   10       8
SPIMOSI      PinÂ 19   12       10
SPIMISO      PinÂ 21   13       9
SPISCLK      PinÂ 23   14       11
GPIO22       PinÂ 15   3        22
GPIO5        PinÂ 29   21       5
GPIO6        PinÂ 31   22       6
GPIO13       PinÂ 33   23       13
============ ======== ======== ===

.. image:: ../img/schematic_3.1.4_smart_fan_mcp3008.png
   :align: center

ProcÃ©dures expÃ©rimentales
-------------------------

**Ã‰tapeÂ 1Â :** Construisez le circuit.

.. image:: ../img/july24_3.1.4_smart_fan_mcp3008.png
    :align: center

.. note::
    Le module dâ€™alimentation peut utiliser une pile de 9Â V avec le connecteur fourni dans le kit.  
    InsÃ©rez le cavalier du module dâ€™alimentation dans les rails 5Â V de la plaque dâ€™essai.

.. image:: ../img/image118.jpeg
    :align: center

**Ã‰tapeÂ 2Â :** AccÃ©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/c/3.1.4-2/

**Ã‰tapeÂ 3Â :** Compilez.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.4_SmartFan.c -o SmartFan -lwiringPi -lm

**Ã‰tapeÂ 4Â :** ExÃ©cutez lâ€™exÃ©cutable.

.. raw:: html

   <run></run>

.. code-block:: 

    ./SmartFan

Lorsque le code est en cours dâ€™exÃ©cution, dÃ©marrez le ventilateur en appuyant sur le bouton.  
Chaque pression augmente ou diminue dâ€™un niveau la vitesse de rotation.  
Il existe **5** niveaux de vitesseÂ : **0Â ~Â 4**.  
Lorsque vous atteignez le 4\ :sup:`Ã¨me` niveau et que vous appuyez Ã  nouveau, le ventilateur sâ€™arrÃªte avec une vitesse **0**.

DÃ¨s que la tempÃ©rature augmente ou baisse de plus de 2Â Â°C, la vitesse est automatiquement augmentÃ©e ou rÃ©duite dâ€™un niveau.

.. note::

    Si cela ne fonctionne pas aprÃ¨s exÃ©cution ou sâ€™il y a un message dâ€™erreurÂ : Â«Â wiringPi.hÂ : No such file or directoryÂ Â», veuillez vous rÃ©fÃ©rer Ã Â :ref:`install_wiringpi`.

Code
----

.. code-block:: c

    #include <wiringPi.h>
    #include <wiringPiSPI.h>
    #include <stdio.h>
    #include <softPwm.h>
    #include <math.h>

    #define SPI_CHANNEL 0
    #define SPI_SPEED   1000000
    #define MotorPin1   21
    #define MotorPin2   22
    #define MotorEnable 23
    #define BtnPin      3

    int read_ADC(int channel)
    {
        if (channel < 0 || channel > 7) return -1;

        unsigned char buffer[3];
        buffer[0] = 1;                      // Bit de dÃ©marrage
        buffer[1] = (8 + channel) << 4;     // Mode simple et canal
        buffer[2] = 0;

        wiringPiSPIDataRW(SPI_CHANNEL, buffer, 3);

        int result = ((buffer[1] & 3) << 8) | buffer[2];
        return result;
    }

    int temperture()
    {
        int analogVal = read_ADC(0);
        double Vr = 3.3 * analogVal / 1023.0;  // RÃ©fÃ©rence 3,3V pour MCP3008
        double Rt = 10000.0 * Vr / (3.3 - Vr);
        double temp = 1 / (((log(Rt / 10000.0)) / 3950.0) + (1 / (273.15 + 25.0)));
        double cel = temp - 273.15;
        double Fah = cel * 1.8 + 32;
        printf("Celsius: %.2f C  Fahrenheit: %.2f F\n", cel, Fah);
        return (int)cel;
    }

    int motor(int level)
    {
        if (level == 0) {
            digitalWrite(MotorEnable, LOW);
            return 0;
        }
        if (level >= 4) {
            level = 4;
        }
        digitalWrite(MotorEnable, HIGH);
        softPwmWrite(MotorPin1, level * 25);
        return level;
    }

    void setup()
    {
        if (wiringPiSetup() == -1) {
            printf("wiringPi setup failed!\n");
            return;
        }

        if (wiringPiSPISetup(SPI_CHANNEL, SPI_SPEED) == -1) {
            printf("SPI setup failed!\n");
            return;
        }

        softPwmCreate(MotorPin1, 0, 100);
        softPwmCreate(MotorPin2, 0, 100);
        pinMode(MotorEnable, OUTPUT);
        pinMode(BtnPin, INPUT);
    }

    int main(void)
    {
        setup();
        int currentState, lastState = 0;
        int level = 0;
        int currentTemp, markTemp = 0;

        while (1) {
            currentState = digitalRead(BtnPin);
            currentTemp = temperture();

            if (currentTemp <= 0) continue;

            if (currentState == 1 && lastState == 0) {
                level = (level + 1) % 5;
                markTemp = currentTemp;
                delay(500);
            }

            lastState = currentState;

            if (level != 0) {
                if (currentTemp - markTemp <= -2) {
                    level = level - 1;
                    markTemp = currentTemp;
                }
                if (currentTemp - markTemp >= 2) {
                    level = level + 1;
                    markTemp = currentTemp;
                }
            }

            level = motor(level);
        }

        return 0;
    }


Explication du code
-------------------

.. code-block:: c

    int read_ADC(int channel)
    {
        if (channel < 0 || channel > 7) return -1;

        unsigned char buffer[3];
        buffer[0] = 1;                      // Bit de dÃ©marrage
        buffer[1] = (8 + channel) << 4;     // Mode simple et canal
        buffer[2] = 0;

        wiringPiSPIDataRW(SPI_CHANNEL, buffer, 3);

        int result = ((buffer[1] & 3) << 8) | buffer[2];
        return result;
    }

Cette fonction lit une entrÃ©e analogique du MCP3008 sur le canal spÃ©cifiÃ©.  
Elle envoie une commande SPI de 3Â octets et retourne une valeur numÃ©rique 10Â bits comprise entreÂ 0 etÂ 1023.

.. code-block:: c

    int temperture()
    {
        int analogVal = read_ADC(0);
        double Vr = 3.3 * analogVal / 1023.0;  // RÃ©fÃ©rence 3,3V pour MCP3008
        double Rt = 10000.0 * Vr / (3.3 - Vr);
        double temp = 1 / (((log(Rt / 10000.0)) / 3950.0) + (1 / (273.15 + 25.0)));
        double cel = temp - 273.15;
        double Fah = cel * 1.8 + 32;
        printf("Celsius: %.2f C  Fahrenheit: %.2f F\n", cel, Fah);
        return (int)cel;
    }

La fonction ``temperture()`` lit le signal analogique de la thermistance via MCP3008,  
calcule la tension et la rÃ©sistance, puis convertit en degrÃ©s Celsius et Fahrenheit en utilisant la formule de la thermistance (approximation Steinhartâ€“Hart).

.. code-block:: c

    int motor(int level)
    {
        if (level == 0) {
            digitalWrite(MotorEnable, LOW);
            return 0;
        }
        if (level >= 4) {
            level = 4;
        }
        digitalWrite(MotorEnable, HIGH);
        softPwmWrite(MotorPin1, level * 25);
        return level;
    }

La fonction ``motor()`` contrÃ´le la vitesse du ventilateur via PWM.  
Le niveau varie deÂ 0 Ã Â 4Â : 0Â Ã©teint le ventilateur et chaque niveau augmente le rapport cyclique deÂ 25Â %.

.. code-block:: c

    void setup()
    {
        if (wiringPiSetup() == -1) {
            printf("wiringPi setup failed!\n");
            return;
        }

        if (wiringPiSPISetup(SPI_CHANNEL, SPI_SPEED) == -1) {
            printf("SPI setup failed!\n");
            return;
        }

        softPwmCreate(MotorPin1, 0, 100);
        softPwmCreate(MotorPin2, 0, 100);
        pinMode(MotorEnable, OUTPUT);
        pinMode(BtnPin, INPUT);
    }

La fonction ``setup()`` initialise WiringPi, configure le SPI,  
met en place le PWM et configure les broches GPIO nÃ©cessaires au contrÃ´le du moteur et Ã  lâ€™entrÃ©e du bouton.

.. code-block:: c

    int main(void)
    {
        setup();
        int currentState, lastState = 0;
        int level = 0;
        int currentTemp, markTemp = 0;

        while (1) {
            currentState = digitalRead(BtnPin);
            currentTemp = temperture();

            if (currentTemp <= 0) continue;

            if (currentState == 1 && lastState == 0) {
                level = (level + 1) % 5;
                markTemp = currentTemp;
                delay(500);
            }

            lastState = currentState;

            if (level != 0) {
                if (currentTemp - markTemp <= -2) {
                    level = level - 1;
                    markTemp = currentTemp;
                }
                if (currentTemp - markTemp >= 2) {
                    level = level + 1;
                    markTemp = currentTemp;
                }
            }

            level = motor(level);
        }

        return 0;
    }

La fonction ``main()`` contient la boucle principale du programmeÂ :

1. VÃ©rifie en continu lâ€™Ã©tat du bouton et lit la tempÃ©rature actuelle.  
2. Ã€ chaque appui sur le bouton, la vitesse du ventilateur augmente (cycleÂ 0â€“4) et la tempÃ©rature de rÃ©fÃ©rence est sauvegardÃ©e.  
3. Si la tempÃ©rature change de Â±2Â Â°C, la vitesse du ventilateur est ajustÃ©e automatiquement dâ€™un niveau.  
4. Appelle ``motor(level)`` pour mettre Ã  jour la sortie PWM selon le niveau actuel.
