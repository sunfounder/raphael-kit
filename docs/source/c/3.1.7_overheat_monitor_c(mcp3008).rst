.. note::

    Bonjour, bienvenue dans la communautÃ© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur FacebookÂ ! Approfondissez vos connaissances sur RaspberryÂ Pi, Arduino et ESP32 avec dâ€™autres passionnÃ©s.

    **Pourquoi rejoindreÂ ?**

    - **Support dâ€™experts**Â : RÃ©solvez les problÃ¨mes aprÃ¨sâ€‘vente et les dÃ©fis techniques avec lâ€™aide de notre communautÃ© et de notre Ã©quipe.
    - **Apprendre et partager**Â : Ã‰changez des astuces et des tutoriels pour amÃ©liorer vos compÃ©tences.
    - **AperÃ§us exclusifs**Â : AccÃ©dez en avantâ€‘premiÃ¨re aux annonces de nouveaux produits et aux aperÃ§us.
    - **RÃ©ductions spÃ©ciales**Â : Profitez de rÃ©ductions exclusives sur nos tout derniers produits.
    - **Promotions et cadeaux festifs**Â : Participez Ã  des concours et promotions spÃ©ciales pendant les fÃªtes.

    ðŸ‘‰ PrÃªt Ã  explorer et Ã  crÃ©er avec nousÂ ? Cliquez sur [|link_sf_facebook|] et rejoignezâ€‘nous dÃ¨s aujourdâ€™huiÂ !

.. _3.1.7_c_mcp3008:

3.1.7 Moniteur de surchauffe (MCP3008)
======================================

.. note::

   .. image:: ../img/mcp3008_and_adc0834.jpg
      :width: 25%
      :align: left
    

   Selon la version de votre kit, identifiez si vous disposez dâ€™un **ADC0834** ou dâ€™un **MCP3008** et suivez la section correspondante.

Introduction
------------

Vous pouvez vouloir crÃ©er un dispositif de surveillance de surchauffe applicable Ã  diverses situations, par ex.Â : dans une usine, pour dÃ©clencher une alarme et Ã©teindre automatiquement la machine en cas de surchauffe dâ€™un circuit.  
Dans ce projet, nous utiliserons une thermistance, un joystick, un buzzer, une LED et un Ã©cran LCD pour rÃ©aliser un dispositif intelligent de surveillance de la tempÃ©rature dont le seuil est rÃ©glable.

Composants requis
-----------------

Dans ce projet, nous avons besoin des composants suivantsÂ :

.. image:: ../img/list2_Overheat_Monitor.png
    :align: center

Il est bien sÃ»r pratique dâ€™acheter un kit complet, voici le lienÂ : 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom	
        - Ã‰LÃ‰MENTS DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez Ã©galement les acheter sÃ©parÃ©ment via les liens ciâ€‘dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DU COMPOSANT
        - LIEN Dâ€™ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_joystick`
        - \-
    *   - :ref:`cpn_mcp3008`
        - \-
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|
    *   - :ref:`cpn_i2c_lcd`
        - |link_i2clcd1602_buy|
    *   - :ref:`cpn_thermistor`
        - |link_thermistor_buy|
    *   - :ref:`cpn_buzzer`
        - \-

SchÃ©ma de cÃ¢blage
-----------------

============ ======== ======== ===
Nom Tâ€‘Board  Physique WiringPi BCM
SPICE0       PinÂ 24   10       8
SPIMOSI      PinÂ 19   12       10
SPIMISO      PinÂ 21   13       9
SPISCLK      PinÂ 23   14       11
GPIO22       PinÂ 15   3        22
GPIO23       PinÂ 16   4        23
GPIO24       PinÂ 18   5        24
SDA1         PinÂ 3             
SCL1         PinÂ 5             
============ ======== ======== ===

.. image:: ../img/Schematic_three_one8.png
   :align: center

ProcÃ©dures expÃ©rimentales
-------------------------

**Ã‰tapeÂ 1Â :** Construisez le circuit.

.. image:: ../img/july24_3.1.8_overheat_monitor_mcp3008.png

**Ã‰tapeÂ 2Â :** AccÃ©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/c/3.1.7-2/

**Ã‰tapeÂ 3Â :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.7_OverheatMonitor.c -lm -lwiringPi

**Ã‰tapeÂ 4Â :** ExÃ©cutez lâ€™exÃ©cutable.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

Pendant lâ€™exÃ©cution du code, la tempÃ©rature actuelle et le seuil de haute tempÃ©rature **40** sont affichÃ©s sur lâ€™Ã©cran **I2CÂ LCD1602**.  
Si la tempÃ©rature actuelle dÃ©passe le seuil, le buzzer et la LED se dÃ©clenchent pour vous avertir.

Le **joystick** est utilisÃ© ici pour ajuster le seuil de haute tempÃ©rature.  
DÃ©placer le **joystick** sur lâ€™axeÂ X ouÂ Y permet dâ€™augmenter ou diminuer ce seuil.  
Appuyez Ã  nouveau sur le **joystick** pour rÃ©initialiser le seuil Ã  sa valeur initiale.

.. note::

    * Si un message dâ€™erreur ``wiringPi.h: No such file or directory`` sâ€™affiche, veuillez vous rÃ©fÃ©rer Ã Â :ref:`install_wiringpi`.
    * Si vous obtenez lâ€™erreur ``Unable to open I2C device: No such file or directory``, vous devez vous rÃ©fÃ©rer Ã Â :ref:`i2c_config` pour activer I2C et vÃ©rifier le cÃ¢blage.
    * Si le code et le cÃ¢blage sont corrects mais que lâ€™Ã©cran LCD ne sâ€™affiche toujours pas, vous pouvez tourner le potentiomÃ¨tre Ã  lâ€™arriÃ¨re pour augmenter le contraste.

Explication du code
-------------------

.. code-block:: c

    int read_ADC(int channel) {
        if (channel < 0 || channel > 7) return -1;
        unsigned char buffer[3];
        buffer[0] = 1;
        buffer[1] = (8 + channel) << 4;
        buffer[2] = 0;
        wiringPiSPIDataRW(SPI_CHANNEL, buffer, 3);
        return ((buffer[1] & 0x03) << 8) | buffer[2];
    }

Lit une valeur analogique 10Â bits Ã  partir du canal MCP3008 (CH0â€“CH7) via SPI et renvoie un entier entreÂ 0 etÂ 1023.

.. code-block:: c

    int get_joystick_value() {
        int x = read_ADC(1);
        int y = read_ADC(2);

        if (x > 900)      return 1;   // Droite
        else if (x < 100) return -1;  // Gauche
        else if (y > 900) return -10; // Haut
        else if (y < 100) return 10;  // Bas
        else              return 0;
    }

Lit les valeurs analogiques du joystick sur CH1 (X) et CH2 (Y).  
Retourne un entier indiquant la direction du mouvement selon les seuils.

.. code-block:: c

    void upper_tem_setting() {
        write_lcd(0,0, "Upper Adjust:");

        int change = get_joystick_value();

        if (change != 0 && change != lastJoystickChange) {
            upperTem += change;
            lastJoystickChange = change;
        }
        else if (change == 0) {
            lastJoystickChange = 0;
        }

        char str[6];
        snprintf(str, sizeof(str), "%d", upperTem);
        write_lcd(0,1, str);
        write_lcd(strlen(str),1, "            ");

        delay(100);
    }

Permet Ã  lâ€™utilisateur dâ€™ajuster le seuil de tempÃ©rature maximale avec le joystick.  
Ã‰vite les changements rÃ©pÃ©tÃ©s si la direction est maintenue.

.. code-block:: c

    double temperature() {
        int raw = read_ADC(0);
        double Vr = 3.3 * ((double)raw / 1023.0);
        double Rt = 10000.0 * Vr / (3.3 - Vr);
        double tempK = 1.0 / ((log(Rt/10000.0)/3950.0) + 1.0/(273.15+25.0));
        return tempK - 273.15;
    }

Lit la valeur analogique du canalÂ CH0 connectÃ© Ã  la thermistance.  
Utilise lâ€™Ã©quation de Steinhartâ€“Hart pour calculer la tempÃ©rature enÂ Â°C.

.. code-block:: c

    void monitoring_temp() {
        char str[6];
        double cel = temperature();
        snprintf(str, sizeof(str), "%.2f", cel);
        write_lcd(0,0, "Temp: ");
        write_lcd(6,0, str);

        snprintf(str, sizeof(str), "%d", upperTem);
        write_lcd(0,1, "Upper: ");
        write_lcd(7,1, str);
        delay(100);

        if (cel >= upperTem) {
            digitalWrite(buzzPin, HIGH);
            digitalWrite(LedPin,  HIGH);
        } else {
            digitalWrite(buzzPin, LOW);
            digitalWrite(LedPin,  LOW);
        }
    }

Lit en continu la tempÃ©rature actuelle et lâ€™affiche avec le seuil.  
Si la tempÃ©rature dÃ©passe le seuil, le buzzer et la LED sont activÃ©s.

.. code-block:: c

    void setup_all() {
        fd = wiringPiI2CSetup(LCDAddr);
        lcd_init();
        if (wiringPiSetup() == -1 || wiringPiSPISetup(SPI_CHANNEL, SPI_SPEED) == -1) {
            printf("Setup failed!\n");
            return;
        }
        pinMode(Joy_BtnPin, INPUT);
        pullUpDnControl(Joy_BtnPin, PUD_UP);
        pinMode(buzzPin, OUTPUT);
        pinMode(LedPin,  OUTPUT);
    }

Initialise lâ€™Ã©cran LCD, le SPI, et configure les broches GPIO pour le bouton du joystick, le buzzer et la LED.  
Active Ã©galement la rÃ©sistance de tirage interne pour le bouton du joystick.

.. code-block:: c

    int main(void) {
        setup_all();

        int lastBtnState = HIGH;
        int stage = 0;

        while (1) {
            int curBtn = digitalRead(Joy_BtnPin);
            if (curBtn == HIGH && lastBtnState == LOW) {
                stage = (stage + 1) % 2;
                lastJoystickChange = 0;
                delay(100);
                lcd_clear();
            }
            lastBtnState = curBtn;

            if (stage == 1)
                upper_tem_setting();
            else
                monitoring_temp();
        }

        return 0;
    }

La boucle principale bascule entre deux modesÂ :

1. Surveillance de la tempÃ©rature.  
2. RÃ©glage de la limite supÃ©rieure Ã  lâ€™aide du joystick.

Le changement de mode se fait lors du relÃ¢chement du bouton du joystick (dÃ©tection de front montant).
