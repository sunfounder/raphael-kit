.. _2.1.8_c:

2.1.8 Clavier
==================

Introduction
------------

Un clavier est un tableau rectangulaire de boutons. Dans ce projet, nous l'utiliserons pour entrer des caractères.

Composants requis
---------------------

Dans ce projet, nous avons besoin des composants suivants.

.. image:: ../img/list_2.1.5_keypad.png

Il est certainement pratique d'acheter un kit complet, voici le lien :

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom	
        - ARTICLES DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez également les acheter séparément via les liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION AUX COMPOSANTS
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_keypad`
        - \-

Schéma de câblage
--------------------

.. image:: ../img/image315.png

.. image:: ../img/image316.png

Procédures expérimentales
----------------------------

**Étape 1 :** Construisez le circuit.

.. image:: ../img/image186.png

**Étape 2 :** Ouvrez le fichier de code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/c/2.1.8/

**Étape 3 :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.1.8_Keypad.cpp -lwiringPi

**Étape 4 :** Exécutez.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Après l'exécution du code, les valeurs des boutons appuyés sur le clavier (valeur du bouton) seront affichées à l'écran.

.. note::

    Si cela ne fonctionne pas après l'exécution ou si un message d'erreur apparaît : "wiringPi.h : Aucun fichier ou dossier de ce type", veuillez vous référer à :ref:`install_wiringpi`.

**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>

    #define ROWS  4 
    #define COLS  4
    #define BUTTON_NUM (ROWS * COLS)

    unsigned char KEYS[BUTTON_NUM] {  
    '1','2','3','A',
    '4','5','6','B',
    '7','8','9','C',
    '*','0','#','D'};

    unsigned char rowPins[ROWS] = {1, 4, 5, 6}; 
    unsigned char colPins[COLS] = {12, 3, 2, 0};

    void keyRead(unsigned char* result);
    bool keyCompare(unsigned char* a, unsigned char* b);
    void keyCopy(unsigned char* a, unsigned char* b);
    void keyPrint(unsigned char* a);
    void keyClear(unsigned char* a);
    int keyIndexOf(const char value);

    void init(void) {
        for(int i=0 ; i<4 ; i++) {
            pinMode(rowPins[i], OUTPUT);
            pinMode(colPins[i], INPUT);
        }
    }

    int main(void){
        unsigned char pressed_keys[BUTTON_NUM];
        unsigned char last_key_pressed[BUTTON_NUM];

        if(wiringPiSetup() == -1){ //when initialize wiring failed,print message to screen
            printf("setup wiringPi failed !");
            return 1; 
        }
        init();
        while(1){
            keyRead(pressed_keys);
            bool comp = keyCompare(pressed_keys, last_key_pressed);
            if (!comp){
                keyPrint(pressed_keys);
                keyCopy(last_key_pressed, pressed_keys);
            }
            delay(100);
        }
        return 0;  
    }

    void keyRead(unsigned char* result){
        int index;
        int count = 0;
        keyClear(result);
        for(int i=0 ; i<ROWS ; i++ ){
            digitalWrite(rowPins[i], HIGH);
            for(int j =0 ; j < COLS ; j++){
                index = i * ROWS + j;
                if(digitalRead(colPins[j]) == 1){
                    result[count]=KEYS[index];
                    count += 1;
                }
            }
            delay(1);
            digitalWrite(rowPins[i], LOW);
        }
    }

    bool keyCompare(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            if (a[i] != b[i]){
                return false;
            }
        }
        return true;
    }

    void keyCopy(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            a[i] = b[i];
        }
    }

    void keyPrint(unsigned char* a){
        if (a[0] != 0){
            printf("%c",a[0]);
        }
        for (int i=1; i<BUTTON_NUM; i++){
            if (a[i] != 0){
                printf(", %c",a[i]);
            }
        }
        printf("\n");
    }

    void keyClear(unsigned char* a){
        for (int i=0; i<BUTTON_NUM; i++){
            a[i] = 0;
        }
    }

    int keyIndexOf(const char value){
        for (int i=0; i<BUTTON_NUM; i++){
            if ((const char)KEYS[i] == value){
                return i;
            }
        }
        return -1;
    }
**Explication du Code**

.. code-block:: c

    unsigned char KEYS[BUTTON_NUM] {  
    '1','2','3','A',
    '4','5','6','B',
    '7','8','9','C',
    '*','0','#','D'};

    unsigned char rowPins[ROWS] = {1, 4, 5, 6}; 
    unsigned char colPins[COLS] = {12, 3, 2, 0};

Déclarez chaque touche du clavier matriciel dans le tableau ``keys[]`` et définissez les broches sur chaque ligne et colonne.

.. code-block:: c

    while(1){
            keyRead(pressed_keys);
            bool comp = keyCompare(pressed_keys, last_key_pressed);
            if (!comp){
                keyPrint(pressed_keys);
                keyCopy(last_key_pressed, pressed_keys);
            }
            delay(100);
        }

Voici la partie de la fonction principale qui lit et affiche la valeur du bouton.

La fonction ``keyRead()`` lira l'état de chaque bouton.

``keyCompare()`` et ``keyCopy()`` sont utilisés pour juger si l'état d'un bouton a changé (c'est-à-dire si un bouton a été pressé ou relâché).

``keyPrint()`` affichera la valeur du bouton dont le niveau actuel est élevé (le bouton est pressé).

.. code-block:: c

    void keyRead(unsigned char* result){
        int index;
        int count = 0;
        keyClear(result);
        for(int i=0 ; i<ROWS ; i++ ){
            digitalWrite(rowPins[i], HIGH);
            for(int j =0 ; j < COLS ; j++){
                index = i * ROWS + j;
                if(digitalRead(colPins[j]) == 1){
                    result[count]=KEYS[index];
                    count += 1;
                }
            }
            delay(1);
            digitalWrite(rowPins[i], LOW);
        }
    }

Cette fonction assigne un niveau élevé à chaque ligne à tour de rôle, 
et lorsque la touche de la colonne est pressée, la colonne dans laquelle
 se trouve la touche obtient un niveau élevé. Après le jugement en boucle
  à deux niveaux, la compilation de l'état de la touche générera un tableau (``result[]``).

Lors de l'appui sur le bouton 3 :

.. image:: ../img/image187.png

``RowPin [0]`` écrit le niveau élevé, et ``colPin[2]`` obtient le niveau élevé.
``colPin [0]``, ``colPin[1]``, ``colPin[3]`` obtiennent le niveau bas.

Cela nous donne 0,0,1,0. Lorsque ``rowPin[1]``, ``rowPin[2]`` et ``rowPin[3]`` sont écrits en niveau élevé,
 ``colPin[0]~colPin[4]`` obtiendront le niveau bas.

Après que le jugement en boucle soit terminé, un tableau sera généré :

.. code-block:: c

    result[BUTTON_NUM] {  
    0, 0, 1, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0};

.. code-block:: c

    bool keyCompare(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            if (a[i] != b[i]){
                return false;
            }
        }
        return true;
    }

    void keyCopy(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            a[i] = b[i];
        }
    }

Ces deux fonctions sont utilisées pour juger si l'état de la touche a changé, par exemple
 lorsque vous relâchez votre main après avoir appuyé sur '3' ou en appuyant sur '2',
  ``keyCompare()`` renvoie false.

``keyCopy()`` est utilisé pour réécrire la valeur actuelle du bouton dans 
le tableau a (``last_key_pressed[BUTTON_NUM]``) après chaque comparaison. 
Ainsi, nous pouvons les comparer la prochaine fois.

.. code-block:: c

    void keyPrint(unsigned char* a){
    //printf("{");
        if (a[0] != 0){
            printf("%c",a[0]);
        }
        for (int i=1; i<BUTTON_NUM; i++){
            if (a[i] != 0){
                printf(", %c",a[i]);
            }
        }
        printf("\n");
    }

Cette fonction est utilisée pour imprimer la valeur de la touche actuellement appuyée.
 Si la touche '1' est pressée, le '1' sera imprimé. Si la touche '1' est pressée et que
  la touche '3' est également pressée, '1, 3' sera imprimé.

Image du phénomène
----------------------

.. image:: ../img/image188.jpeg
