.. _2.1.8_c:

2.1.8 Tastenfeld
==================

Einführung
----------

Ein Tastenfeld besteht aus einem rechteckigen Feld von Tasten. In diesem Projekt werden wir es verwenden, um Zeichen einzugeben.

Benötigte Komponenten
-------------------------

Für dieses Projekt benötigen wir die folgenden Komponenten.

.. image:: ../img/list_2.1.5_keypad.png

Es ist definitiv praktisch, ein komplettes Set zu kaufen. Hier ist der Link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Name	
        - ARTIKEL IN DIESEM KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Sie können diese auch separat über die untenstehenden Links kaufen.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - KOMPONENTENBESCHREIBUNG
        - KAUF-LINK

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_keypad`
        - \-

Schaltplan
----------

.. image:: ../img/image315.png

.. image:: ../img/image316.png

Experimentelle Verfahren
------------------------

**Schritt 1:** Schaltkreis aufbauen.

.. image:: ../img/image186.png

**Schritt 2:** Öffnen Sie die Code-Datei.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/c/2.1.8/

**Schritt 3:** Kompilieren Sie den Code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.1.8_Keypad.cpp -lwiringPi

**Schritt 4:** Ausführen.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Nachdem der Code ausgeführt wurde, werden die Werte der gedrückten Tasten auf dem Tastenfeld (Tastenwert) auf dem Bildschirm angezeigt.

.. note::

    Falls es nach dem Ausführen nicht funktioniert oder eine Fehlermeldung erscheint: \"wiringPi.h: Datei oder Verzeichnis nicht gefunden\", beziehen Sie sich bitte auf :ref:`install_wiringpi`.

**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>

    #define ROWS  4 
    #define COLS  4
    #define BUTTON_NUM (ROWS * COLS)

    unsigned char KEYS[BUTTON_NUM] {  
    '1','2','3','A',
    '4','5','6','B',
    '7','8','9','C',
    '*','0','#','D'};

    unsigned char rowPins[ROWS] = {1, 4, 5, 6}; 
    unsigned char colPins[COLS] = {12, 3, 2, 0};

    void keyRead(unsigned char* result);
    bool keyCompare(unsigned char* a, unsigned char* b);
    void keyCopy(unsigned char* a, unsigned char* b);
    void keyPrint(unsigned char* a);
    void keyClear(unsigned char* a);
    int keyIndexOf(const char value);

    void init(void) {
        for(int i=0 ; i<4 ; i++) {
            pinMode(rowPins[i], OUTPUT);
            pinMode(colPins[i], INPUT);
        }
    }

    int main(void){
        unsigned char pressed_keys[BUTTON_NUM];
        unsigned char last_key_pressed[BUTTON_NUM];

        if(wiringPiSetup() == -1){ //when initialize wiring failed,print message to screen
            printf("setup wiringPi failed !");
            return 1; 
        }
        init();
        while(1){
            keyRead(pressed_keys);
            bool comp = keyCompare(pressed_keys, last_key_pressed);
            if (!comp){
                keyPrint(pressed_keys);
                keyCopy(last_key_pressed, pressed_keys);
            }
            delay(100);
        }
        return 0;  
    }

    void keyRead(unsigned char* result){
        int index;
        int count = 0;
        keyClear(result);
        for(int i=0 ; i<ROWS ; i++ ){
            digitalWrite(rowPins[i], HIGH);
            for(int j =0 ; j < COLS ; j++){
                index = i * ROWS + j;
                if(digitalRead(colPins[j]) == 1){
                    result[count]=KEYS[index];
                    count += 1;
                }
            }
            delay(1);
            digitalWrite(rowPins[i], LOW);
        }
    }

    bool keyCompare(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            if (a[i] != b[i]){
                return false;
            }
        }
        return true;
    }

    void keyCopy(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            a[i] = b[i];
        }
    }

    void keyPrint(unsigned char* a){
        if (a[0] != 0){
            printf("%c",a[0]);
        }
        for (int i=1; i<BUTTON_NUM; i++){
            if (a[i] != 0){
                printf(", %c",a[i]);
            }
        }
        printf("\n");
    }

    void keyClear(unsigned char* a){
        for (int i=0; i<BUTTON_NUM; i++){
            a[i] = 0;
        }
    }

    int keyIndexOf(const char value){
        for (int i=0; i<BUTTON_NUM; i++){
            if ((const char)KEYS[i] == value){
                return i;
            }
        }
        return -1;
    }

**Code-Erklärung**

.. code-block:: c

    unsigned char KEYS[BUTTON_NUM] {  
    '1','2','3','A',
    '4','5','6','B',
    '7','8','9','C',
    '*','0','#','D'};

    unsigned char rowPins[ROWS] = {1, 4, 5, 6}; 
    unsigned char colPins[COLS] = {12, 3, 2, 0};

Jeder Taste der Matrix-Tastatur wird im Array ``keys[]`` deklariert und die Pins in jeder Reihe und Spalte definiert.

.. code-block:: c

    while(1){
            keyRead(pressed_keys);
            bool comp = keyCompare(pressed_keys, last_key_pressed);
            if (!comp){
                keyPrint(pressed_keys);
                keyCopy(last_key_pressed, pressed_keys);
            }
            delay(100);
        }

Dies ist der Teil der Hauptfunktion, der den Tastenwert liest und ausgibt.

Die Funktion ``keyRead()`` liest den Zustand jeder Taste.

``KeyCompare()`` und ``keyCopy()`` werden verwendet, um zu beurteilen, ob sich der Zustand einer Taste geändert hat (also eine Taste gedrückt oder losgelassen wurde).

``keyPrint()`` gibt den Tastenwert der Taste aus, deren aktuelles Level High ist (die Taste wird gedrückt).

.. code-block:: c

    void keyRead(unsigned char* result){
        int index;
        int count = 0;
        keyClear(result);
        for(int i=0 ; i<ROWS ; i++ ){
            digitalWrite(rowPins[i], HIGH);
            for(int j =0 ; j < COLS ; j++){
                index = i * ROWS + j;
                if(digitalRead(colPins[j]) == 1){
                    result[count]=KEYS[index];
                    count += 1;
                }
            }
            delay(1);
            digitalWrite(rowPins[i], LOW);
        }
    }

Diese Funktion weist jeder Reihe nacheinander ein High-Level zu und wenn die Taste in der Spalte gedrückt wird, erhält die Spalte, in der sich die Taste befindet, ein High-Level. Nach der zweilagigen Schleifenbewertung wird eine Array-Kompilation des Tastenzustands (``result[]``) erstellt.

Beim Drücken der Taste 3:

.. image:: ../img/image187.png

``RowPin[0]`` wird auf High-Level geschrieben und colPin[2] erhält das High-Level. ``ColPin[0]``, colPin[1], colPin[3] erhalten das Low-Level.

Dies ergibt 0,0,1,0. Wenn rowPin[1], rowPin[2] und rowPin[3] auf High-Level geschrieben werden, erhalten colPin[0]~colPin[4] das Low-Level.

Nach Abschluss der Schleifenbewertung wird ein Array erzeugt:

.. code-block:: c

    result[BUTTON_NUM] {  
    0, 0, 1, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0};

.. code-block:: c

    bool keyCompare(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            if (a[i] != b[i]){
                return false;
            }
        }
        return true;
    }

    void keyCopy(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            a[i] = b[i];
        }
    }

Diese beiden Funktionen werden verwendet, um zu beurteilen, ob sich der Tastenzustand geändert hat, z.B. wenn Sie beim Drücken von '3' Ihre Hand loslassen oder '2' drücken, gibt keyCompare() false zurück.

KeyCopy() wird verwendet, um den aktuellen Tastenwert für das Array a (last_key_pressed[BUTTON_NUM]) nach jedem Vergleich neu zu schreiben. Damit können wir sie das nächste Mal vergleichen.

.. code-block:: c

    void keyPrint(unsigned char* a){
    //printf("{");
        if (a[0] != 0){
            printf("%c",a[0]);
        }
        for (int i=1; i<BUTTON_NUM; i++){
            if (a[i] != 0){
                printf(", %c",a[i]);
            }
        }
        printf("\n");
    }

Diese Funktion wird verwendet, um den Wert der derzeit gedrückten Taste auszugeben. Wenn die Taste '1' gedrückt wird, wird '1' ausgedruckt. Wenn die Taste '1' und die Taste '3' gedrückt werden, wird '1, 3' ausgedruckt.

Phänomen-Bild
---------------

.. image:: ../img/image188.jpeg


