 
.. _3.1.7_c:

3.1.7 Moniteur de Surchauffe
==================================

Introduction
-------------------

Vous pouvez vouloir créer un dispositif de surveillance de la surchauffe applicable à diverses
 situations, par exemple, dans une usine, si nous voulons avoir une alarme et l'arrêt automatique
  de la machine en temps opportun en cas de surchauffe du circuit. Dans ce projet, nous utiliserons
   une thermistance, un joystick, un buzzer, une LED et un écran LCD pour réaliser un dispositif 
   intelligent de surveillance de la température dont le seuil est ajustable.


Composants Nécessaires
------------------------------

Pour ce projet, nous avons besoin des composants suivants.

.. image:: ../img/list_Overheat_Monitor.png
    :align: center

Il est définitivement pratique d'acheter un kit complet, voici le lien : 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom	
        - ÉLÉMENTS DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez également les acheter séparément à partir des liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DES COMPOSANTS
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_joystick`
        - \-
    *   - :ref:`cpn_adc0834`
        - \-
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|
    *   - :ref:`cpn_i2c_lcd`
        - |link_i2clcd1602_buy|
    *   - :ref:`cpn_thermistor`
        - |link_thermistor_buy|
    *   - :ref:`cpn_buzzer`
        - \-

Schéma de Câblage
--------------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin15    3        22
GPIO23       Pin16    4        23
GPIO24       Pin18    5        24
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: ../img/Schematic_three_one8.png
   :align: center
Procédures expérimentales
-----------------------------

**Étape 1 :** Construisez le circuit.

.. image:: ../img/image258.png

**Étape 2 :** Accédez au dossier du code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/c/3.1.7/

**Étape 3 :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.7_OverheatMonitor.c -lm -lwiringPi

**Étape 4 :** Exécutez le fichier exécutable.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

Pendant l'exécution du code, la température actuelle et le seuil de haute température **40** 
sont affichés sur le **I2C LCD1602**. Si la température actuelle dépasse le seuil, le buzzer 
et la LED se déclenchent pour vous alerter.

**Joystick** permet d'ajuster le seuil de haute température en appuyant dessus. En déplaçant le
 **Joystick** dans la direction de l'axe X ou Y, vous pouvez augmenter ou diminuer le seuil de 
 haute température actuel. Appuyez à nouveau sur le **Joystick** pour réinitialiser le seuil à 
 sa valeur initiale.

.. note::

    * Si un message d'erreur ``wiringPi.h: Aucun fichier ou dossier de ce type`` apparaît, veuillez vous référer à :ref:`install_wiringpi`.
    * Si vous recevez l'erreur ``Impossible d'ouvrir le périphérique I2C : Aucun fichier ou dossier de ce type``, vous devez vous référer à :ref:`i2c_config` pour activer I2C et vérifier si le câblage est correct.
    * Si le code et le câblage sont corrects mais que l'écran LCD n'affiche toujours rien, vous pouvez ajuster le potentiomètre à l'arrière pour augmenter le contraste.
**Explication du code**

.. code-block:: c

    int get_joystick_value(){
        uchar x_val;
        uchar y_val;
        x_val = get_ADC_Result(1);
        y_val = get_ADC_Result(2);
        if (x_val > 200){
            return 1;
        }
        else if(x_val < 50){
            return -1;
        }
        else if(y_val > 200){
            return -10;
        }
        else if(y_val < 50){
            return 10;
        }
        else{
            return 0;
        }
    }

Cette fonction lit les valeurs de X et Y. Si ``X>200``, elle retournera
``1`` ; ``X<50``, elle retournera ``-1`` ; ``Y>200``, elle retournera
``-10``, et ``Y<50``, elle retournera ``10``.

.. code-block:: c

    void upper_tem_setting(){
        write(0, 0, "Upper Adjust:");
        int change = get_joystick_value();
        upperTem = upperTem + change;
        char str[6];
        snprintf(str,3,"%d",upperTem);
    write(0,1,str);
    int len;
      len = strlen(str);
      write(len,1,"             ");
        delay(100);
    }

Cette fonction permet de régler le seuil et de l'afficher sur le
I2C LCD1602.

.. code-block:: c

    double temperature(){
        unsigned char temp_value;
        double Vr, Rt, temp, cel, Fah;
        temp_value = get_ADC_Result(0);
        Vr = 5 * (double)(temp_value) / 255;
        Rt = 10000 * (double)(Vr) / (5 - (double)(Vr));
        temp = 1 / (((log(Rt/10000)) / 3950)+(1 / (273.15 + 25)));
        cel = temp - 273.15;
        Fah = cel * 1.8 +32;
        return cel;
    }

Lire la valeur analogique de **CH0** (thermistance) de **ADC0834** et
la convertir ensuite en valeur de température.

.. code-block:: c

    void monitoring_temp(){
        char str[6];
        double cel = temperature();
        snprintf(str,6,"%.2f",cel);
        write(0, 0, "Temp: ");
        write(6, 0, str);
        snprintf(str,3,"%d",upperTem);
        write(0, 1, "Upper: ");
        write(7, 1, str);
        delay(100);
        if(cel >= upperTem){
            digitalWrite(buzzPin, HIGH);
            digitalWrite(LedPin, HIGH);
        }
        else if(cel < upperTem){
            digitalWrite(buzzPin, LOW);
            digitalWrite(LedPin, LOW);
        }
    }

Lorsque le code s'exécute, la température actuelle et le seuil de haute température 
**40** sont affichés sur le **I2C LCD1602**. Si la température actuelle dépasse le 
seuil, le buzzer et la LED s'activent pour vous alerter.

.. code-block:: c

    int main(void)
    {
        setup();
        int lastState =1;
        int stage=0;
        while (1)
        {
            int currentState = digitalRead(Joy_BtnPin);
            if(currentState==1 && lastState == 0){
                stage=(stage+1)%2;
                delay(100);
                lcd_clear();
            }
            lastState=currentState;
            if (stage==1){
                upper_tem_setting();
            }
            else{
                monitoring_temp();
            }
        }
        return 0;
    }

La fonction ``main()`` contient tout le processus du programme comme suit :

1) Lorsque le programme démarre, la valeur initiale de **stage** est **0**, 
et la température actuelle ainsi que le seuil de haute température **40** 
sont affichés sur le **I2C LCD1602**. Si la température actuelle dépasse le 
seuil, le buzzer et la LED s'activent pour vous alerter.

2) Appuyez sur le joystick, et **stage** passera à **1** vous permettant d'ajuster 
le seuil de haute température. En déplaçant le joystick dans la direction de l'axe X ou Y, 
vous pouvez augmenter ou diminuer le seuil actuel. Appuyez à nouveau sur le joystick pour 
réinitialiser le seuil à sa valeur initiale.


Image du phénomène
-------------------------

.. image:: ../img/image259.jpeg
   :align: center