.. note::

    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten.

    **Warum beitreten?**

    - **ExpertenunterstÃ¼tzung**: LÃ¶sen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams.
    - **Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre FÃ¤higkeiten zu verbessern.
    - **Exklusive Vorschauen**: Erhalten Sie frÃ¼hzeitigen Zugang zu neuen ProduktankÃ¼ndigungen und exklusiven Einblicken.
    - **Spezialrabatte**: GenieÃŸen Sie exklusive Rabatte auf unsere neuesten Produkte.
    - **Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil.

    ðŸ‘‰ Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!

.. _3.1.7_c:

3.1.7 ÃœberhitzungsÃ¼berwachung
===================================


.. note::

    .. image:: ../img/mcp3008_and_adc0834.jpg
        :width: 25%
        :align: left
        
    AbhÃ¤ngig von Ihrer Kit-Version identifizieren Sie bitte, ob Sie **ADC0834** oder **MCP3008** haben, und fahren Sie mit dem entsprechenden Abschnitt fort.





EinfÃ¼hrung
-------------------

MÃ¶glicherweise mÃ¶chten Sie ein ÃœberhitzungsÃ¼berwachungsgerÃ¤t herstellen, das fÃ¼r verschiedene Situationen geeignet ist, z.B. in der Fabrik, wenn wir einen Alarm haben mÃ¶chten und das rechtzeitige automatische Abschalten der Maschine, wenn es zu einer Schaltungserhitzung kommt. In diesem Projekt werden wir einen Thermistor, einen Joystick, eine Hupe, eine LED und ein LCD verwenden, um ein intelligentes TemperaturÃ¼berwachungsgerÃ¤t herzustellen, dessen Schwellenwert einstellbar ist.

BenÃ¶tigte Komponenten
------------------------------

FÃ¼r dieses Projekt benÃ¶tigen wir die folgenden Komponenten.

.. image:: ../img/list_Overheat_Monitor.png
    :align: center

Es ist definitiv praktisch, ein komplettes Kit zu kaufen, hier ist der Link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Name	
        - ARTIKEL IN DIESEM KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Sie kÃ¶nnen sie auch separat Ã¼ber die untenstehenden Links kaufen.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - KOMPONENTENBESCHREIBUNG
        - KAUF LINK

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_joystick`
        - \-
    *   - :ref:`cpn_adc0834`
        - \-
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|
    *   - :ref:`cpn_i2c_lcd`
        - |link_i2clcd1602_buy|
    *   - :ref:`cpn_thermistor`
        - |link_thermistor_buy|
    *   - :ref:`cpn_buzzer`
        - \-

Schaltplan
--------------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin15    3        22
GPIO23       Pin16    4        23
GPIO24       Pin18    5        24
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: ../img/Schematic_three_one8.png
   :align: center

Experimentelle Verfahren
-----------------------------

**Schritt 1:** Bauen Sie den Schaltkreis.

.. image:: ../img/image258.png

**Schritt 2**: Gehen Sie zum Ordner des Codes.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/c/3.1.7/

**Schritt 3**: Kompilieren Sie den Code.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.7_ÃœberhitzungsÃ¼berwachung.c -lm -lwiringPi

**Schritt 4**: FÃ¼hren Sie die ausfÃ¼hrbare Datei aus.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

Wenn der Code ausgefÃ¼hrt wird, werden die aktuelle Temperatur und der Hochtemperaturschwellenwert **40** auf **I2C LCD1602** angezeigt. Wenn die aktuelle Temperatur hÃ¶her als der Schwellenwert ist, werden die Hupe und die LED gestartet, um Sie zu alarmieren.

Der **Joystick** dient hier zum DrÃ¼cken, um den Hochtemperaturschwellenwert anzupassen. Durch das Umschalten des **Joysticks** in Richtung der X- und Y-Achse kÃ¶nnen Sie den aktuellen Hochtemperaturschwellenwert erhÃ¶hen oder verringern. DrÃ¼cken Sie den **Joystick** erneut, um den Schwellenwert auf den Ausgangswert zurÃ¼ckzusetzen.

.. note::

    * Wenn die Fehlermeldung ``wiringPi.h: No such file or directory`` angezeigt wird, verweisen Sie bitte auf :ref:`install_wiringpi`.
    * Wenn Sie den Fehler ``Unable to open I2C device: No such file or directory`` erhalten, mÃ¼ssen Sie sich auf :ref:`i2c_config` beziehen, um I2C zu aktivieren und zu Ã¼berprÃ¼fen, ob die Verdrahtung korrekt ist.
    * Wenn der Code und die Verdrahtung in Ordnung sind, das LCD jedoch immer noch keinen Inhalt anzeigt, kÃ¶nnen Sie das Potentiometer auf der RÃ¼ckseite drehen, um den Kontrast zu erhÃ¶hen.

**Code-ErklÃ¤rung**

.. code-block:: c

    intÂ get_joystick_value(){
    Â Â Â Â ucharÂ x_val;
    Â Â Â Â ucharÂ y_val;
    Â Â Â Â x_valÂ =Â get_ADC_Result(1);
    Â Â Â Â y_valÂ =Â get_ADC_Result(2);
    Â Â Â Â ifÂ (x_valÂ >Â 200){
    Â Â Â Â Â Â Â Â returnÂ 1;
    Â Â Â Â }
    Â Â Â Â elseÂ if(x_valÂ <Â 50){
    Â Â Â Â Â Â Â Â returnÂ -1;
    Â Â Â Â }
    Â Â Â Â elseÂ if(y_valÂ >Â 200){
    Â Â Â Â Â Â Â Â returnÂ -10;
    Â Â Â Â }
    Â Â Â Â elseÂ if(y_valÂ <Â 50){
    Â Â Â Â Â Â Â Â returnÂ 10;
    Â Â Â Â }
    Â Â Â Â else{
    Â Â Â Â Â Â Â Â returnÂ 0;
    Â Â Â Â }
    }

Diese Funktion liest Werte von X und Y. Wenn ``X>200``, wird 
``1`` zurÃ¼ckgegeben; ``X<50``, gibt ``-1`` zurÃ¼ck; ``y>200``, gibt 
``-10`` zurÃ¼ck, und ``y<50``, gibt ``10`` zurÃ¼ck.

.. code-block:: c

    voidÂ upper_tem_setting(){
    Â Â Â Â write(0,Â 0,Â "UpperÂ Adjust:");
    Â Â Â Â intÂ changeÂ =Â get_joystick_value();
    Â Â Â Â upperTemÂ =Â upperTemÂ +Â change;
    Â Â Â Â charÂ str[6];
    Â Â Â Â snprintf(str,3,"%d",upperTem);
    write(0,1,str);
    intÂ len;
    Â Â lenÂ =Â strlen(str);
    Â Â write(len,1,"Â Â Â Â Â Â Â Â Â Â Â Â Â ");
    Â Â Â Â delay(100);
    }

Diese Funktion dient zur Anpassung des Schwellenwertes und zur Anzeige auf dem 
I2C LCD1602.

.. code-block:: c

    doubleÂ temperature(){
    Â Â Â Â unsignedÂ charÂ temp_value;
    Â Â Â Â doubleÂ Vr,Â Rt,Â temp,Â cel,Â Fah;
    Â Â Â Â temp_valueÂ =Â get_ADC_Result(0);
    Â Â Â Â VrÂ =Â 5Â *Â (double)(temp_value)Â /Â 255;
    Â Â Â Â RtÂ =Â 10000Â *Â (double)(Vr)Â /Â (5Â -Â (double)(Vr));
    Â Â Â Â tempÂ =Â 1Â /Â (((log(Rt/10000))Â /Â 3950)+(1Â /Â (273.15Â +Â 25)));
    Â Â Â Â celÂ =Â tempÂ -Â 273.15;
    Â Â Â Â FahÂ =Â celÂ *Â 1.8Â +32;
    Â Â Â Â returnÂ cel;
    }

Liest den analogen Wert des **CH0** (Thermistor) des **ADC0834** und 
konvertiert ihn in einen Temperaturwert.

.. code-block:: c

    voidÂ monitoring_temp(){
    Â Â Â Â charÂ str[6];
    Â Â Â Â doubleÂ celÂ =Â temperature();
    Â Â Â Â snprintf(str,6,"%.2f",cel);
    Â Â Â Â write(0,Â 0,Â "Temp:Â ");
    Â Â Â Â write(6,Â 0,Â str);
    Â Â Â Â snprintf(str,3,"%d",upperTem);
    Â Â Â Â write(0,Â 1,Â "Upper:Â ");
    Â Â Â Â write(7,Â 1,Â str);
    Â Â Â Â delay(100);
    Â Â Â Â if(celÂ >=Â upperTem){
    Â Â Â Â Â Â Â Â digitalWrite(buzzPin,Â HIGH);
    Â Â Â Â Â Â Â Â digitalWrite(LedPin,Â HIGH);
    Â Â Â Â }
    Â Â Â Â elseÂ if(celÂ <Â upperTem){
    Â Â Â Â Â Â Â Â digitalWrite(buzzPin,Â LOW);
    Â Â Â Â Â Â Â Â digitalWrite(LedPin,Â LOW);
    Â Â Â Â }
    }

WÃ¤hrend der Code lÃ¤uft, werden die aktuelle Temperatur und der Hochtemperatur-
Schwellenwert **40** auf dem **I2C LCD1602** angezeigt. Wenn die aktuelle 
Temperatur hÃ¶her als der Schwellenwert ist, werden Buzzer und LED aktiviert, um Sie zu warnen.

.. code-block:: c

    intÂ main(void)
    {
    Â Â Â Â setup();
    Â Â Â Â intÂ lastStateÂ =1;
    Â Â Â Â intÂ stage=0;
    Â Â Â Â whileÂ (1)
    Â Â Â Â {
    Â Â Â Â Â Â Â Â intÂ currentStateÂ =Â digitalRead(Joy_BtnPin);
    Â Â Â Â Â Â Â Â if(currentState==1Â &&Â lastStateÂ ==Â 0){
    Â Â Â Â Â Â Â Â Â Â Â Â stage=(stage+1)%2;
    Â Â Â Â Â Â Â Â Â Â Â Â delay(100);
    Â Â Â Â Â Â Â Â Â Â Â Â lcd_clear();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â lastState=currentState;
    Â Â Â Â Â Â Â Â ifÂ (stage==1){
    Â Â Â Â Â Â Â Â Â Â Â Â upper_tem_setting();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â else{
    Â Â Â Â Â Â Â Â Â Â Â Â monitoring_temp();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â }
    Â Â Â Â returnÂ 0;
    }

Die Funktion ``main()`` beinhaltet den gesamten Programmablauf:

1) Bei Programmstart ist der Anfangswert von **stage** **0**, und 
   die aktuelle Temperatur sowie der Hochtemperatur-Schwellenwert **40** werden 
   auf dem **I2C LCD1602** angezeigt. Wenn die aktuelle Temperatur den Schwellenwert 
   Ã¼berschreitet, werden Buzzer und LED aktiviert, um Sie zu warnen.

2) DrÃ¼cken Sie den Joystick, wird **stage** auf **1** gesetzt und Sie kÃ¶nnen 
   den Hochtemperatur-Schwellenwert anpassen. Durch Kippen des Joysticks in X- 
   und Y-Richtung kann der aktuelle Schwellenwert angepasst (erhÃ¶ht oder 
   verringert) werden. Ein erneutes DrÃ¼cken des Joysticks setzt den Schwellenwert 
   auf den Ausgangswert zurÃ¼ck.

PhÃ¤nomen-Bild
-------------------------

.. image:: ../img/image259.jpeg
   :align: center