.. note::

    Ciao, benvenuto nella community SunFounder Raspberry Pi & Arduino & ESP32 su Facebook! Approfondisci la tua esperienza con Raspberry Pi, Arduino ed ESP32 insieme ad altri appassionati.

    **Perch√© unirti a noi?**

    - **Supporto Esperto**: Risolvi problemi post-vendita e sfide tecniche con l'aiuto della nostra comunit√† e del nostro team.
    - **Impara e Condividi**: Scambia suggerimenti e tutorial per migliorare le tue competenze.
    - **Anteprime Esclusive**: Ottieni accesso anticipato agli annunci di nuovi prodotti e anteprime.
    - **Sconti Speciali**: Approfitta di sconti esclusivi sui nostri prodotti pi√π recenti.
    - **Promozioni Festive e Giveaway**: Partecipa a concorsi e promozioni festive.

    üëâ Pronto a esplorare e creare con noi? Clicca su [|link_sf_facebook|] e unisciti subito!

.. _1.1.4_c:

1.1.4 Display a 7 Segmenti
===============================

Introduzione
-------------------

Proviamo a gestire un display a 7 segmenti per visualizzare una cifra da 0 a 9 e da A a F.

Componenti Necessari
--------------------------------

In questo progetto, abbiamo bisogno dei seguenti componenti. 

.. image:: ../img/list_7_segment.png

√à sicuramente conveniente acquistare un kit completo, ecco il link: 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nome	
        - COMPONENTI NEL KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Puoi anche acquistarli separatamente dai seguenti link.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUZIONE AI COMPONENTI
        - LINK PER L'ACQUISTO

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_7_segment`
        - |link_7segment_buy|
    *   - :ref:`cpn_74hc595`
        - |link_74hc595_buy|

Schema Elettrico
-----------------------

Collega il pin ST_CP del 74HC595 al GPIO18 del Raspberry Pi, SH_CP al GPIO27, 
DS al GPIO17, le porte di uscita parallele agli 8 segmenti del display a 7 segmenti. 
I dati di input vengono inviati nel pin DS al registro a scorrimento quando SH_CP 
(l'ingresso di clock del registro a scorrimento) √® al fronte di salita, e al registro 
di memoria quando ST_CP (l'ingresso di clock della memoria) √® al fronte di salita. 
Puoi controllare gli stati di SH_CP e ST_CP tramite i GPIO del Raspberry Pi per 
trasformare l'input seriale in output parallelo, risparmiando cos√¨ GPIO del Raspberry 
Pi e pilotando il display.

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
============ ======== ======== ===

.. image:: ../img/schematic_7_segment.png


Procedure Sperimentali
------------------------------

**Passo 1:** Costruisci il circuito.

.. image:: ../img/image73.png

**Passo 2:** Vai alla cartella del codice.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/c/1.1.4/

**Passo 3:** Compila.

.. raw:: html

   <run></run>

.. code-block::

    gcc 1.1.4_7-Segment.c -lwiringPi

**Passo 4:** Esegui il file eseguibile compilato.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Dopo aver eseguito il codice, vedrai che il display a 7 segmenti visualizzer√† da 0 a 9 e da A a F.

.. note::

    Se non funziona dopo l'esecuzione o appare un messaggio di errore: \"wiringPi.h: No such file or directory\", fai riferimento a :ref:`install_wiringpi`.

**Codice**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #define   SDI   0   //input dati seriali
    #define   RCLK  1   //input clock memoria (STCP)
    #define   SRCLK 2   //input clock registro a scorrimento (SHCP)
    unsigned char SegCode[16] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};

    void init(void){
        pinMode(SDI, OUTPUT); 
        pinMode(RCLK, OUTPUT);
        pinMode(SRCLK, OUTPUT); 
        digitalWrite(SDI, 0);
        digitalWrite(RCLK, 0);
        digitalWrite(SRCLK, 0);
    }

    void hc595_shift(unsigned char dat){
        int i;
        for(i=0;i<8;i++){
            digitalWrite(SDI, 0x80 & (dat << i));
            digitalWrite(SRCLK, 1);
            delay(1);
            digitalWrite(SRCLK, 0);
        }
            digitalWrite(RCLK, 1);
            delay(1);
            digitalWrite(RCLK, 0);
    }

    int main(void){
        int i;
        if(wiringPiSetup() == -1){ //quando l'inizializzazione di wiring fallisce, stampa il messaggio a schermo
            printf("setup wiringPi failed !");
            return 1;
        }
        init();
        while(1){
            for(i=0;i<16;i++){
                printf("Print %1X on Segment\n", i); // %X means hex output
                hc595_shift(SegCode[i]);
                delay(500);
            }
        }
        return 0;
    }

**Spiegazione del Codice**

.. code-block:: c

    unsigned char SegCode[16] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};

Un array di codici segmento da 0 a F in esadecimale (catodo comune).

.. code-block:: c

    void init(void){
        pinMode(SDI, OUTPUT); 
        pinMode(RCLK, OUTPUT); 
        pinMode(SRCLK, OUTPUT); 
        digitalWrite(SDI, 0);
        digitalWrite(RCLK, 0);
        digitalWrite(SRCLK, 0);
    }

Imposta i tre pin ds, st_cp, sh_cp come OUTPUT, con stato iniziale a 0.

.. code-block:: c

    void hc595_shift(unsigned char dat){}

Assegna un valore a 8 bit al registro a scorrimento del 74HC595.

.. code-block:: c

    digitalWrite(SDI, 0x80 & (dat << i));

Assegna il dato dat al pin SDI(DS) bit per bit. Supponiamo che dat=0x3f (0011 1111), quando i=2, 0x3f sar√† spostato a sinistra (<<) di 2 bit. 1111 1100 (0x3f << 2) & 1000 0000 (0x80) = 1000 0000, √® vero.

.. code-block:: c

    digitalWrite(SRCLK, 1);

Il valore iniziale di SRCLK era 0, qui viene impostato su 1 per generare un impulso di salita e trasferire i dati DS al registro a scorrimento.

.. code-block:: c

    digitalWrite(RCLK, 1);

Il valore iniziale di RCLK era 0, qui viene impostato su 1 per generare un impulso di salita e trasferire i dati dal registro a scorrimento al registro di memoria.

.. code-block:: c

    while(1){
            for(i=0;i<16;i++){
                printf("Print %1X on Segment\n", i); // %X means hex output
                hc595_shift(SegCode[i]);
                delay(500);
            }
        }

In questo ciclo for, utilizziamo ``%1X`` per stampare i come numero esadecimale. Applichiamo i per trovare il codice del segmento corrispondente nell'array ``SegCode[]`` e usiamo ``hc595_shift()`` per passare il SegCode nel registro a scorrimento del 74HC595.

.. note::
    I numeri esadecimali da 0 a 15 sono (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F).

**Immagine del Fenomeno**

.. image:: ../img/image74.jpeg

