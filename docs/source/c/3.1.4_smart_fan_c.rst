.. note::

    Ciao, benvenuto nella Community di appassionati di SunFounder Raspberry Pi & Arduino & ESP32 su Facebook! Approfondisci Raspberry Pi, Arduino ed ESP32 insieme agli altri appassionati.

    **PerchÃ© unirti a noi?**

    - **Supporto esperto**: Risolvi problemi post-vendita e sfide tecniche con l'aiuto della nostra community e del nostro team.
    - **Impara e condividi**: Scambia suggerimenti e tutorial per migliorare le tue competenze.
    - **Anteprime esclusive**: Ottieni accesso anticipato a nuovi annunci di prodotti e anteprime.
    - **Sconti speciali**: Godi di sconti esclusivi sui nostri prodotti piÃ¹ recenti.
    - **Promozioni festive e omaggi**: Partecipa a omaggi e promozioni speciali per le festivitÃ .

    ðŸ‘‰ Sei pronto a esplorare e creare con noi? Clicca su [|link_sf_facebook|] e unisciti oggi stesso!

.. _3.1.4_c:

3.1.4 Ventola Intelligente
===========================

.. note::

   .. image:: ../img/mcp3008_and_adc0834.jpg
      :width: 25%
      :align: left
    

   A seconda della versione del tuo kit, identifica se hai **ADC0834** o **MCP3008** e procedi con la sezione corrispondente.

Introduzione
-------------

In questo progetto, utilizzeremo motori, pulsanti e termistori per realizzare una ventola intelligente manuale + automatica con velocitÃ  regolabile.

Componenti necessari
------------------------------

In questo progetto avremo bisogno dei seguenti componenti. 

.. image:: ../img/list_Smart_Fan.png
    :align: center

Ãˆ sicuramente conveniente acquistare un kit completo, ecco il link: 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nome	
        - ELEMENTI IN QUESTO KIT
        - LINK
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Puoi anche acquistare i componenti separatamente dai link qui sotto.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUZIONE COMPONENTI
        - LINK DI ACQUISTO

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_power_module`
        - \-
    *   - :ref:`cpn_thermistor`
        - |link_thermistor_buy|
    *   - :ref:`cpn_l293d`
        - \-
    *   - :ref:`cpn_adc0834`
        - \-
    *   - :ref:`cpn_button`
        - |link_button_buy|
    *   - :ref:`cpn_motor`
        - |link_motor_buy|

Schema elettrico
------------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin 15   3        22
GPIO5        Pin 29   21       5
GPIO6        Pin 31   22       6
GPIO13       Pin 33   23       13
============ ======== ======== ===

.. image:: ../img/Schematic_three_one4.png
   :align: center

Procedura sperimentale
-----------------------------

**Passo 1:** Costruisci il circuito.

.. image:: ../img/image245.png
    :align: center

.. note::
    Il modulo di alimentazione puÃ² utilizzare una batteria da 9V con il connettore 
    per batteria da 9V incluso nel kit. Inserisci il cappuccio del jumper del modulo 
    di alimentazione nelle strisce del bus da 5V della breadboard.

.. image:: ../img/image118.jpeg
    :align: center

**Passo 2**: Entra nella cartella del codice.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/c/3.1.4/

**Passo 3**: Compila.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.4_SmartFan.c -lwiringPi -lm

**Passo 4**: Esegui il file eseguibile sopra.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

Quando il codice viene eseguito, avvia la ventola premendo il pulsante. 
Ogni volta che premi, la velocitÃ  aumenta o diminuisce di un livello. 
Ci sono **5** livelli di velocitÃ : **0~4**. Quando impostato sul 4\ 
:sup:`th` livello di velocitÃ  e premi il pulsante, la ventola smette 
di funzionare con una velocitÃ  del vento pari a **0**.

Quando la temperatura aumenta o diminuisce di oltre 2â„ƒ, la velocitÃ  aumenta o diminuisce automaticamente di 1 livello.

.. note::

    Se non funziona dopo l'esecuzione o compare un errore come: \"wiringPi.h: Nessun file o directory\", fai riferimento a :ref:`install_wiringpi`.

Codice
----------

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #include <softPwm.h>
    #include <math.h>

    typedef unsigned char uchar;
    typedef unsigned int uint;

    #define ADC_CS      0
    #define ADC_CLK     1
    #define ADC_DIO     2
    #define MotorPin1   21
    #define MotorPin2   22
    #define MotorEnable 23
    #define BtnPin      3

    uchar get_ADC_Result(uint channel)
    {
        uchar i;
        uchar dat1=0, dat2=0;
        int sel = channel > 1 & 1;
        int odd = channel & 1;

        digitalWrite(ADC_CLK, 1);
        delayMicroseconds(2);
        digitalWrite(ADC_CLK, 0);
        delayMicroseconds(2);

        pinMode(ADC_DIO, OUTPUT);
        digitalWrite(ADC_CS, 0);
        // Start bit
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        //Single End mode
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // ODD
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,odd);  delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        //Select
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,sel);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);

        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);

        for(i=0;i<8;i++)
        {
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);

            pinMode(ADC_DIO, INPUT);
            dat1=dat1<<1 | digitalRead(ADC_DIO);
        }

        for(i=0;i<8;i++)
        {
            dat2 = dat2 | ((uchar)(digitalRead(ADC_DIO))<<i);
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);
        }

        digitalWrite(ADC_CS,1);
        pinMode(ADC_DIO, OUTPUT);
        return(dat1==dat2) ? dat1 : 0;
    }

    int temperture(){
        unsigned char analogVal;
        double Vr, Rt, temp, cel, Fah;
        analogVal = get_ADC_Result(0);
        Vr = 5 * (double)(analogVal) / 255;
        Rt = 10000 * (double)(Vr) / (5 - (double)(Vr));
        temp = 1 / (((log(Rt/10000)) / 3950)+(1 / (273.15 + 25)));
        cel = temp - 273.15;
        Fah = cel * 1.8 +32;
        int t=cel;
        return t;
    }

    int motor(int level){
        if(level==0){
            digitalWrite(MotorEnable,LOW);
            return 0;
        }
        if (level>=4){
            level =4;
        }
        digitalWrite(MotorEnable,HIGH);
        softPwmWrite(MotorPin1, level*25);
        return level;    
    }
    void setup(){
        if(wiringPiSetup() == -1){ //when initialize wiring failed,print messageto screen
            printf("setup wiringPi failed !");
            return;
        }
        softPwmCreate(MotorPin1,  0, 100);
        softPwmCreate(MotorPin2,  0, 100);
        pinMode(MotorEnable,OUTPUT);
        pinMode(BtnPin,INPUT);
        pinMode(ADC_CS,  OUTPUT);
        pinMode(ADC_CLK, OUTPUT);
    }

    int main(void)
    {
        setup();
        int currentState,lastState=0;
        int level = 0;
        int currentTemp,markTemp=0;
        while(1){
            currentState=digitalRead(BtnPin);
            currentTemp=temperture();
            if (currentTemp<=0){continue;}
            if (currentState==1&&lastState==0){
                level=(level+1)%5;
                markTemp=currentTemp;
                delay(500);
            }
            lastState=currentState;
            if (level!=0){
                if (currentTemp-markTemp<=-2){
                    level=level-1;
                    markTemp=currentTemp;
                }
                if (currentTemp-markTemp>=2){
                    level=level+1;
                    markTemp=currentTemp;
                }
            }
            level=motor(level);
        }
        return 0;
    }

Spiegazione del Codice
----------------------------

.. code-block:: c

    intÂ temperture(){
    Â Â Â Â unsignedÂ charÂ analogVal;
    Â Â Â Â doubleÂ Vr,Â Rt,Â temp,Â cel,Â Fah;
    Â Â Â Â analogValÂ =Â get_ADC_Result(0);
    Â Â Â Â VrÂ =Â 5Â *Â (double)(analogVal)Â /Â 255;
    Â Â Â Â RtÂ =Â 10000Â *Â (double)(Vr)Â /Â (5Â -Â (double)(Vr));
    Â Â Â Â tempÂ =Â 1Â /Â (((log(Rt/10000))Â /Â 3950)+(1Â /Â (273.15Â +Â 25)));
    Â Â Â Â celÂ =Â tempÂ -Â 273.15;
    Â Â Â Â FahÂ =Â celÂ *Â 1.8Â +32;
    Â Â Â Â intÂ t=cel;
    Â Â Â Â returnÂ t;
    }

La funzione **temperture()** converte i valori del termistore letti da ADC0834 
in valori di temperatura. Vedi :ref:`2.2.2_c` per maggiori dettagli.

.. code-block:: c

    intÂ motor(intÂ level){
    Â Â Â Â if(level==0){
    Â Â Â Â Â Â Â Â digitalWrite(MotorEnable,LOW);
    Â Â Â Â Â Â Â Â returnÂ 0;
    Â Â Â Â }
    Â Â Â Â ifÂ (level>=4){
    Â Â Â Â Â Â Â Â levelÂ =4;
    Â Â Â Â }
    Â Â Â Â digitalWrite(MotorEnable,HIGH);
    Â Â Â Â softPwmWrite(MotorPin1,Â level*25);
    Â Â Â Â returnÂ level;Â Â Â Â 
    }

Questa funzione controlla la velocitÃ  di rotazione del motore. L'intervallo di 
**livelli**: **0-4** (il livello **0** ferma il motore). Ogni incremento di 
livello rappresenta una variazione del **25%** della velocitÃ  del vento.

.. code-block:: c

    intÂ main(void)
    {
    Â Â Â Â setup();
    Â Â Â Â intÂ currentState,lastState=0;
    Â Â Â Â intÂ levelÂ =Â 0;
    Â Â Â Â intÂ currentTemp,markTemp=0;
    Â Â Â Â while(1){
    Â Â Â Â Â Â Â Â currentState=digitalRead(BtnPin);
    Â Â Â Â Â Â Â Â currentTemp=temperture();
    Â Â Â Â Â Â Â Â ifÂ (currentTemp<=0){continue;}
    Â Â Â Â Â Â Â Â ifÂ (currentState==1&&lastState==0){
    Â Â Â Â Â Â Â Â Â Â Â Â level=(level+1)%5;
    Â Â Â Â Â Â Â Â Â Â Â Â markTemp=currentTemp;
    Â Â Â Â Â Â Â Â Â Â Â Â delay(500);
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â lastState=currentState;
    Â Â Â Â Â Â Â Â ifÂ (level!=0){
    Â Â Â Â Â Â Â Â Â Â Â Â ifÂ (currentTemp-markTemp<=-2){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â level=level-1;
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â markTemp=currentTemp;
    Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â ifÂ (currentTemp-markTemp>=2){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â level=level+1;
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â markTemp=currentTemp;
    Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â level=motor(level);
    Â Â Â Â }
    Â Â Â Â returnÂ 0;
    }

La funzione **main()** contiene l'intero processo del programma come segue:

1) Leggi costantemente lo stato del pulsante e la temperatura corrente.

2) Ogni pressione aumenta il livello di **+1** e allo stesso tempo, la temperatura 
   viene aggiornata. L'intervallo di **livelli** Ã¨ **1~4**.

3) Quando la ventola funziona (il livello non Ã¨ **0**), la temperatura Ã¨ sotto 
   controllo. Un cambiamento di **2â„ƒ\ +** provoca l'aumento o la diminuzione del livello.

4) Il motore modifica la velocitÃ  di rotazione con il **livello**.


