.. note::

    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten.

    **Warum beitreten?**

    - **Expertenunterst√ºtzung**: L√∂sen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams.
    - **Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre F√§higkeiten zu verbessern.
    - **Exklusive Vorschauen**: Erhalten Sie fr√ºhzeitigen Zugang zu neuen Produktank√ºndigungen und exklusiven Einblicken.
    - **Spezialrabatte**: Genie√üen Sie exklusive Rabatte auf unsere neuesten Produkte.
    - **Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil.

    üëâ Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!

.. _3.1.13_c:

3.1.13 GAME - NichtNicht
===========================

Einf√ºhrung
-------------------

In diesem Projekt werden wir ein interessantes Spielger√§t erstellen, das wir "Nicht Nicht" nennen.

W√§hrend des Spiels wird das Punktmatrix zuf√§llig einen Pfeil aktualisieren. Ihre Aufgabe ist es, innerhalb einer begrenzten Zeit die Taste in die entgegengesetzte Richtung des Pfeils zu dr√ºcken. Wenn die Zeit abgelaufen ist oder die Taste in die gleiche Richtung wie der Pfeil gedr√ºckt wird, sind Sie aus dem Spiel.

Dieses Spiel kann wirklich Ihr umgekehrtes Denken schulen. Sollen wir es mal versuchen?

Ben√∂tigte Komponenten
------------------------------

F√ºr dieses Projekt ben√∂tigen wir die folgenden Komponenten.

.. image:: ../img/list_GAME_14_NotNot.png
    :align: center

Es ist definitiv praktisch, ein ganzes Kit zu kaufen. Hier ist der Link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Name
        - ARTIKEL IN DIESEM KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Sie k√∂nnen diese auch einzeln √ºber die untenstehenden Links kaufen.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - KOMPONENTEN BESCHREIBUNG
        - KAUF LINK

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_dot_matrix`
        - |link_led_matrix_buy|
    *   - :ref:`cpn_button`
        - |link_button_buy|

Schaltplan
------------------------

============ ======== ======== ====
T-Board Name physical wiringPi BCM
GPIO22       Pin 15   3        22
GPIO23       Pin 16   4        23
SPIMOSI      Pin 19   12       MOSI
SPICE0       pin 24   10       CE0
SPISCLK      Pin 23   14       SCLK
============ ======== ======== ====

.. image:: ../img/Schematic_notnot.png
   :align: center

Experimentelle Verfahren
---------------------------------

**Schritt 1**: Schalten Sie die Schaltung.

.. image:: ../img/3.1.14game_notnot.png

**Schritt 2**: Aktivieren Sie das SPI, bevor Sie das Experiment starten. Weitere Details finden Sie unter :ref:`spi_configuration`.

**Schritt 3**: Navigieren Sie zum Ordner des Codes.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/c/3.1.13/

**Schritt 4**: Kompilieren Sie den Code.

.. raw:: html

   <run></run>

.. code-block:: 

    make

**Schritt 5**: F√ºhren Sie die ausf√ºhrbare Datei aus.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./3.1.13_GAME_NotNot

Nachdem das Programm gestartet ist, wird auf dem Punktmatrix zuf√§llig ein linker oder rechter Pfeil angezeigt. Ihre Aufgabe ist es, die Taste in die entgegengesetzte Richtung des Pfeils zu dr√ºcken. Dann erscheint ein "‚àö" auf dem Punktmatrix. Wenn Sie die Taste in die gleiche Richtung wie der Pfeil dr√ºcken, sind Sie aus dem Spiel und das Punktmatrix zeigt ein "x" an. Sie k√∂nnen auch 2 neue Tasten hinzuf√ºgen oder sie durch Joystick-Tasten f√ºr oben, unten, links und rechts - 4 Richtungen ersetzen, um die Schwierigkeit des Spiels zu erh√∂hen.

.. note::

    Wenn es nach dem Start nicht funktioniert oder eine Fehlermeldung erscheint: \"wiringPi.h: Datei oder Verzeichnis nicht gefunden\", beachten Sie bitte :ref:`install_wiringpi`.

**Code-Erkl√§rung**

**Code-Erkl√§rung**

Dieses C-Programm ist darauf ausgelegt, auf einem Raspberry Pi unter Verwendung der WiringPi-Bibliothek ausgef√ºhrt zu werden. Es kommuniziert mit einem 8x8-LED-Matrix-Display, das √ºber den MAX7219-Treiberchip gesteuert wird, und verwendet zwei Tasten zur Benutzerinteraktion. Das Programm zeigt zuf√§llig einen Pfeil nach links oder rechts auf der LED-Matrix an, und der Benutzer muss die entsprechende Taste dr√ºcken. Anschlie√üend wird ein H√§kchen f√ºr eine richtige Antwort oder ein Kreuz f√ºr eine falsche angezeigt.

#. Header-Dateien:

   * ``wiringPi.h``: Bietet Funktionen zur GPIO-Steuerung mit der WiringPi-Bibliothek.
   * ``wiringPiSPI.h``: Bietet Funktionen f√ºr die SPI-Kommunikation.
   * ``stdio.h``: Standard-Ein-/Ausgabefunktionen (``printf`` usw.).
   * ``stdlib.h``: Standardbibliotheksfunktionen (``rand``, ``srand``, ``exit``).
   * ``time.h``: Funktionen zur Bearbeitung von Datum und Uhrzeit (``time``, ``NULL``).

#. Typdefinitionen:

   * ``#define uchar unsigned char``: Definiert ``uchar`` als Alias f√ºr ``unsigned char``.
   * ``#define uint unsigned int``: Definiert ``uint`` als Alias f√ºr ``unsigned int``.

#. Konstanten und Makros:

   * ``SPI_CHANNEL``: SPI-Kanal f√ºr die Kommunikation (0 oder 1).
   * ``SPI_SPEED``: SPI-Kommunikationsgeschwindigkeit auf 1 MHz gesetzt.
   * ``AButtonPin``: WiringPi-Pin-Nummer f√ºr Taste A (GPIO 22).
   * ``BButtonPin``: WiringPi-Pin-Nummer f√ºr Taste B (GPIO 23).

#. Globale Variablen:

   * ``int stage = 0;``: Verfolgt die aktuelle Phase des Spiels (Anzeige des Pfeils oder Ergebnis).

#. Daten-Arrays:

   * ``uchar arrow[2][8]``: Enth√§lt zwei 8-Byte-Muster, die einen rechten und linken Pfeil f√ºr die LED-Matrix darstellen.

     * ``arrow[0]``: Muster f√ºr den rechten Pfeil.
     * ``arrow[1]``: Muster f√ºr den linken Pfeil.

   * ``uchar check[2][8]``: Enth√§lt zwei 8-Byte-Muster f√ºr die Symbole ‚ÄûRichtig‚Äú (H√§kchen) und ‚ÄûFalsch‚Äú (Kreuz).

     * ``check[0]``: Muster f√ºr das H√§kchen-Symbol.
     * ``check[1]``: Muster f√ºr das Kreuz-Symbol.

#. Funktion ``void Delay_xms(uint x)``:

   * Wrapper-Funktion f√ºr ``delay(x)``, bereitgestellt von WiringPi.
   * Verz√∂gert die Programmausf√ºhrung um ``x`` Millisekunden.

#. Funktion ``void Write_Max7219_byte(uchar DATA)``:

   * Sendet ein einzelnes Byte (``DATA``) an den MAX7219 √ºber SPI.
   * Verwendet ``wiringPiSPIDataRW`` zur Durchf√ºhrung der SPI-Daten√ºbertragung.
   * ``DATA``: Das zu sendende Datenbyte.

#. Funktion ``void Write_Max7219(uchar address1, uchar dat1)``:

   * Sendet einen Befehl und Daten an den MAX7219.
   * Kombiniert ``address1`` (Registeradresse) und ``dat1`` (Daten) in einen Puffer und sendet sie √ºber SPI.
   * ``address1``: Adresse des MAX7219-Registers.
   * ``dat1``: Daten zum Schreiben in das Register.

#. Funktion ``void Init_MAX7219()``:

   * Initialisiert den MAX7219-Display-Treiber mit den erforderlichen Konfigurationen.
   * Konfiguriert Decode-Modus, Intensit√§t, Scan-Limit, Shutdown-Modus und Display-Test.
   * L√∂scht vorherige Daten auf dem Display.

#. Funktion ``void Init_WiringPi()``:

   * Initialisiert die WiringPi-Bibliothek und die SPI-Schnittstelle.
   * Konfiguriert die Tasten-Pins als Eing√§nge mit Pull-up-Widerst√§nden.
   * √úberpr√ºft, ob die Initialisierung erfolgreich war und beendet das Programm bei einem Fehler.

#. Funktion ``int get_index()``:

   * Generiert einen zuf√§lligen Index (0 oder 1), um zwischen dem linken und rechten Pfeil zu w√§hlen.
   * R√ºckgabe: ``0`` oder ``1``.

#. Funktion ``int get_key(uint num)``:

   * Wartet darauf, dass der Benutzer eine Taste dr√ºckt, und bestimmt, ob die Eingabe mit dem angezeigten Pfeil √ºbereinstimmt.
   * Parameter:

     * ``num``: Der Index des angezeigten Pfeils (0 f√ºr rechts, 1 f√ºr links).

   * R√ºckgabe:

     * ``1`` bei korrekter Benutzereingabe.
     * ``0`` bei falscher Benutzereingabe.

   * Funktionsweise:

     * Tritt in eine Endlosschleife ein und √ºberpr√ºft den Zustand der Tasten.
     * Verwendet ``digitalRead``, um Tastendr√ºcke zu erkennen (aktiv LOW).
     * Vergleicht die gedr√ºckte Taste mit der erwarteten Eingabe basierend auf ``num``.

#. Funktion ``void display(uint index)``:

   * Zeigt entweder einen Pfeil oder ein Ergebnissymbol auf der LED-Matrix an, basierend auf der ``stage``.
   * Parameter:

     * ``index``: Index zur Auswahl des Musters aus den Arrays ``arrow`` oder ``check``.

   * Funktionsweise:

     * Wenn ``stage == 0``, wird ein Pfeilmuster angezeigt.
     * Wenn ``stage == 1``, wird ein H√§kchen- oder Kreuzsymbol angezeigt.

#. Hauptfunktion:

   * **Initialisierung:**

     * Initialisiert den Zufallszahlengenerator mit ``srand((unsigned)time(NULL))``.
     * Ruft ``Init_WiringPi()`` auf, um GPIO und SPI einzurichten.
     * Ruft ``Init_MAX7219()`` auf, um das LED-Matrix-Display zu initialisieren.
     * F√ºhrt eine kurze Verz√∂gerung mit ``Delay_xms(50)`` ein.
   
   * **Spielschleife (``while (1)``):**

     * **Stufe 0 (Pfeil anzeigen):**

       * Ruft ``get_index()`` auf, um zuf√§llig eine Pfeilrichtung auszuw√§hlen.
       * Ruft ``display(direction)`` auf, um den Pfeil auf der LED-Matrix anzuzeigen.
       * Setzt ``stage = 1``, um zur n√§chsten Stufe zu wechseln.

     * **Stufe 1 (Benutzereingabe abwarten und Ergebnis anzeigen):**

       * Ruft ``get_key(direction)`` auf, um die Benutzereingabe abzuwarten und die Richtigkeit zu bestimmen.
       * Ruft ``display(key)`` auf, um das Ergebnissymbol (H√§kchen oder Kreuz) anzuzeigen.
       * Wartet 1 Sekunde mit ``Delay_xms(1000)``, damit der Benutzer das Ergebnis sehen kann.
       * Setzt ``stage = 0``, um die Schleife neu zu starten.


**Programmfluss-Zusammenfassung:**

1. **Einrichtung:**

   * Initialisiert WiringPi und SPI.
   * Konfiguriert die Tasten-Pins und die MAX7219-Einstellungen.
   * Initialisiert den Zufallszahlengenerator.

2. **Pfeil anzeigen:**

   * W√§hlt zuf√§llig eine Pfeilrichtung (links oder rechts).
   * Zeigt den entsprechenden Pfeil auf der LED-Matrix an.

3. **Benutzerinteraktion:**

   * Wartet darauf, dass der Benutzer entweder Taste A oder Taste B dr√ºckt.
   * Bestimmt, ob die gedr√ºckte Taste der Pfeilrichtung entspricht.

4. **Ergebnis anzeigen:**

   * Zeigt ein H√§kchen an, wenn die Benutzereingabe korrekt ist.
   * Zeigt ein Kreuz an, wenn die Benutzereingabe falsch ist.
   * Wartet 1 Sekunde vor der n√§chsten Runde.

5. **Wiederholen:**

   * Kehrt zur Anzeige eines neuen Pfeils zur√ºck und setzt das Spiel fort.