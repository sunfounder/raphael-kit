 

.. note::

    Bonjour et bienvenue dans la Communaut√© Facebook des passionn√©s de Raspberry Pi, Arduino et ESP32 de SunFounder ! Plongez plus profond√©ment dans l'univers des Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre et partager** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits et aux aper√ßus.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos produits les plus r√©cents.
    - **Promotions festives et cadeaux** : Participez √† des cadeaux et des promotions de vacances.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez [|link_sf_facebook|] et rejoignez-nous aujourd'hui !

.. _3.1.3_c:

3.1.3 Alarme de Recul
==============================

Introduction
-------------

Dans ce projet, nous allons utiliser un √©cran LCD, un buzzer et des capteurs ultrasoniques 
pour cr√©er un syst√®me d'assistance au recul. Nous pouvons le placer sur un v√©hicule t√©l√©command√© 
pour simuler le processus r√©el de recul d'une voiture dans un garage.

Composants N√©cessaires
------------------------------

Pour ce projet, nous avons besoin des composants suivants. 

.. image:: ../img/list_Reversing_Alarm.png
    :align: center

Il est tr√®s pratique d'acheter un kit complet, voici le lien : 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom
        - ARTICLES DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez √©galement les acheter s√©par√©ment via les liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DES COMPOSANTS
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_buzzer`
        - \-
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|
    *   - :ref:`cpn_ultrasonic_sensor`
        - |link_ultrasonic_buy|
    *   - :ref:`cpn_i2c_lcd`
        - |link_i2clcd1602_buy|

Sch√©ma de C√¢blage
--------------------

Le capteur ultrasonique d√©tecte la distance entre lui-m√™me et l'obstacle qui sera affich√©e sur 
l'√©cran LCD sous forme de code. En m√™me temps, le capteur ultrasonique fait √©mettre au buzzer 
un son d'avertissement de fr√©quence diff√©rente en fonction de la valeur de distance.

=============== ======== =========  ===
Nom de la Carte physique  wiringPi  BCM
GPIO23          Pin 16    4         23
GPIO24          Pin 18    5         24
GPIO17          Pin 11    0         17
SDA1            Pin 3              
SCL1            Pin 5              
=============== ======== =========  ===

.. image:: ../img/Schematic_three_one3.png
   :align: center

Proc√©dures Exp√©rimentales
-----------------------------

**√âtape 1 :** Construire le circuit.

.. image:: ../img/image242.png

**√âtape 2 :** Changer de r√©pertoire.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/c/3.1.3/

**√âtape 3 :** Compiler.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.3_ReversingAlarm.c -lwiringPi

**√âtape 4 :** Ex√©cuter.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

Lorsque le code s'ex√©cute, le module de capteur ultrasonique d√©tecte la distance 
jusqu'√† l'obstacle et affiche les informations sur la distance sur le LCD1602; 
de plus, le buzzer √©met un son d'avertissement dont la fr√©quence change en fonction de la distance.

.. note::

    * Si une erreur ``wiringPi.h : No such file or directory`` appara√Æt, veuillez consulter :ref:`install_wiringpi`.
    * Si une erreur ``Unable to open I2C device : No such file or directory`` appara√Æt, vous devez consulter :ref:`i2c_config` pour activer l'I2C et v√©rifier le c√¢blage.
    * Si le code et le c√¢blage sont corrects, mais que l'√©cran LCD ne s'affiche toujours pas, vous pouvez tourner le potentiom√®tre √† l'arri√®re pour augmenter le contraste.


**Code**

.. note::
    Les codes suivants sont incomplets. Si vous souhaitez v√©rifier les codes complets,
    il est sugg√©r√© d'utiliser la commande nano 3.1.1_ReversingAlarm.c.

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #include <sys/time.h>
    #include <wiringPi.h>
    #include <wiringPiI2C.h>
    #include <string.h>

    #define Trig    4
    #define Echo    5
    #define Buzzer  0

    int LCDAddr = 0x27;
    int BLEN = 1;
    int fd;

    //here is the function of LCD
    void write_word(int data){...}

    void send_command(int comm){...}

    void send_data(int data){...}

    void lcdInit(){...}

    void clear(){...}

    void write(int x, int y, char data[]){...}

    //here is the function of Ultrasonic
    void ultraInit(void){...}

    float disMeasure(void){...}

    //here is the main function
    int main(void)
    {
        float dis;
        char result[10];
        if(wiringPiSetup() == -1){ 
            printf("setup wiringPi failed !");
            return 1;
        }

        pinMode(Buzzer,OUTPUT);
        fd = wiringPiI2CSetup(LCDAddr);
        lcdInit();
        ultraInit();

        clear();
        write(0, 0, "Ultrasonic Starting"); 
        write(1, 1, "By Sunfounder");   

        while(1){
            dis = disMeasure();
            printf("%.2f cm \n",dis);
            digitalWrite(Buzzer,LOW);
            if (dis > 400){
                clear();
                write(0, 0, "Error");
                write(3, 1, "Out of range");    
                delay(500);
            }
            else
            {
                clear();
                write(0, 0, "Distance is");
                sprintf(result,"%.2f cm",dis);
                write(5, 1, result);

                if(dis>=50)
                {delay(500);}
                else if(dis<50 & dis>20) {
                    for(int i=0;i<2;i++){
                    digitalWrite(Buzzer,HIGH);
                    delay(50);
                    digitalWrite(Buzzer,LOW);
                    delay(200);
                    }
                }
                else if(dis<=20){
                    for(int i=0;i<5;i++){
                    digitalWrite(Buzzer,HIGH);
                    delay(50);
                    digitalWrite(Buzzer,LOW);
                    delay(50);
                    }
                }
            }   
        }

        return 0;
    }

**Explication du Code**

.. code-block:: c

    pinMode(Buzzer,OUTPUT);
    fd = wiringPiI2CSetup(LCDAddr);
    lcdInit();
    ultraInit();

Dans ce programme, nous appliquons des composants pr√©c√©dents de mani√®re synth√©tique. Ici,
nous utilisons des buzzers, un √©cran LCD et un capteur ultrasonique. Nous les initialisons
de la m√™me mani√®re que pr√©c√©demment.

.. code-block:: c

    dis = disMeasure();
     printf("%.2f cm \n",dis);
    digitalWrite(Buzzer,LOW);
    if (dis > 400){
         write(0, 0, "Error");
         write(3, 1, "Out of range");    
    }
    else
    {
        write(0, 0, "Distance is");
        sprintf(result,"%.2f cm",dis);
        write(5, 1, result);
	}

Ici, nous obtenons la valeur du capteur ultrasonique et calculons la distance.

Si la valeur de la distance est sup√©rieure √† la plage √† d√©tecter, un message 
d'erreur est affich√© sur l'√©cran LCD. Et si la valeur de la distance est dans la plage, 
les r√©sultats correspondants seront affich√©s.

.. code-block:: c

    sprintf(result,"%.2f cm",dis);

√âtant donn√© que le mode de sortie de l'√©cran LCD ne supporte que le type caract√®re, 
et que la variable dis stocke la valeur de type float, nous devons utiliser sprintf(). 
Cette fonction convertit la valeur de type float en caract√®re et la stocke dans la variable 
cha√Æne result[]. %.2f signifie conserver deux d√©cimales.

.. code-block:: c

    if(dis>=50)
    {delay(500);}
    else if(dis<50 & dis>20) {
        for(int i=0;i<2;i++){
        digitalWrite(Buzzer,HIGH);
        delay(50);
        digitalWrite(Buzzer,LOW);
        delay(200);
        }
    }
    else if(dis<=20){
        for(int i=0;i<5;i++){
        digitalWrite(Buzzer,HIGH);
        delay(50);
        digitalWrite(Buzzer,LOW);
        delay(50);
        }
    }

Cette condition de jugement est utilis√©e pour contr√¥ler le son du buzzer. 
En fonction de la diff√©rence de distance, il peut √™tre divis√© en trois cas, 
dans lesquels il y aura diff√©rentes fr√©quences sonores. Comme la valeur totale 
du d√©lai est de 500, tous les cas peuvent fournir un intervalle de 500 ms pour 
le capteur ultrasonique.

Photo du Ph√©nom√®ne
-----------------------

.. image:: ../img/image243.jpeg
   :align: center
