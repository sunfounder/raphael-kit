 
.. _2.1.7_c:

2.1.7 Potentiomètre
=========================

Introduction
---------------

La fonction ADC peut être utilisée pour convertir des signaux analogiques en signaux numériques, et dans cette expérience, l'ADC0834 est utilisé pour obtenir cette fonction impliquant l'ADC. Ici, nous mettons en œuvre ce processus en utilisant un potentiomètre. Le potentiomètre change la quantité physique -- la tension, qui est convertie par la fonction ADC.

Composants Nécessaires
------------------------------

Dans ce projet, nous avons besoin des composants suivants. 

.. image:: ../img/list_2.1.4_potentiometer.png

Il est définitivement pratique d'acheter un kit complet, voici le lien : 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Name	
        - ITEMS IN THIS KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Vous pouvez également les acheter séparément aux liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DES COMPOSANTS
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_potentiometer`
        - |link_potentiometer_buy|
    *   - :ref:`cpn_adc0834`
        - \-

Schéma de Câblage
-----------------

.. image:: ../img/image311.png


.. image:: ../img/image312.png


Procédures Expérimentales
-----------------------

**Étape 1:** Construisez le circuit.

.. image:: ../img/image180.png


.. note::
    Veuillez placer la puce en vous référant à la position correspondante
    décrite dans l'image. Notez que les rainures sur la puce doivent être à gauche lorsqu'elle est placée.

**Étape 2:** Ouvrez le fichier de code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/c/2.1.7/

**Étape 3:** Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.1.7_Potentiometer.c -lwiringPi

**Étape 4:** Exécutez le programme.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Après l'exécution du code, tournez le bouton du potentiomètre, l'intensité de la LED changera en conséquence.

.. note::

    Si cela ne fonctionne pas après l'exécution, ou s'il y a un message d'erreur : \"wiringPi.h: No such file or directory\", veuillez vous référer à :ref:`install_wiringpi`.
**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #include <softPwm.h>

    typedef unsigned char uchar;
    typedef unsigned int uint;

    #define     ADC_CS    0
    #define     ADC_CLK   1
    #define     ADC_DIO   2
    #define     LedPin    3

    uchar get_ADC_Result(uint channel)
    {
        uchar i;
        uchar dat1=0, dat2=0;
        int sel = channel > 1 & 1;
        int odd = channel & 1;

        pinMode(ADC_DIO, OUTPUT);
        digitalWrite(ADC_CS, 0);
        // Start bit
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Single End mode
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // ODD
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,odd);  delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Select
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,sel);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);

        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);

        for(i=0;i<8;i++)
        {
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);

            pinMode(ADC_DIO, INPUT);
            dat1=dat1<<1 | digitalRead(ADC_DIO);
        }

        for(i=0;i<8;i++)
        {
            dat2 = dat2 | ((uchar)(digitalRead(ADC_DIO))<<i);
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);
        }

        digitalWrite(ADC_CS,1);
        pinMode(ADC_DIO, OUTPUT);
        return(dat1==dat2) ? dat1 : 0;
    }

    int main(void)
    {
        uchar analogVal;
        if(wiringPiSetup() == -1){ //when initialize wiring failed,print messageto screen
            printf("setup wiringPi failed !");
            return 1;
        }
        softPwmCreate(LedPin,  0, 100);
        pinMode(ADC_CS,  OUTPUT);
        pinMode(ADC_CLK, OUTPUT);

        while(1){
            analogVal = get_ADC_Result(0);
            printf("Current analogVal : %d\n", analogVal);
            softPwmWrite(LedPin, analogVal);
            delay(100);
        }
        return 0;
    }

**Explication du Code**

.. code-block:: c

    #define     ADC_CS    0
    #define     ADC_CLK   1
    #define     ADC_DIO   2
    #define     LedPin    3

Définir CS, CLK, DIO de l'ADC0834, et les connecter respectivement à GPIO0, GPIO1 et GPIO2. Ensuite, attacher la LED à GPIO3.

.. code-block:: c

    uchar get_ADC_Result(uint channel)
    {
        uchar i;
        uchar dat1=0, dat2=0;
        int sel = channel > 1 & 1;
        int odd = channel & 1;

        pinMode(ADC_DIO, OUTPUT);
        digitalWrite(ADC_CS, 0);
        // Start bit
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Single End mode
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // ODD
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,odd);  delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Select
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,sel);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);

        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        for(i=0;i<8;i++)
        {
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);

            pinMode(ADC_DIO, INPUT);
            dat1=dat1<<1 | digitalRead(ADC_DIO);
        }

        for(i=0;i<8;i++)
        {
            dat2 = dat2 | ((uchar)(digitalRead(ADC_DIO))<<i);
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);
        }

        digitalWrite(ADC_CS,1);
        pinMode(ADC_DIO, OUTPUT);
        return(dat1==dat2) ? dat1 : 0;
    }

Il existe une fonction de l'ADC0834 pour effectuer la conversion analogique-numérique. 
Le flux de travail spécifique est le suivant :

.. code-block:: c

    digitalWrite(ADC_CS, 0);

Mettre CS à un niveau bas et commencer à activer la conversion AD.

.. code-block:: c

    // Start bit
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
    digitalWrite(ADC_CLK,1);    delayMicroseconds(2);

Lorsque la transition de l'horloge d'un niveau bas à un niveau haut se produit pour la première fois, 
régler DIO sur 1 comme bit de démarrage. Dans les trois étapes suivantes, 
il y a 3 mots d'affectation.

.. code-block:: c

    //Single End mode
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
    digitalWrite(ADC_CLK,1);    delayMicroseconds(2);

Dès que la transition de l'horloge d'un niveau bas à un niveau haut se produit pour la deuxième fois, régler DIO sur 1 et choisir le mode SGL.

.. code-block:: c

    // ODD
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,odd);  delayMicroseconds(2);
    digitalWrite(ADC_CLK,1);    delayMicroseconds(2);

Une fois que cela se produit pour la troisième fois, la valeur de DIO est contrôlée par la variable **odd**.

.. code-block:: c

    //Select
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,sel);    delayMicroseconds(2);
    digitalWrite(ADC_CLK,1);

Lorsque l'impulsion de CLK passe du niveau bas au niveau haut pour la quatrième fois, la valeur de DIO est contrôlée par la variable **sel**.

Dans le cas où channel=0, sel=0, odd=0, les formules opérationnelles concernant **sel** et **odd** sont les suivantes :

.. code-block:: c

    int sel = channel > 1 & 1;
    int odd = channel & 1;

Lorsque la condition channel=1, sel=0, odd=1 est remplie, veuillez vous référer au tableau de logique de contrôle d'adresse suivant. Ici, CH1 est choisi, et le bit de démarrage est décalé dans l'emplacement de démarrage du registre de multiplexage et la conversion commence.

.. image:: ../img/image313.png


.. code-block:: c

    digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,1);    delayMicroseconds(2);

Ici, définir DIO sur 1 deux fois, veuillez l'ignorer.

.. code-block:: c

    for(i=0;i<8;i++)
        {
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);

            pinMode(ADC_DIO, INPUT);
            dat1=dat1<<1 | digitalRead(ADC_DIO);
        }

Dans la première instruction for(), dès que la cinquième impulsion de CLK passe du niveau haut au niveau bas, régler DIO en mode entrée. Ensuite, la conversion commence et la valeur convertie est stockée dans la variable dat1. Après huit périodes d'horloge, la conversion est terminée.

.. code-block:: c

    for(i=0;i<8;i++)
        {
            dat2 = dat2 | ((uchar)(digitalRead(ADC_DIO))<<i);
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);
        }

Dans la deuxième instruction for(), les valeurs converties sont sorties via DO après huit autres périodes d'horloge et stockées dans la variable dat2.

.. code-block:: c

    digitalWrite(ADC_CS,1);
    pinMode(ADC_DIO, OUTPUT);
    return(dat1==dat2) ? dat1 : 0;

return(dat1==dat2) ? dat1 : 0 est utilisé pour comparer la valeur obtenue lors de la conversion et la valeur de sortie. Si elles sont égales, la valeur convertie dat1 est sortie ; sinon, 0 est sorti. Ici, le flux de travail de l'ADC0834 est terminé.

.. code-block:: c

    softPwmCreate(LedPin,  0, 100);

La fonction est d'utiliser un logiciel pour créer une broche PWM, LedPin, puis la largeur d'impulsion initiale est définie sur 0, et la période du PWM est de 100 x 100us.

.. code-block:: c

    while(1){
            analogVal = get_ADC_Result(0);
            printf("Current analogVal : %d\n", analogVal);
            softPwmWrite(LedPin, analogVal);
            delay(100);
        }

Dans le programme principal, lire la valeur du canal 0 qui a été connecté à un potentiomètre. Et stocker la valeur dans la variable analogVal puis l'écrire dans LedPin. Vous pouvez maintenant voir la luminosité de la LED changer en fonction de la valeur du potentiomètre.

Image du Phénomène
------------------

.. image:: ../img/image181.jpeg
