.. _1.2.2_c:

1.2.2 受動ブザー
==========================

はじめに
------------

このプロジェクトでは、受動ブザーで音楽を再生する方法を学びます。

必要な部品
------------------------------

このプロジェクトでは、以下の部品が必要です。

.. image:: ../img/list_1.2.2.png

全体のキットを購入するのは非常に便利です。以下がリンクです：

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - 名前
        - このキットのアイテム
        - リンク
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

以下のリンクから個別に購入することもできます。

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - コンポーネントの紹介
        - 購入リンク

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_buzzer`
        - |link_passive_buzzer_buy|
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|

回路図
-----------------

この実験では、受動ブザー、PNPトランジスタ、トランジスタのベースとGPIO間の1kの抵抗が使用されます。トランジスタを保護するためのものです。

GPIO17に異なる周波数が与えられると、受動ブザーは異なる音を出します。この方法で、ブザーは音楽を再生します。

.. image:: ../img/image333.png

実験手順
-----------------------

**ステップ1**: 回路を組み立てます。（背面が緑の基板の受動ブザーを使用します。）

.. image:: ../img/image106.png

**ステップ2**: ディレクトリを変更します。

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/c/1.2.2/

**ステップ3**: コードをコンパイルします。

.. raw:: html

   <run></run>

.. code-block::

    gcc 1.2.2_PassiveBuzzer.c -lwiringPi

**ステップ4**: 実行します。

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

コードが実行されると、ブザーは音楽の一部を再生します。

.. note::

    実行後に動作しないか、エラーメッセージ「wiringPi.h: No such file or directory」が表示される場合、 :ref:`install_wiringpi` を参照してください。

**コード**

.. code-block:: c

    #include <wiringPi.h>
    #include <softTone.h>
    #include <stdio.h>

    #define BuzPin    0

    #define  CL1  131
    #define  CL2  147
    #define  CL3  165
    #define  CL4  175
    #define  CL5  196
    #define  CL6  221
    #define  CL7  248

    #define  CM1  262
    #define  CM2  294
    #define  CM3  330
    #define  CM4  350
    #define  CM5  393
    #define  CM6  441
    #define  CM7  495

    #define  CH1  525
    #define  CH2  589
    #define  CH3  661
    #define  CH4  700
    #define  CH5  786
    #define  CH6  882
    #define  CH7  990

    int song_1[] = {CM3,CM5,CM6,CM3,CM2,CM3,CM5,CM6,CH1,CM6,CM5,CM1,CM3,CM2,
                    CM2,CM3,CM5,CM2,CM3,CM3,CL6,CL6,CL6,CM1,CM2,CM3,CM2,CL7,
                    CL6,CM1,CL5};

    int beat_1[] = {1,1,3,1,1,3,1,1,1,1,1,1,1,1,3,1,1,3,1,1,1,1,1,1,1,2,1,1,
                    1,1,1,1,1,1,3};


    int song_2[] = {CM1,CM1,CM1,CL5,CM3,CM3,CM3,CM1,CM1,CM3,CM5,CM5,CM4,CM3,CM2,
                    CM2,CM3,CM4,CM4,CM3,CM2,CM3,CM1,CM1,CM3,CM2,CL5,CL7,CM2,CM1
                    };

    int beat_2[] = {1,1,1,3,1,1,1,3,1,1,1,1,1,1,3,1,1,1,2,1,1,1,3,1,1,1,3,3,2,3};

    int main(void)
    {
        int i, j;
        if(wiringPiSetup() == -1){ //when initialize wiring failed,print message to screen
            printf("setup wiringPi failed !");
            return 1;
        }

        if(softToneCreate(BuzPin) == -1){
            printf("setup softTone failed !");
            return 1;
        }

        while(1){
            printf("music is being played...\n");

            for(i=0;i<sizeof(song_1)/4;i++){
                softToneWrite(BuzPin, song_1[i]);   
                delay(beat_1[i] * 500);
            }

            for(i=0;i<sizeof(song_2)/4;i++){
                softToneWrite(BuzPin, song_2[i]);   
                delay(beat_2[i] * 500);
            }   
        }

        return 0;
    }

**コード説明**

.. code-block:: c

    #define  CL1  131
    #define  CL2  147
    #define  CL3  165
    #define  CL4  175
    #define  CL5  196
    #define  CL6  221
    #define  CL7  248

    #define  CM1  262
    #define  CM2  294


各音符の周波数は以下の通りです。CLは低音を、CMは中音を、CHは高音を示し、1-7はそれぞれの音符C、D、E、F、G、A、Bに対応します。

.. code-block:: c

    int song_1[] = {CM3,CM5,CM6,CM3,CM2,CM3,CM5,CM6,CH1,CM6,CM5,CM1,CM3,CM2,
                    CM2,CM3,CM5,CM2,CM3,CM3,CL6,CL6,CL6,CM1,CM2,CM3,CM2,CL7,
                    CL6,CM1,CL5};
    int beat_1[] = {1,1,3,1,1,3,1,1,1,1,1,1,1,1,3,1,1,3,1,1,1,1,1,1,1,2,1,1,
                    1,1,1,1,1,1,3};

``song_1[]`` 配列は、曲の楽譜を格納し、 ``beat_1[]`` は曲の各音符の拍子を示します（各拍子は0.5秒です）。

.. code-block:: c

    if(softToneCreate(BuzPin) == -1){
            printf("setup softTone failed !");
            return 1;
    }

これはソフトウェアで制御される音のピンを作成します。任意のGPIOピンを使用でき、ピン番号は使用した ``wiringPiSetup()`` 関数のものになります。戻り値が0なら成功です。それ以外の場合、何が間違っているかを調べるためにグローバルなerrnovariableをチェックする必要があります。

.. code-block:: c

    for(i=0;i<sizeof(song_1)/4;i++){
        softToneWrite(BuzPin, song_1[i]);   
        delay(beat_1[i] * 500);
    }

for文を使用してsong_1を再生します。

判定条件の **i<sizeof(song_1)/4** では、「4で割る」は ``song_1[]`` が整数型のデータタイプの配列であり、各要素が4バイトを占有しているため使用されます。

``song_1`` の要素数（音楽ノートの数）は、 ``sizeof(song_1)`` を4で割ることで得られます。

各音符を拍子 * 500msで再生するために、関数 ``delay(beat_1[i] * 500)`` が呼び出されます。

``softToneWrite(BuzPin, song_1[i])`` のプロトタイプは：

.. code-block:: c

    void softToneWrite (int pin, int freq);

これは指定されたピンの音の周波数値を更新します。周波数を0に設定するまで音は再生を停止しません。

現象の画像
------------------

.. image:: ../img/image107.jpeg