.. nota::

    Ciao, benvenuto nella community di SunFounder Raspberry Pi & Arduino & ESP32 su Facebook! Approfondisci le tue conoscenze su Raspberry Pi, Arduino ed ESP32 insieme ad altri appassionati.

    **Perch√© unirti a noi?**

    - **Supporto Esperto**: Risolvi i problemi post-vendita e le sfide tecniche con l'aiuto della nostra comunit√† e del nostro team.
    - **Impara e Condividi**: Scambia suggerimenti e tutorial per migliorare le tue competenze.
    - **Anteprime Esclusive**: Ottieni accesso anticipato agli annunci di nuovi prodotti e alle anteprime.
    - **Sconti Speciali**: Approfitta di sconti esclusivi sui nostri prodotti pi√π recenti.
    - **Promozioni Festive e Giveaway**: Partecipa a concorsi e promozioni festive.

    üëâ Pronto a esplorare e creare con noi? Clicca su [|link_sf_facebook|] e unisciti subito!

.. _1.2.2_c:

1.2.2 Buzzer Passivo
===========================

Introduzione
-------------

In questo progetto, impareremo come far suonare un buzzer passivo per riprodurre musica.

Componenti Necessari
-------------------------------

In questo progetto, abbiamo bisogno dei seguenti componenti. 

.. image:: ../img/list_1.2.2.png

√à sicuramente conveniente acquistare un kit completo, ecco il link: 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nome	
        - COMPONENTI NEL KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Puoi anche acquistarli separatamente dai link seguenti.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUZIONE AI COMPONENTI
        - LINK PER L'ACQUISTO

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_buzzer`
        - |link_passive_buzzer_buy|
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|

Schema Elettrico
---------------------

In questo esperimento, utilizziamo un buzzer passivo, un transistor PNP e una 
resistenza da 1kŒ© tra la base del transistor e il GPIO per proteggere il transistor.

Quando a GPIO17 vengono assegnate frequenze diverse, il buzzer passivo emetter√† suoni 
differenti; in questo modo, il buzzer riproduce musica.

.. image:: ../img/image333.png


Procedure Sperimentali
---------------------------

**Passo 1:** Costruisci il circuito. (Il buzzer passivo ha un circuito stampato verde sul retro.)

.. image:: ../img/image106.png

**Passo 2:** Cambia la directory.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/c/1.2.2/

**Passo 3:** Compila.

.. raw:: html

   <run></run>

.. code-block::

    gcc 1.2.2_PassiveBuzzer.c -lwiringPi

**Passo 4:** Esegui.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Dopo l'esecuzione del codice, il buzzer riprodurr√† un brano musicale.

.. note::

    Se il codice non funziona dopo l'esecuzione o appare l'errore: \"wiringPi.h: No such file or directory\", fai riferimento a :ref:`install_wiringpi`.

**Codice**

.. code-block:: c

    #include <wiringPi.h>
    #include <softTone.h>
    #include <stdio.h>

    #define BuzPin    0

    #define  CL1  131
    #define  CL2  147
    #define  CL3  165
    #define  CL4  175
    #define  CL5  196
    #define  CL6  221
    #define  CL7  248

    #define  CM1  262
    #define  CM2  294
    #define  CM3  330
    #define  CM4  350
    #define  CM5  393
    #define  CM6  441
    #define  CM7  495

    #define  CH1  525
    #define  CH2  589
    #define  CH3  661
    #define  CH4  700
    #define  CH5  786
    #define  CH6  882
    #define  CH7  990

    int song_1[] = {CM3,CM5,CM6,CM3,CM2,CM3,CM5,CM6,CH1,CM6,CM5,CM1,CM3,CM2,
                    CM2,CM3,CM5,CM2,CM3,CM3,CL6,CL6,CL6,CM1,CM2,CM3,CM2,CL7,
                    CL6,CM1,CL5};

    int beat_1[] = {1,1,3,1,1,3,1,1,1,1,1,1,1,1,3,1,1,3,1,1,1,1,1,1,1,2,1,1,
                    1,1,1,1,1,1,3};


    int song_2[] = {CM1,CM1,CM1,CL5,CM3,CM3,CM3,CM1,CM1,CM3,CM5,CM5,CM4,CM3,CM2,
                    CM2,CM3,CM4,CM4,CM3,CM2,CM3,CM1,CM1,CM3,CM2,CL5,CL7,CM2,CM1
                    };

    int beat_2[] = {1,1,1,3,1,1,1,3,1,1,1,1,1,1,3,1,1,1,2,1,1,1,3,1,1,1,3,3,2,3};

    int main(void)
    {
        int i, j;
        if(wiringPiSetup() == -1){ //quando l'inizializzazione di wiring fallisce, stampa messaggio a schermo
            printf("setup wiringPi failed !");
            return 1;
        }

        if(softToneCreate(BuzPin) == -1){
            printf("setup softTone failed !");
            return 1;
        }

        while(1){
            printf("music is being played...\n");

            for(i=0;i<sizeof(song_1)/4;i++){
                softToneWrite(BuzPin, song_1[i]);   
                delay(beat_1[i] * 500);
            }

            for(i=0;i<sizeof(song_2)/4;i++){
                softToneWrite(BuzPin, song_2[i]);   
                delay(beat_2[i] * 500);
            }   
        }

        return 0;
    }

**Spiegazione del Codice**

.. code-block:: c

    #define  CL1  131
    #define  CL2  147
    #define  CL3  165
    #define  CL4  175
    #define  CL5  196
    #define  CL6  221
    #define  CL7  248

    #define  CM1  262
    #define  CM2  294


Queste sono le frequenze di ciascuna nota, come indicato. CL si riferisce alla nota bassa, 
CM alla nota media, CH alla nota alta, 1-7 corrispondono alle note C, D, E, F, G, A, B.

.. code-block:: c

    int song_1[] = {CM3,CM5,CM6,CM3,CM2,CM3,CM5,CM6,CH1,CM6,CM5,CM1,CM3,CM2,
                    CM2,CM3,CM5,CM2,CM3,CM3,CL6,CL6,CL6,CM1,CM2,CM3,CM2,CL7,
                    CL6,CM1,CL5};
    int beat_1[] = {1,1,3,1,1,3,1,1,1,1,1,1,1,1,3,1,1,3,1,1,1,1,1,1,1,2,1,1,
                    1,1,1,1,1,1,3};

L'array ``song_1[]`` memorizza uno spartito musicale di una canzone, mentre ``beat_1[]`` 
si riferisce al ritmo di ciascuna nota nella canzone (0,5 secondi per ogni battito).

.. code-block:: c

    if(softToneCreate(BuzPin) == -1){
            printf("setup softTone failed !");
            return 1;
    }


Questa funzione crea un tono controllato via software sul pin. Puoi utilizzare qualsiasi pin GPIO, 
e la numerazione del pin sar√† quella della funzione ``wiringPiSetup()`` utilizzata. Il valore restituito √® 0 per il successo. In caso contrario, √® necessario controllare la variabile globale ``errno`` per vedere cosa √® andato storto.

.. code-block:: c

    for(i=0;i<sizeof(song_1)/4;i++){
        softToneWrite(BuzPin, song_1[i]);   
        delay(beat_1[i] * 500);
    }

Utilizzare un ciclo ``for`` per riprodurre ``song_1``.

Nella condizione di giudizio, **i<sizeof(song_1)/4**, "dividere per 4" viene 
utilizzato perch√© l'array ``song_1[]`` √® un array di tipo intero e ogni elemento 
occupa quattro byte.

Il numero di elementi in ``song_1`` (il numero di note musicali) viene ottenuto 
dividendo ``sizeof(song_1)`` per 4.

Per fare in modo che ogni nota suoni per ``beat * 500ms``, viene chiamata la funzione 
``delay(beat_1[i] * 500)``.

Il prototipo della funzione ``softToneWrite(BuzPin, song_1[i])`` √®:

.. code-block:: c

    void softToneWrite (int pin, int freq);

Questa funzione aggiorna la frequenza del tono sul pin specificato. Il tono 
continua a suonare fino a quando non si imposta la frequenza su 0.

Immagine del Fenomeno
---------------------------

.. image:: ../img/image107.jpeg
