.. note::

    Bonjour, bienvenue dans la communautÃ© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur FacebookÂ ! Approfondissez vos connaissances sur RaspberryÂ Pi, Arduino et ESP32 avec dâ€™autres passionnÃ©s.

    **Pourquoi rejoindreÂ ?**

    - **Support dâ€™experts**Â : RÃ©solvez les problÃ¨mes aprÃ¨sâ€‘vente et les dÃ©fis techniques avec lâ€™aide de notre communautÃ© et de notre Ã©quipe.
    - **Apprendre et partager**Â : Ã‰changez des astuces et des tutoriels pour amÃ©liorer vos compÃ©tences.
    - **AperÃ§us exclusifs**Â : AccÃ©dez en avantâ€‘premiÃ¨re aux annonces de nouveaux produits et aux aperÃ§us.
    - **RÃ©ductions spÃ©ciales**Â : Profitez de rÃ©ductions exclusives sur nos tout derniers produits.
    - **Promotions et cadeaux festifs**Â : Participez Ã  des concours et promotions spÃ©ciales pendant les fÃªtes.

    ðŸ‘‰ PrÃªt Ã  explorer et Ã  crÃ©er avec nousÂ ? Cliquez sur [|link_sf_facebook|] et rejoignezâ€‘nous dÃ¨s aujourdâ€™huiÂ !

.. _2.1.9_c_mcp3008:

2.1.9 Joystick (MCP3008)
==========================

.. note::

   .. image:: ../img/mcp3008_and_adc0834.jpg
      :width: 25%
      :align: left
    

   Selon la version de votre kit, identifiez si vous disposez dâ€™un **ADC0834** ou dâ€™un **MCP3008** et suivez la section correspondante.

Introduction
--------------

Dans ce projet, nous allons apprendre comment fonctionne un joystick.  
Nous manipulons le joystick et affichons les rÃ©sultats Ã  lâ€™Ã©cran.

Composants requis
-------------------------------

Dans ce projet, nous avons besoin des composants suivants. 

.. image:: ../img/image317-copy.png

Il est bien sÃ»r pratique dâ€™acheter un kit complet, voici le lienÂ : 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom	
        - Ã‰LÃ‰MENTS DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez Ã©galement les acheter sÃ©parÃ©ment via les liens ciâ€‘dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DU COMPOSANT
        - LIEN Dâ€™ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_joystick`
        - \-
    *   - :ref:`cpn_mcp3008`
        - \-

SchÃ©ma de cÃ¢blage
-----------------

Lors de la lecture des donnÃ©es du joystick, il existe des diffÃ©rences entre les axesÂ :  
les donnÃ©es des axes X et Y sont analogiques et nÃ©cessitent lâ€™utilisation du MCP3008 pour convertir la valeur analogique en valeur numÃ©rique.  
Les donnÃ©es de lâ€™axe Z sont numÃ©riques, elles peuvent donc Ãªtre lues directement via le GPIO ou encore via lâ€™ADC.

.. .. image:: ../img/image319.png

    *   - Nom Tâ€‘Board
        - physique
        - WiringPi
        - BCM

    *   - SPICE0
        - pin24
        - 10
        - 8
    *   - SPIMOSI
        - pin19
        - 12
        - 10
    *   - SPIMISO
        - pin21
        - 13
        - 9
    *   - SPISCLK
        - pin23
        - 14
        - 11
    *   - GPIO22
        - pin15
        - 3
        - 22

.. image:: ../img/schematic_2.1.9_joystick_mcp3008.png


ProcÃ©dures expÃ©rimentales
-------------------------

**Ã‰tapeÂ 1Â :** Construisez le circuit.

.. image:: ../img/july24_2.1.9_joystick_mcp3008.png

**Ã‰tapeÂ 2Â :** AccÃ©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/c/2.1.9-2/

**Ã‰tapeÂ 3Â :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.1.9_Joystick.c -o joystick -lwiringPi

**Ã‰tapeÂ 4Â :** ExÃ©cutez lâ€™exÃ©cutable.

.. raw:: html

   <run></run>

.. code-block::

    ./joystick

AprÃ¨s exÃ©cution du code, tournez le joystick, puis les valeurs correspondantes de  
x, y et Btn sont affichÃ©es Ã  lâ€™Ã©cran.

.. note::

    Si cela ne fonctionne pas aprÃ¨s exÃ©cution ou sâ€™il y a un message dâ€™erreurÂ : Â«Â wiringPi.hÂ : No such file or directoryÂ Â», veuillez vous rÃ©fÃ©rer Ã Â :ref:`install_wiringpi`.

**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <wiringPiSPI.h>
    #include <stdio.h>

    #define SPI_CHANNEL 0
    #define SPI_SPEED   1000000  // 1 MHz
    #define BtnPin      3        // WiringPi 3 = BCM GPIO22

    // Lecture du canal MCP3008 (0â€“7)
    int read_ADC(int channel) {
        if (channel < 0 || channel > 7) return -1;

        unsigned char buffer[3];
        buffer[0] = 1;                            // Bit de dÃ©marrage
        buffer[1] = (8 + channel) << 4;           // Configuration du canal
        buffer[2] = 0;

        wiringPiSPIDataRW(SPI_CHANNEL, buffer, 3);

        int result = ((buffer[1] & 0x03) << 8) | buffer[2];
        return result;
    }

    int main(void) {
        if (wiringPiSetup() == -1) {
            printf("Ã‰chec de lâ€™initialisation de WiringPiÂ !\n");
            return 1;
        }

        if (wiringPiSPISetup(SPI_CHANNEL, SPI_SPEED) == -1) {
            printf("Ã‰chec de la configuration SPIÂ !\n");
            return 1;
        }

        pinMode(BtnPin, INPUT);
        pullUpDnControl(BtnPin, PUD_UP);

        while (1) {
            int x_val = read_ADC(0);     // VRX sur CH0
            int y_val = read_ADC(1);     // VRY sur CH1
            int btn_val = digitalRead(BtnPin);  // Bouton SW

            printf("x = %d, y = %d, btn = %d\n", x_val, y_val, btn_val);
            delay(100);
        }

        return 0;
    }

**Explication du code**

#. Cette section initialise les bibliothÃ¨ques nÃ©cessaires pour la communication GPIO et SPI.

   .. code-block:: c

       #include <wiringPi.h>
       #include <wiringPiSPI.h>
       #include <stdio.h>

       #define SPI_CHANNEL 0
       #define SPI_SPEED   1000000  // 1 MHz
       #define BtnPin      3        // WiringPi 3 = BCM GPIO22

#. DÃ©finit une fonction `read_ADC()` pour lire des donnÃ©es analogiques depuis le MCP3008.  
   Elle communique via SPI pour demander les donnÃ©es dâ€™un canal donnÃ© (0â€“7), puis analyse la rÃ©ponse pour obtenir un rÃ©sultat ADC 10Â bits.

   .. code-block:: c

       int read_ADC(int channel) {
           if (channel < 0 || channel > 7) return -1;

           unsigned char buffer[3];
           buffer[0] = 1;
           buffer[1] = (8 + channel) << 4;
           buffer[2] = 0;

           wiringPiSPIDataRW(SPI_CHANNEL, buffer, 3);

           int result = ((buffer[1] & 0x03) << 8) | buffer[2];
           return result;
       }

#. La fonction principale initialise les interfaces WiringPi et SPI, configure la broche du bouton du joystick et lit en continu les valeurs du joystick pour les afficher dans la console.

   .. code-block:: c

       int main(void) {
           if (wiringPiSetup() == -1) {
               printf("Ã‰chec de lâ€™initialisation de WiringPiÂ !\n");
               return 1;
           }

           if (wiringPiSPISetup(SPI_CHANNEL, SPI_SPEED) == -1) {
               printf("Ã‰chec de la configuration SPIÂ !\n");
               return 1;
           }

           pinMode(BtnPin, INPUT);
           pullUpDnControl(BtnPin, PUD_UP);

           while (1) {
               int x_val = read_ADC(0);     // VRX sur CH0
               int y_val = read_ADC(1);     // VRY sur CH1
               int btn_val = digitalRead(BtnPin);  // Bouton SW

               printf("x = %d, y = %d, btn = %d\n", x_val, y_val, btn_val);
               delay(100);
           }

           return 0;
       }

.. Phenomenon Picture
.. ------------------

.. .. image:: ../img/image194.jpeg
