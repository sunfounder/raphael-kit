.. _1.1.4_js:

1.1.4 7セグメントディスプレイ
=============================

はじめに
--------------

0から9、AからFまでの数字を7セグメントディスプレイに表示する方法を試してみましょう。

必要な部品
------------------------------

このプロジェクトには、以下の部品が必要です。

.. image:: img/list_7_segment.png

全体のキットを購入するのは確かに便利です。こちらがリンクです：

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - 名前
        - このキットのアイテム
        - リンク
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

以下のリンクからそれぞれの部品も購入することができます。

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - コンポーネントの紹介
        - 購入リンク

    *   - :ref:`GPIO拡張ボード`
        - |link_gpio_board_buy|
    *   - :ref:`ブレッドボード`
        - |link_breadboard_buy|
    *   - :ref:`ジャンパーワイヤー`
        - |link_wires_buy|
    *   - :ref:`抵抗器`
        - |link_resistor_buy|
    *   - :ref:`7セグメントディスプレイ`
        - |link_7segment_buy|
    *   - :ref:`74HC595`
        - |link_74hc595_buy|

回路図
---------------------

74HC595のST_CPピンをRaspberry Pi GPIO18に、SH_CPをGPIO27に、DS
をGPIO17に接続し、並列出力ポートをLEDセグメント
ディスプレイの8セグメントに接続します。SH_CP（シフトレジスタのクロック入力）が立ち上がりエッジの時にDSピンにデータを入力し、ST_CP（メモリのクロック入力）が立ち上がりエッジの時にメモリレジスタに入力します。その後、Raspberry Pi GPIOを介してSH_CPとST_CPの状態を制御して、シリアルデータ入力を並列データ出力に変換することで、Raspberry Pi GPIOを節約してディスプレイを駆動できます。

.. image:: img/schematic_7_segment.png

実験手順
--------------------------

**ステップ1:** 回路を作成する。

.. image:: img/image73.png

**ステップ2:** コードのフォルダに移動します。

.. raw:: html

    <run></run>

.. code-block::

    cd ~/raphael-kit/nodejs/

**ステップ3:** コードを実行する。

.. raw:: html

    <run></run>

.. code-block::

    sudo node 7-segment_display.js

コードを実行すると、7セグメントディスプレイが0-9、A-Fを表示します。

**コード**

.. code-block:: js

    const Gpio = require('pigpio').Gpio;

    const segCode = [0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71];

    const SDI = new Gpio(17, { mode: Gpio.OUTPUT });
    const RCLK = new Gpio(18, { mode: Gpio.OUTPUT });
    const SRCLK = new Gpio(27, { mode: Gpio.OUTPUT });

    function hc595_shift(dat) {
        for (let j = 0; j < 8; j++) {
            let code = 0x80 & (dat << j);
            if (code != 0) {
                code = 1;
            }
            SDI.digitalWrite(code);
            SRCLK.trigger(1,1);
        }
        RCLK.trigger(1,1);
    }

    let index = -1;
    setInterval(() => {
        index = (index+1)%16;
        hc595_shift(segCode[index]);
    }, 1000);


**コード説明**

.. code-block:: js

    const segCode = [0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71];

0からFまでの16進数（共通カソード）セグメントコード配列を定義します。

.. code-block:: js

    const SDI = new Gpio(17, { mode: Gpio.OUTPUT });
    const RCLK = new Gpio(18, { mode: Gpio.OUTPUT });
    const SRCLK = new Gpio(27, { mode: Gpio.OUTPUT });

ピン17、18、27を出力モードとして初期化し、それぞれ ``SDI``、 ``RCLK``、 ``SRCLK`` にコピーします。

.. code-block:: js

    function hc595_shift(dat) {
        for (let j = 0; j < 8; j++) {
            let code = 0x80 & (dat << j);
            if (code != 0) {
                code = 1;
            }
            SDI.digitalWrite(code);
            SRCLK.trigger(1,1);
        }
        RCLK.trigger(1,1);
    }

``segCode`` 配列内のフィールドを数字に変換してデジタルチューブに表示する ``hc595_shift`` 関数を実装します。

.. code-block:: js

    let code = 0x80 & (dat << j);
    if (code != 0) {
        code = 1;
    }
    SDI.digitalWrite(code); 

ビットごとにdatデータをSDI(DS)に割り当てます。
ここでは、dat=0x3f(0011 1111)と仮定して、j=2のとき、0x3fは2ビット左(<<)にシフトします。
1111 1100 (0x3f << 2) & 1000 0000 (0x80) = 1000 0000、これは真です。
この時、1がSDIに書き込まれます。

.. code-block:: js

    SRCLK.trigger(1,1);

立ち上がりエッジのパルスを生成し、DSデータをシフトレジスタに移動します。

``trigger(pulseLen, level)``
    * pulseLen - パルスの長さ（マイクロ秒）(1 - 100)
    * level - 0または1

GPIOにトリガーパルスを送信します。
GPIOはpulseLenマイクロ秒の間、レベルに設定され、その後レベルではない状態にリセットされます。

.. code-block:: js

    RCLK.trigger(1,1);

立ち上がりエッジのパルスを生成し、シフトレジスタからストレージレジスタにデータを移動します。

.. code-block:: js

    let index = -1;
    setInterval(() => {
        index = (index+1)%16;
        hc595_shift(segCode[index]);
    }, 1000);

最終的に、関数 ``hc595_shift()`` を使用して ``segCode`` のフィールドを変換し、デジタルチューブを通して表示します。

現象の画像
---------------------------

.. image:: img/image74.jpeg





