 

.. _2.1.8_js:

2.1.8 Clavier
===============

Introduction
---------------

Un clavier est une matrice rectangulaire de boutons. Dans ce projet, nous allons l'utiliser pour 
saisir des caractères.

Composants nécessaires
--------------------------

Dans ce projet, nous avons besoin des composants suivants. 

.. image:: ../img/list_2.1.5_keypad.png

Il est certainement pratique d'acheter un kit complet, voici le lien : 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom
        - ARTICLES DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez également les acheter séparément via les liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DES COMPOSANTS
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_keypad`
        - \-

Schéma de câblage
--------------------

.. image:: ../img/image315.png


.. image:: ../img/image316.png


Procédures expérimentales
----------------------------

**Étape 1 :** Construire le circuit.

.. image:: ../img/image186.png

**Étape 2 :** Ouvrir le fichier de code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/nodejs/

**Étape 3 :** Exécuter.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo node keypad.js

Après l'exécution du code, les valeurs des boutons pressés sur le clavier (valeur du bouton) 
seront affichées à l'écran.

**Code**

.. code-block:: js

    const Gpio = require('pigpio').Gpio; 

    var rowsPins = [18,23,24,25];
    var colsPins = [10,6,27,17];
    var keys = ["1","2","3","A",
            "4","5","6","B",
            "7","8","9","C",
            "*","0","#","D"];      

    for(let i=0;i<rowsPins.length;i++){
        rowsPins[i] = new Gpio(rowsPins[i],{mode: Gpio.OUTPUT})
    }
    for(let i=0;i<colsPins.length;i++){
        colsPins[i] = new Gpio(colsPins[i],{
            mode: Gpio.INPUT,
            pullUpDown: Gpio.PUD_DOWN,
            edge: Gpio.RISING_EDGE
        })
    }

    var last_key_pressed = 0;

    var col=-1;
    for(let i=0;i<colsPins.length;i++){
        colsPins[i].on('interrupt',()=>{
            col=i;
            pressed_keys=keys[row*colsPins.length+col];
            if(last_key_pressed!=pressed_keys){
                console.log(`${pressed_keys}`);
            }
            last_key_pressed = pressed_keys;
        });
    }

    var row=-1;
    setInterval(() => {
        row=(row+1)%rowsPins.length;
        for(let i=0;i<rowsPins.length;i++){
            rowsPins[i].digitalWrite(0);
        }
        rowsPins[row].digitalWrite(1);
    }, 10);


**Explication du Code**

.. code-block:: js

    const Gpio = require('pigpio').Gpio; 

    var rowsPins = [18,23,24,25];
    var colsPins = [10,6,27,17];
    var keys = ["1","2","3","A",
            "4","5","6","B",
            "7","8","9","C",
            "*","0","#","D"];      

    for(let i=0;i<rowsPins.length;i++){
        rowsPins[i] = new Gpio(rowsPins[i],{mode: Gpio.OUTPUT})
    }
    for(let i=0;i<colsPins.length;i++){
        colsPins[i] = new Gpio(colsPins[i],{
            mode: Gpio.INPUT,
            pullUpDown: Gpio.PUD_DOWN,
            edge: Gpio.RISING_EDGE
        })
    }



Dans le style du clavier, déclarez deux ensembles de broches et une matrice.

Quatre des broches sont les lignes du clavier, définissez ces broches en mode OUTPUT ;
Les quatre autres broches sont les colonnes du clavier, définissez ces broches en mode INPUT et configurez l'interruption sur front montant pour elles.

Le principe selon lequel le contrôleur principal peut obtenir la valeur de la touche est le suivant :
Les quatre broches de ligne fournissent à tour de rôle un niveau haut, si un bouton est pressé,
La broche de colonne correspondante obtiendra le niveau haut émis par la broche de ligne, ce qui déclenchera l'interruption sur front montant.

Par exemple, si j'appuie sur le bouton **3**, lorsque les 2e, 3e et 4e broches de ligne émettent le niveau haut, il n'y a pas d'effet ;
Lorsque la broche de ligne en première position émet le niveau haut, la troisième broche de colonne sera en mesure d'obtenir le niveau haut et de déclencher l'interruption sur front montant. À ce moment, les 1ère, 2e et 4e broches de colonne ne déclenchent aucun événement.

Ensuite, selon la 1ère broche de ligne qui émet le niveau haut et la 3e broche de colonne qui obtient le niveau haut, le contrôleur principal pourra savoir que la position du bouton pressé est (1,3), c'est-à-dire le bouton **3**.

.. image:: ../img/image187.png


.. code-block:: js

    var row=-1;
    setInterval(() => {
        row=(row+1)%rowsPins.length;
        for(let i=0;i<rowsPins.length;i++){
            rowsPins[i].digitalWrite(0);
        }
        rowsPins[row].digitalWrite(1);
    }, 10);

Les quatre broches de ligne sont périodiquement alimentées en haut niveau, et la variable ``row`` est utilisée pour localiser la broche de ligne actuellement active.

.. code-block:: js

    var col=-1;
    for(let i=0;i<colsPins.length;i++){
        colsPins[i].on('interrupt',()=>{
            col=i;
            // pressed_keys=keys[row*colsPins.length+col];
            // if(last_key_pressed!=pressed_keys){
            //     console.log(`${pressed_keys}`);
            // }
            // last_key_pressed = pressed_keys;
        });
    }

Configurez des fonctions d'interruption pour les quatre broches de colonne,
et la variable ``col`` est utilisée pour localiser les broches de colonne qui déclenchent l'événement d'interruption sur front montant.


.. code-block:: js

    pressed_keys=keys[row*colsPins.length+col];
    if(last_key_pressed!=pressed_keys){
        console.log(`${pressed_keys}`);
    }
    last_key_pressed = pressed_keys;

Il y a aussi un morceau de code dans la fonction d'interruption pour obtenir la valeur de la touche spécifique à partir de la matrice ``keys`` selon ``row`` et ``col``.
Et chaque fois que vous obtenez une nouvelle valeur de touche, imprimez la valeur.

Image du phénomène
------------------

.. image:: ../img/image188.jpeg


