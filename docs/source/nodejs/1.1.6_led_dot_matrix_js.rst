.. _1.1.6_js:

1.1.6 Module de Matrice LED
==================================

Introduction
--------------------

Dans ce projet, vous allez découvrir le module de matrice LED. Ce module utilise le pilote MAX7219 pour contrôler la matrice LED 8 x 8.

Composants requis
------------------------------

Dans ce projet, nous avons besoin des composants suivants. 

.. image:: ../img/list_dot.png

Il est vraiment pratique d'acheter un kit complet, voici le lien : 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom	
        - ARTICLES DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez également les acheter séparément via les liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DES COMPOSANTS
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_dot_matrix`
        - |link_led_matrix_buy|

Schéma de connexion
-----------------------

============ ======== ======== ====
Nom T-Board  Physique wiringPi BCM
SPIMOSI      Pin 19   12       MOSI
SPICE0       pin 24   10       CE0
SPISCLK      Pin 23   14       SCLK
============ ======== ======== ====

.. image:: ../img/schematic_dot.png

Procédures expérimentales
----------------------------

**Étape 1 :** Montez le circuit. 

.. image:: ../img/1.1.6fritzing.png

.. note::

    Activez le SPI avant de commencer l'expérience, consultez :ref:`SPI Configuration` pour plus de détails.


**Étape 2 :** Accédez au dossier du code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/nodejs/

**Étape 3 :** Installez les dépendances.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo npm install spi-device

**Étape 4 :** Exécutez le code.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo node max7219_led_matrix.js 

Après avoir exécuté le code, la matrice de points LED affiche de 0 à 9 et de A à Z en séquence.


**Code**

.. code-block:: js

    const Gpio = require('pigpio').Gpio;
    const spi = require('spi-device');

    class MAX7219_LED_MATRIX {
        constructor(bus, device) {
            this.bus = bus;
            this.device = device;
        }
        delay(ms) {
            return new Promise((resolve, reject) => {setTimeout(resolve, ms)});
        }

        async write(addr, data) {
            return new Promise((resolve, reject)=>{
                const max7219 = spi.open(this.bus, this.device, (err)=>{
                    if (err) reject(err);
            
                    const message = [{
                        sendBuffer: Buffer.from([addr, data]),
                        receiveBuffer: Buffer.alloc(2),
                        byteLength: 2,
                        speedHz: 20000
                    }];
        
                    max7219.transfer(message, (err, message)=>{
                        if (err) reject(err);
                        else resolve();
                    })
                })
            })
        }
        async init() {
            await this.write(0x09, 0x00);
            await this.write(0x0a, 0x03);
            await this.write(0x0b, 0x07);
            await this.write(0x0c, 0x01);
            await this.write(0x0f, 0x00);
        }
    }

    const DISP=[
        [0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x3C],//0
        [0x08,0x18,0x28,0x08,0x08,0x08,0x08,0x08],//1
        [0x7E,0x2,0x2,0x7E,0x40,0x40,0x40,0x7E],//2
        [0x3E,0x2,0x2,0x3E,0x2,0x2,0x3E,0x0],//3
        [0x8,0x18,0x28,0x48,0xFE,0x8,0x8,0x8],//4
        [0x3C,0x20,0x20,0x3C,0x4,0x4,0x3C,0x0],//5
        [0x3C,0x20,0x20,0x3C,0x24,0x24,0x3C,0x0],//6
        [0x3E,0x22,0x4,0x8,0x8,0x8,0x8,0x8],//7
        [0x0,0x3E,0x22,0x22,0x3E,0x22,0x22,0x3E],//8
        [0x3E,0x22,0x22,0x3E,0x2,0x2,0x2,0x3E],//9
        [0x8,0x14,0x22,0x3E,0x22,0x22,0x22,0x22],//A
        [0x3C,0x22,0x22,0x3E,0x22,0x22,0x3C,0x0],//B
        [0x3C,0x40,0x40,0x40,0x40,0x40,0x3C,0x0],//C
        [0x7C,0x42,0x42,0x42,0x42,0x42,0x7C,0x0],//D
        [0x7C,0x40,0x40,0x7C,0x40,0x40,0x40,0x7C],//E
        [0x7C,0x40,0x40,0x7C,0x40,0x40,0x40,0x40],//F
        [0x3C,0x40,0x40,0x40,0x40,0x44,0x44,0x3C],//G
        [0x44,0x44,0x44,0x7C,0x44,0x44,0x44,0x44],//H
        [0x7C,0x10,0x10,0x10,0x10,0x10,0x10,0x7C],//I
        [0x3C,0x8,0x8,0x8,0x8,0x8,0x48,0x30],//J
        [0x0,0x24,0x28,0x30,0x20,0x30,0x28,0x24],//K
        [0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x7C],//L
        [0x81,0xC3,0xA5,0x99,0x81,0x81,0x81,0x81],//M
        [0x0,0x42,0x62,0x52,0x4A,0x46,0x42,0x0],//N
        [0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x3C],//O
        [0x3C,0x22,0x22,0x22,0x3C,0x20,0x20,0x20],//P
        [0x1C,0x22,0x22,0x22,0x22,0x26,0x22,0x1D],//Q
        [0x3C,0x22,0x22,0x22,0x3C,0x24,0x22,0x21],//R
        [0x0,0x1E,0x20,0x20,0x3E,0x2,0x2,0x3C],//S
        [0x0,0x3E,0x8,0x8,0x8,0x8,0x8,0x8],//T
        [0x42,0x42,0x42,0x42,0x42,0x42,0x22,0x1C],//U
        [0x42,0x42,0x42,0x42,0x42,0x42,0x24,0x18],//V
        [0x0,0x49,0x49,0x49,0x49,0x2A,0x1C,0x0],//W
        [0x0,0x41,0x22,0x14,0x8,0x14,0x22,0x41],//X
        [0x41,0x22,0x14,0x8,0x8,0x8,0x8,0x8],//Y
        [0x0,0x7F,0x2,0x4,0x8,0x10,0x20,0x7F],//Z
    ];

    lm = new MAX7219_LED_MATRIX(0, 0);

    async function main(){
        lm.init();
        while(1){
            for(let j=0;j<36;j++){
                for(let i=1;i<9;i++){
                    lm.write(i, DISP[j][i-1]);
                }
                await lm.delay(1000);
            }
        }
    }
    main(); 

**Explication du code**

.. code-block:: js

    const spi = require('spi-device');

Importez les modules nécessaires pour la communication SPI.

.. note::
    Lorsque vous avez plusieurs appareils nécessitant une communication SPI, connectez simplement les broches CS à des broches différentes.

.. code-block:: js

    class MAX7219_LED_MATRIX {
        constructor(bus, device) {
            this.bus = bus;
            this.device = device;
        }
        delay(ms) {
            return new Promise((resolve, reject) => {setTimeout(resolve, ms)});
        }

        async write(addr, data) {
            return new Promise((resolve, reject)=>{
                const max7219 = spi.open(this.bus, this.device, (err)=>{
                    if (err) reject(err);

                    const message = [{
                        sendBuffer: Buffer.from([addr, data]),
                        receiveBuffer: Buffer.alloc(2),
                        byteLength: 2,
                        speedHz: 20000
                    }];

                    max7219.transfer(message, (err, message)=>{
                        if (err) reject(err);
                        else resolve();
                    })
                })
            })
        }

Implémentez une classe ``MAX7219_LED_MATRIX``, et la fonction ``write()`` encapsulée permet d'allumer la matrice.

.. note::
    Le mot-clé ``async`` est utilisé pour modifier la fonction et est généralement associé au mot-clé ``await``. L'instruction modifiée par le mot-clé ``await`` doit attendre la fin de l'exécution du code précédent avant de s'exécuter, ce qui permet d'obtenir un effet de blocage synchrone.

* `Fonction asynchrone <https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Statements/async_function>`_

.. code-block:: js

    lm = new MAX7219_LED_MATRIX(0, 0);

Instanciez un objet ``lm`` de la classe ``MAX7219_LED_MATRIX``, afin que nous puissions appeler la fonction ``write()`` encapsulée à l'intérieur.

.. code-block:: js

    while(1){
        for(let j=0;j<36;j++){
            for(let i=0;i<8;i++){
                lm.write(i, DISP[j][i]);
            }
            await lm.delay(1000);
        }
    }

La fonction ``write(row,date)`` permet d'afficher des caractères spécifiques sur la matrice de points LED.
Le premier paramètre sélectionne la ligne de la matrice LED (8 lignes au total).
Le deuxième paramètre entre un nombre binaire de 8 bits pour contrôler les 8 LEDs de la ligne (0 signifie éteint, 1 signifie allumé).


La variable ``j`` est utilisée pour sélectionner le glyphe, qui est ``DISP[]``. Il y a un total de 35 glyphes, de 0 à 9 et de A à Z.

Par exemple, lorsque j=1, la matrice LED doit afficher l'image **1**.

La variable ``i`` est utilisée pour écrire les 8 données dans le glyphe ``DISP[]`` dans la matrice LED à tour de rôle. Après la boucle, une image 8x8 peut être générée.

Par exemple, lorsque j=1, i=1, les données de ``DISP[1][1]`` seront écrites ici, c'est-à-dire ``0x18``,
Cela amènera la deuxième rangée de la matrice LED à afficher l'image ``00011000``.

.. image:: ../img/led_not.png
    :width: 400

Image du phénomène
-----------------------

.. image:: ../img/1.1.6led_dot_matrix.JPG