.. note::

    Ciao, benvenuto nella Community di SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts su Facebook! Approfondisci il mondo di Raspberry Pi, Arduino ed ESP32 insieme ad altri appassionati.

    **Perch√© unirti a noi?**

    - **Supporto Tecnico Esperto**: Risolvi i problemi post-vendita e le sfide tecniche con l'aiuto della nostra comunit√† e del nostro team.
    - **Impara e Condividi**: Scambia consigli e tutorial per migliorare le tue competenze.
    - **Anteprime Esclusive**: Ottieni accesso anticipato agli annunci di nuovi prodotti e alle anteprime.
    - **Sconti Speciali**: Approfitta di sconti esclusivi sui nostri prodotti pi√π recenti.
    - **Promozioni Festive e Giveaway**: Partecipa a giveaway e promozioni durante le festivit√†.

    üëâ Sei pronto a esplorare e creare con noi? Clicca [|link_sf_facebook|] e unisciti oggi stesso!

.. _2.1.7_py_pi5:

2.1.7 Potenziometro
=======================

Introduzione
------------

La funzione ADC pu√≤ essere utilizzata per convertire segnali analogici in 
segnali digitali. In questo esperimento, utilizziamo l'ADC0834 per ottenere 
questa funzione. In questo caso, implementiamo il processo utilizzando un 
potenziometro. Il potenziometro modifica una grandezza fisica -- la tensione -- 
che viene convertita dalla funzione ADC.

Componenti Necessari
------------------------------

Per questo progetto, avremo bisogno dei seguenti componenti.

.. image:: ../python_pi5/img/2.1.7_potentiometer_list.png

√à decisamente conveniente acquistare un kit completo, ecco il link: 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nome	
        - COMPONENTI NEL KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Puoi anche acquistarli separatamente dai link sottostanti.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUZIONE AI COMPONENTI
        - LINK D'ACQUISTO

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_potentiometer`
        - |link_potentiometer_buy|
    *   - :ref:`cpn_adc0834`
        - \-

Schema Elettrico
---------------------

.. image:: ../python_pi5/img/2.1.7_potentiometer_second_1.png


.. image:: ../python_pi5/img/2.1.7_potentiometer_second_2.png

Procedure Sperimentali
---------------------------

**Passo 1:** Costruisci il circuito.

.. image:: ../python_pi5/img/2.1.7_Potentiometer_circuit.png


.. note::
    Posiziona il chip facendo riferimento alla posizione corrispondente 
    raffigurata nell'immagine. Nota che le scanalature sul chip devono 
    essere a sinistra quando viene posizionato.

**Passo 2:** Apri il file del codice.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python-pi5

**Passo 3:** Esegui.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.1.7_Potentiometer_zero.py

Dopo l'esecuzione del codice, ruota la manopola del potenziometro e l'intensit√† del LED cambier√† di conseguenza.

.. warning::

    Se viene visualizzato l'errore ``RuntimeError: Cannot determine SOC peripheral base address``, fare riferimento a :ref:`faq_soc`. 

**Code**

.. note::

    Puoi **Modificare/Resettare/Copiare/Eseguire/Fermare** il codice qui sotto. Ma prima, devi accedere alla directory del codice come ``raphael-kit/python-pi5``. Dopo aver modificato il codice, puoi eseguirlo direttamente per vedere l'effetto.


.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3

   from gpiozero import PWMLED
   import ADC0834
   import time

   # Inizializza un LED PWM sul pin GPIO 22
   led = PWMLED(22)

   # Configura il modulo ADC0834
   ADC0834.setup()

   def MAP(x, in_min, in_max, out_min, out_max):
       """
       Map a value from one range to another.
       :param x: The value to be mapped.
       :param in_min: The lower bound of the value's current range.
       :param in_max: The upper bound of the value's current range.
       :param out_min: The lower bound of the value's target range.
       :param out_max: The upper bound of the value's target range.
       :return: The mapped value.
       """
       return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min

   try:
       while True:
           # Ottieni la lettura corrente dal modulo ADC0834
           res = ADC0834.getResult()
           print('res = %d' % res)

           # Mappa il valore ADC a un intervallo adatto per impostare la luminosit√† del LED
           R_val = MAP(res, 0, 255, 0, 100)

           # Imposta la luminosit√† del LED
           led.value = float(R_val / 100)

           # Attendi 0.2 secondi prima di leggere di nuovo
           time.sleep(0.2)

   # Uscita controllata quando viene premuto 'Ctrl+C'
   except KeyboardInterrupt: 
       led.value = 0  # Spegni il LED


**Spiegazione del Codice**

#. ``gpiozero`` per il controllo del LED PWM, ``ADC0834`` per la conversione analogico-digitale e ``time`` per implementare i ritardi.

   .. code-block:: python

       #!/usr/bin/env python3

       from gpiozero import PWMLED
       import ADC0834
       import time

#. Inizializza un oggetto PWMLED collegato al pin GPIO 22 e configura il convertitore ADC0834.

   .. code-block:: python

       # Inizializza un LED PWM sul pin GPIO 22
       led = PWMLED(22)

       # Configura il modulo ADC0834
       ADC0834.setup()

#. Definisce una funzione chiamata ``MAP`` per convertire un intervallo di valori in un altro, utile per mappare i valori ADC ai livelli di luminosit√† appropriati per il LED.

   .. code-block:: python

       def MAP(x, in_min, in_max, out_min, out_max):
           return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min

#. Leggi continuamente il valore dell'ADC in un ciclo, mappando la lettura dell'ADC (0-255) a un livello di luminosit√† (0-100) per il LED. Regola la luminosit√† del LED in base a questo valore mappato. Implementa un ritardo di 0,2 secondi per una migliore leggibilit√† e stabilit√†.

   .. code-block:: python

       try:
           while True:
               # Ottieni la lettura corrente dal modulo ADC0834
               res = ADC0834.getResult()
               print('res = %d' % res)

               # Mappa il valore ADC a un intervallo adatto per impostare la luminosit√† del LED
               R_val = MAP(res, 0, 255, 0, 100)

               # Imposta la luminosit√† del LED
               led.value = float(R_val / 100)

               # Attendi 0.2 secondi prima di leggere di nuovo
               time.sleep(0.2)

       # Uscita controllata quando viene premuto 'Ctrl+C'
       except KeyboardInterrupt: 
           led.value = 0  # Spegni il LED
