.. note::

    ¡Hola! Bienvenidos a la comunidad de entusiastas de SunFounder Raspberry Pi, Arduino y ESP32 en Facebook. Sumérgete más en Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **¿Por qué unirse?**

    - **Soporte experto**: Resuelve problemas postventa y desafíos técnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprender y compartir**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Avances exclusivos**: Obtén acceso anticipado a anuncios de nuevos productos y adelantos.
    - **Descuentos especiales**: Disfruta de descuentos exclusivos en nuestros productos más recientes.
    - **Promociones festivas y sorteos**: Participa en sorteos y promociones de temporada.

    👉 ¿Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y únete hoy mismo!

.. _2.1.7_py_pi5:

2.1.7 Potenciómetro
======================

Introducción
----------------

La función ADC se puede utilizar para convertir señales analógicas en señales digitales y, 
en este experimento, se utiliza el ADC0834 para obtener la función que implica ADC. Aquí, 
implementamos este proceso utilizando un potenciómetro. El potenciómetro cambia la cantidad 
física: el voltaje, que es convertido por la función ADC.

Componentes necesarios
------------------------------

En este proyecto, necesitamos los siguientes componentes.

.. image:: ../python_pi5/img/2.1.7_potentiometer_list.png

Es definitivamente conveniente comprar un kit completo, aquí está el enlace:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre	
        - ARTÍCULOS EN ESTE KIT
        - ENLACE
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

También puedes comprarlos por separado en los enlaces a continuación.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCIÓN DEL COMPONENTE
        - ENLACE DE COMPRA

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_potentiometer`
        - |link_potentiometer_buy|
    *   - :ref:`cpn_adc0834`
        - \-

Diagrama esquemático
------------------------

.. image:: ../python_pi5/img/2.1.7_potentiometer_second_1.png


.. image:: ../python_pi5/img/2.1.7_potentiometer_second_2.png

Procedimientos experimentales
--------------------------------

**Paso 1:** Construye el circuito.

.. image:: ../python_pi5/img/2.1.7_Potentiometer_circuit.png


.. note::
    Coloca el chip refiriéndote a la posición correspondiente
    mostrada en la imagen. Ten en cuenta que las ranuras del chip deben estar a la 
    izquierda cuando se coloque.

**Paso 2:** Abre el archivo de código

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python-pi5

**Paso 3:** Ejecuta.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.1.7_Potentiometer_zero.py

Después de ejecutar el código, gira la perilla del potenciómetro, la intensidad del LED cambiará en consecuencia.

.. warning::

    Si recibe el mensaje de error ``RuntimeError: Cannot determine SOC peripheral base address``, consulte :ref:`faq_soc`

**Código**

.. note::

    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el código a continuación. Pero antes de eso, debes ir a la ruta del código fuente como ``raphael-kit/python-pi5``. Después de modificar el código, puedes ejecutarlo directamente para ver el efecto.


.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3

   from gpiozero import PWMLED
   import ADC0834
   import time

   # Inicializar un LED PWM en el pin GPIO 22
   led = PWMLED(22)

   # Configurar el módulo ADC0834
   ADC0834.setup()

   def MAP(x, in_min, in_max, out_min, out_max):
       """
       Map a value from one range to another.
       :param x: The value to be mapped.
       :param in_min: The lower bound of the value's current range.
       :param in_max: The upper bound of the value's current range.
       :param out_min: The lower bound of the value's target range.
       :param out_max: The upper bound of the value's target range.
       :return: The mapped value.
       """
       return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min

   try:
       while True:
           # Obtener la lectura actual del módulo ADC0834
           res = ADC0834.getResult()
           print('res = %d' % res)

           # Mapear el valor del ADC a un rango adecuado para ajustar el brillo del LED
           R_val = MAP(res, 0, 255, 0, 100)

           # Ajustar el brillo del LED
           led.value = float(R_val / 100)

           # Esperar 0.2 segundos antes de leer nuevamente
           time.sleep(0.2)

   # Salida elegante cuando se presiona 'Ctrl+C'
   except KeyboardInterrupt: 
       led.value = 0  # Apagar el LED


**Explicación del Código**

#. ``gpiozero`` para el control de LED PWM, ``ADC0834`` para la conversión de analógico a digital y ``time`` para implementar retardos.

   .. code-block:: python

       #!/usr/bin/env python3

       from gpiozero import PWMLED
       import ADC0834
       import time

#. Inicializa un objeto PWMLED conectado al pin GPIO 22 y configura el convertidor ADC0834.

   .. code-block:: python

       # Inicializa un LED PWM en el pin GPIO 22
       led = PWMLED(22)

       # Configura el módulo ADC0834
       ADC0834.setup()

#. Define una función llamada ``MAP`` para convertir un rango de valores a otro, útil para mapear los valores del ADC a niveles de brillo adecuados para el LED.

   .. code-block:: python

       def MAP(x, in_min, in_max, out_min, out_max):
           return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min

#. Lee continuamente el valor del ADC en un bucle, mapeando la lectura del ADC (0-255) a un nivel de brillo (0-100) para el LED. Ajusta el brillo del LED basado en este valor mapeado. Implementa un retraso de 0.2 segundos para una mejor legibilidad y estabilidad.

   .. code-block:: python

       try:
           while True:
               # Obtén la lectura actual del módulo ADC0834
               res = ADC0834.getResult()
               print('res = %d' % res)

               # Mapea el valor del ADC a un rango adecuado para ajustar el brillo del LED
               R_val = MAP(res, 0, 255, 0, 100)

               # Ajusta el brillo del LED
               led.value = float(R_val / 100)

               # Espera 0.2 segundos antes de leer nuevamente
               time.sleep(0.2)

       # Salida elegante cuando se presiona 'Ctrl+C'
       except KeyboardInterrupt: 
           led.value = 0  # Apaga el LED
