 
.. note::

    Bonjour et bienvenue dans la Communaut√© Facebook des passionn√©s de Raspberry Pi, Arduino et ESP32 de SunFounder ! Plongez plus profond√©ment dans l'univers des Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre et partager** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits et aux aper√ßus.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos produits les plus r√©cents.
    - **Promotions festives et cadeaux** : Participez √† des cadeaux et des promotions de vacances.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez [|link_sf_facebook|] et rejoignez-nous aujourd'hui !

.. _2.2.9_py_pi5:

2.2.9 Module MPU6050
=======================

Introduction
-----------------

Le MPU-6050 est le premier et le seul dispositif de suivi de mouvement √† 6 axes au 
monde (gyroscope √† 3 axes et acc√©l√©rom√®tre √† 3 axes) con√ßu pour les smartphones, 
les tablettes et les capteurs portables. Il r√©pond aux exigences de faible puissance, 
de faible co√ªt et de haute performance.

Dans cette exp√©rience, nous utilisons l'I2C pour obtenir les valeurs du capteur 
d'acc√©l√©ration √† trois axes et du gyroscope √† trois axes du MPU6050 et les afficher √† l'√©cran.


Composants n√©cessaires
--------------------------

Dans ce projet, nous avons besoin des composants suivants.

.. image:: ../python_pi5/img/2.2.9_mpu6050_list.png

Il est certainement pratique d'acheter un kit complet, voici le lien :

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom	
        - ARTICLES DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez √©galement les acheter s√©par√©ment via les liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DU COMPOSANT
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_mpu6050`
        - |link_mpu6050_buy|

Sch√©ma
---------

Le MPU6050 communique avec le microcontr√¥leur via l'interface du bus I2C. 
Les broches SDA1 et SCL1 doivent √™tre connect√©es aux broches correspondantes.

.. image:: ../python_pi5/img/2.2.9_mpu6050_schematic.png


Proc√©dures exp√©rimentales
-------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: ../python_pi5/img/2.2.9_mpu6050_circuit.png

**√âtape 2** : Configurez I2C (voir l'annexe :ref:`i2c_config`. Si vous avez d√©j√† 
configur√© I2C, passez cette √©tape.)

**√âtape 3 :** Allez dans le dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python-pi5

**√âtape 4 :** Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.2.9_mpu6050_zero.py

Lorsque le code est ex√©cut√©, l'angle de d√©viation des axes x et y, 
ainsi que l'acc√©l√©ration et la vitesse angulaire de chaque axe lues 
par le MPU6050 seront affich√©s √† l'√©cran apr√®s calcul.

.. note::

    * Si vous obtenez l'erreur ``FileNotFoundError: [Errno 2] No such file or directory: '/dev/i2c-1'``, vous devez vous r√©f√©rer √† :ref:`i2c_config` pour activer l'I2C.
    * Si vous obtenez l'erreur ``ModuleNotFoundError: No module named 'smbus2'``, veuillez ex√©cuter ``sudo pip3 install smbus2``.
    * Si l'erreur ``OSError: [Errno 121] Remote I/O error`` appara√Æt, cela signifie que le module est mal c√¢bl√© ou que le module est cass√©.

.. warning::

    Si vous recevez le message d'erreur ``RuntimeError: Cannot determine SOC peripheral base address``, veuillez consulter :ref:`faq_soc`

**Code**

.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez vous rendre au chemin du code source comme ``raphael-kit/python-pi5``. Apr√®s avoir modifi√© le code, vous pouvez l'ex√©cuter directement pour voir l'effet.

.. raw:: html

    <run></run>

.. code-block:: python

   import smbus
   import math
   import time

   # Power management registers
   power_mgmt_1 = 0x6b
   power_mgmt_2 = 0x6c

   def read_byte(adr):
       return bus.read_byte_data(address, adr)

   def read_word(adr):
       high = bus.read_byte_data(address, adr)
       low = bus.read_byte_data(address, adr+1)
       val = (high << 8) + low
       return val

   def read_word_2c(adr):
       val = read_word(adr)
       if (val >= 0x8000):
           return -((65535 - val) + 1)
       else:
           return val

   def dist(a,b):
       return math.sqrt((a*a)+(b*b))

   def get_y_rotation(x,y,z):
       radians = math.atan2(x, dist(y,z))
       return -math.degrees(radians)

   def get_x_rotation(x,y,z):
       radians = math.atan2(y, dist(x,z))
       return math.degrees(radians)


   bus = smbus.SMBus(1) # or bus = smbus.SMBus(1) for Revision 2 boards
   address = 0x68       # This is the address value read via the i2cdetect command

   # Now wake the 6050 up as it starts in sleep mode
   bus.write_byte_data(address, power_mgmt_1, 0)

   while True:
       time.sleep(0.1)
       gyro_xout = read_word_2c(0x43)
       gyro_yout = read_word_2c(0x45)
       gyro_zout = read_word_2c(0x47)

       print ("gyro_xout : ", gyro_xout, " scaled: ", (gyro_xout / 131))
       print ("gyro_yout : ", gyro_yout, " scaled: ", (gyro_yout / 131))
       print ("gyro_zout : ", gyro_zout, " scaled: ", (gyro_zout / 131))

       accel_xout = read_word_2c(0x3b)
       accel_yout = read_word_2c(0x3d)
       accel_zout = read_word_2c(0x3f)

       accel_xout_scaled = accel_xout / 16384.0
       accel_yout_scaled = accel_yout / 16384.0
       accel_zout_scaled = accel_zout / 16384.0

       print ("accel_xout: ", accel_xout, " scaled: ", accel_xout_scaled)
       print ("accel_yout: ", accel_yout, " scaled: ", accel_yout_scaled)
       print ("accel_zout: ", accel_zout, " scaled: ", accel_zout_scaled)

       print ("x rotation: " , get_x_rotation(accel_xout_scaled, accel_yout_scaled, accel_zout_scaled))
       print ("y rotation: " , get_y_rotation(accel_xout_scaled, accel_yout_scaled, accel_zout_scaled))

       time.sleep(1)


**Explication du code**

#. Lire les donn√©es du capteur envoy√©es par le MPU6050.

   .. code-block:: python

       def read_word(adr):
           high = bus.read_byte_data(address, adr)
           low = bus.read_byte_data(address, adr+1)
           val = (high << 8) + low
           return val

       def read_word_2c(adr):
           val = read_word(adr)
           if (val >= 0x8000):
               return -((65535 - val) + 1)
           else:
               return val

#. Calculer l'angle de d√©viation de l'axe y.

   .. code-block:: python

       def get_y_rotation(x,y,z):
           radians = math.atan2(x, dist(y,z))
           return -math.degrees(radians)

#. Calculer l'angle de d√©viation de l'axe x.

   .. code-block:: python

       def get_x_rotation(x,y,z):
           radians = math.atan2(y, dist(x,z))
           return math.degrees(radians)

#. Lire les valeurs des axes x, y et z sur le capteur gyroscopique, convertir les m√©tadonn√©es en valeurs de vitesse angulaire, puis les imprimer.

   .. code-block:: python

       gyro_xout = read_word_2c(0x43)
       gyro_yout = read_word_2c(0x45)
       gyro_zout = read_word_2c(0x47)

       print ("gyro_xout : ", gyro_xout, " scaled: ", (gyro_xout / 131))
       print ("gyro_yout : ", gyro_yout, " scaled: ", (gyro_yout / 131))
       print ("gyro_zout : ", gyro_zout, " scaled: ", (gyro_zout / 131))

#. Lire les valeurs des axes x, y et z sur le capteur d'acc√©l√©ration, convertir les √©l√©ments en valeurs de vitesse acc√©l√©r√©e (unit√© de gravit√©), et les imprimer.

   .. code-block:: python

       accel_xout = read_word_2c(0x3b)
       accel_yout = read_word_2c(0x3d)
       accel_zout = read_word_2c(0x3f)

       accel_xout_scaled = accel_xout / 16384.0
       accel_yout_scaled = accel_yout / 16384.0
       accel_zout_scaled = accel_zout / 16384.0

       print ("accel_xout: ", accel_xout, " scaled: ", accel_xout_scaled)
       print ("accel_yout: ", accel_yout, " scaled: ", accel_yout_scaled)
       print ("accel_zout: ", accel_zout, " scaled: ", accel_zout_scaled)

#. Imprimer les angles de d√©viation des axes x et y.

   .. code-block:: python

       print ("x rotation: " , get_x_rotation(accel_xout_scaled, accel_yout_scaled, accel_zout_scaled))
       print ("y rotation: " , get_y_rotation(accel_xout_scaled, accel_yout_scaled, accel_zout_scaled))

