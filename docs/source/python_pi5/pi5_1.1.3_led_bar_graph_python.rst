.. note::

    Hola, ¬°bienvenido a la Comunidad de Entusiastas de SunFounder Raspberry Pi, Arduino y ESP32 en Facebook! Sum√©rgete en Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **¬øPor qu√© unirse?**

    - **Soporte experto**: Resuelve problemas postventa y desaf√≠os t√©cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprende y comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Previsualizaciones exclusivas**: Obt√©n acceso anticipado a nuevos anuncios de productos y adelantos.
    - **Descuentos especiales**: Disfruta de descuentos exclusivos en nuestros productos m√°s nuevos.
    - **Promociones y sorteos festivos**: Participa en sorteos y promociones de temporada.

    üëâ ¬øListo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y √∫nete hoy mismo.

.. _1.1.3_py_pi5:

1.1.3 Gr√°fico de Barra LED
=================================

Introducci√≥n
--------------------

En este proyecto, iluminaremos secuencialmente las luces en el gr√°fico de barra LED.

Componentes Requeridos
--------------------------------------

En este proyecto, necesitamos los siguientes componentes.

.. image:: ../python_pi5/img/1.1.3_led_bar_list.png

Es definitivamente conveniente comprar un kit completo, aqu√≠ est√° el enlace:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre
        - ELEMENTOS EN ESTE KIT
        - ENLACE
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Tambi√©n puedes comprarlos por separado en los enlaces a continuaci√≥n.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCI√ìN DE COMPONENTES
        - ENLACE DE COMPRA

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_bar_graph`
        - \-

Diagrama Esquem√°tico
----------------------------

============== ========== ======== ===
Nombre T-Board Pin f√≠sico wiringPi BCM
GPIO18         Pin 12     1        18
GPIO23         Pin 16     4        23
GPIO24         Pin 18     5        24
GPIO25         Pin 22     6        25
SPICE0         Pin 24     10       8
SPICE1         Pin 26     11       7
GPIO12         Pin 32     26       12
GPIO16         Pin 36     27       16
GPIO20         Pin 38     28       22
GPIO21         Pin 40     29       21
============== ========== ======== ===

.. image:: ../python_pi5/img/1.1.3_LedBarGraph_schematic.png

Procedimientos Experimentales
---------------------------------

**Paso 1**: Construye el circuito.

.. note::

    Presta atenci√≥n a la direcci√≥n al conectar. Si lo conectas al rev√©s, no se encender√°.

.. image:: ../python_pi5/img/1.1.3_LedBarGraph_circuit.png

**Paso 2:** Ve a la carpeta del c√≥digo.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python-pi5

**Paso 3**: Ejecuta el archivo ejecutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 1.1.3_LedBarGraph_zero.py

Despu√©s de ejecutar el c√≥digo, ver√°s que los LED en la barra LED se 
encienden y apagan regularmente.

.. warning::

    Si recibe el mensaje de error ``RuntimeError: Cannot determine SOC peripheral base address``, consulte :ref:`faq_soc`

**C√≥digo**

.. note::

    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el c√≥digo a continuaci√≥n. Pero antes de eso, necesitas ir a la ruta del c√≥digo fuente como ``raphael-kit/python-pi5``. Despu√©s de modificar el c√≥digo, puedes ejecutarlo directamente para ver el efecto.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import LED
   from time import sleep

   # Define GPIO pins where LEDs are connected
   led_pins = [18, 23, 24, 25, 8, 7, 12, 16, 20, 21]

   # Create LED objects for each pin
   leds = [LED(pin) for pin in led_pins]

   def odd_led_bar_graph():
       # Sequentially light up odd-numbered LEDs (index 0, 2, 4, etc.)
       for i in range(5):
           j = i * 2  # Calculate odd index
           leds[j].on()  # Turn on odd-numbered LED
           sleep(0.3)    # Delay for visual effect
           leds[j].off() # Turn off LED

   def even_led_bar_graph():
       # Sequentially light up even-numbered LEDs (index 1, 3, 5, etc.)
       for i in range(5):
           j = i * 2 + 1  # Calculate even index
           leds[j].on()   # Turn on even-numbered LED
           sleep(0.3)     # Delay for visual effect
           leds[j].off()  # Turn off LED

   def all_led_bar_graph():
       # Sequentially light up all LEDs one by one
       for led in leds:
           led.on()       # Turn on LED
           sleep(0.3)     # Delay for visual effect
           led.off()      # Turn off LED

   def turn_off_all_leds():
       # Turn off all LEDs at once
       for led in leds:
           led.off()

   try:
       # Main loop to cycle through LED patterns
       while True:
           odd_led_bar_graph()   # Activate odd-numbered LEDs
           sleep(0.3)            # Pause between patterns
           even_led_bar_graph()  # Activate even-numbered LEDs
           sleep(0.3)            # Pause between patterns
           all_led_bar_graph()   # Activate all LEDs
           sleep(0.3)            # Pause before restarting

   except KeyboardInterrupt:
       # Handle interruption (Ctrl+C) gracefully
       turn_off_all_leds()      # Ensure all LEDs are turned off on exit
       pass


**Explicaci√≥n del C√≥digo**

#. Estas l√≠neas importan las clases y funciones necesarias. ``LED`` de ``gpiozero`` para el control del LED y ``sleep`` de ``time`` para los retardos.

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import LED
       from time import sleep

#. La lista ``led_pins`` contiene los n√∫meros de los pines GPIO. ``leds`` es una lista de objetos ``LED``, cada uno correspondiente a un pin en ``led_pins``.

   .. code-block:: python

       # Define GPIO pins where LEDs are connected
       led_pins = [18, 23, 24, 25, 8, 7, 12, 16, 20, 21]

       # Create LED objects for each pin
       leds = [LED(pin) for pin in led_pins]

#. Permitir que el LED en los d√≠gitos impares de la barra de LEDs se encienda en secuencia.

   .. code-block:: python

       def odd_led_bar_graph():
           # Sequentially light up odd-numbered LEDs (index 0, 2, 4, etc.)
           for i in range(5):
               j = i * 2  # Calculate odd index
               leds[j].on()  # Turn on odd-numbered LED
               sleep(0.3)    # Delay for visual effect
               leds[j].off() # Turn off LED

#. Permitir que el LED en los d√≠gitos pares de la barra de LEDs se encienda en secuencia.

   .. code-block:: python

       def even_led_bar_graph():
           # Sequentially light up even-numbered LEDs (index 1, 3, 5, etc.)
           for i in range(5):
               j = i * 2 + 1  # Calculate even index
               leds[j].on()   # Turn on even-numbered LED
               sleep(0.3)     # Delay for visual effect
               leds[j].off()  # Turn off LED

#. Permitir que los LEDs en la barra de LEDs se enciendan uno por uno.

   .. code-block:: python

       def all_led_bar_graph():
           # Sequentially light up all LEDs one by one
           for led in leds:
               led.on()       # Turn on LED
               sleep(0.3)     # Delay for visual effect
               led.off()      # Turn off LED

#. El bucle ``while True`` alterna continuamente entre los patrones de LEDs. El bloque ``except`` maneja una interrupci√≥n de teclado (Ctrl+C), asegurando que todos los LEDs se apaguen al salir.

   .. code-block:: python

       try:
           # Bucle principal para alternar entre los patrones de LEDs
           while True:
               odd_led_bar_graph()   # Activar LEDs de n√∫mero impar
               sleep(0.3)            # Pausa entre patrones
               even_led_bar_graph()  # Activar LEDs de n√∫mero par
               sleep(0.3)            # Pausa entre patrones
               all_led_bar_graph()   # Activar todos los LEDs
               sleep(0.3)            # Pausa antes de reiniciar

       except KeyboardInterrupt:
           # Manejar interrupci√≥n (Ctrl+C) de manera segura
           turn_off_all_leds()      # Asegurar que todos los LEDs est√©n apagados al salir
           pass
