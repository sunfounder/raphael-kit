.. note::

    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten.

    **Warum beitreten?**

    - **Expertenunterst√ºtzung**: L√∂sen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams.
    - **Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre F√§higkeiten zu verbessern.
    - **Exklusive Vorschauen**: Erhalten Sie fr√ºhzeitigen Zugang zu neuen Produktank√ºndigungen und exklusiven Einblicken.
    - **Spezialrabatte**: Genie√üen Sie exklusive Rabatte auf unsere neuesten Produkte.
    - **Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil.

    üëâ Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!

.. _2.1.9_py_pi5:

2.1.9 Joystick
=====================

Einleitung
----------------------

In diesem Projekt lernen wir, wie ein Joystick funktioniert. Wir bedienen den Joystick und zeigen die Ergebnisse auf dem Bildschirm an.

Ben√∂tigte Komponenten
-----------------------------

F√ºr dieses Projekt ben√∂tigen wir die folgenden Komponenten.

.. image:: ../python_pi5/img/2.1.9_joystick_list.png

Es ist definitiv praktisch, ein ganzes Kit zu kaufen, hier ist der Link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Name	
        - IN DIESEM KIT ENTHALTENE TEILE
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Sie k√∂nnen sie auch separat √ºber die unten stehenden Links kaufen.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - KOMPONENTENVORSTELLUNG
        - KAUF-LINK

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_joystick`
        - \-
    *   - :ref:`cpn_adc0834`
        - \-

Schaltplan
--------------

Wenn die Daten des Joysticks gelesen werden, gibt es Unterschiede zwischen den Achsen: Die Daten der X- und Y-Achse sind analog, was bedeutet, dass der ADC0834 verwendet wird, um den analogen Wert in einen digitalen Wert umzuwandeln. Die Daten der Z-Achse sind digital, sodass Sie direkt den GPIO zum Lesen verwenden k√∂nnen, oder Sie k√∂nnen auch den ADC zum Lesen verwenden.

.. image:: ../python_pi5/img/2.1.9_joystick_schematic_1.png


.. image:: ../python_pi5/img/2.1.9_joystick_schematic_2.png

Experimentelle Verfahren
------------------------------

**Schritt 1:** Bauen Sie den Schaltkreis auf.

.. image:: ../python_pi5/img/2.1.9_Joystick_circuit.png

**Schritt 2:** Wechseln Sie zum Ordner des Codes.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python-pi5

**Schritt 3:** F√ºhren Sie den Code aus.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.1.9_Joystick_zero.py

Nachdem der Code ausgef√ºhrt wurde, drehen Sie den Joystick, dann werden die entsprechenden Werte von x, y, Btn auf dem Bildschirm angezeigt.

.. warning::

    Wenn die Fehlermeldung ``RuntimeError: Cannot determine SOC peripheral base address`` angezeigt wird, lesen Sie bitte :ref:`faq_soc`

**Code**

.. note::

    Sie k√∂nnen den unten stehenden Code **modifizieren/zur√ºcksetzen/kopieren/ausf√ºhren/stoppen**. Aber zuvor m√ºssen Sie zum Quellcodepfad wie ``raphael-kit/python-pi5`` gehen. Nachdem Sie den Code modifiziert haben, k√∂nnen Sie ihn direkt ausf√ºhren, um den Effekt zu sehen.


.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import Button
   import ADC0834
   import time

   # Initialize the button connected to GPIO pin 22
   BtnPin = Button(22)

   # Setup the ADC0834 ADC
   ADC0834.setup()

   try:
       # Main loop to read and print ADC values and button state
       while True:
           # Read X and Y values from ADC channels 0 and 1
           x_val = ADC0834.getResult(0)
           y_val = ADC0834.getResult(1)

           # Read the state of the button (pressed or not)
           Btn_val = BtnPin.value

           # Print the X, Y, and button values
           print('X: %d  Y: %d  Btn: %d' % (x_val, y_val, Btn_val))

           # Delay of 0.2 seconds before the next read
           time.sleep(0.2)

   # Gracefully handle script termination (e.g., via KeyboardInterrupt)
   except KeyboardInterrupt: 
       pass


**Code-Erkl√§rung**

#. Importiert die Klasse ``Button`` aus der Bibliothek ``gpiozero`` zur Verwaltung eines Buttons, der mit einem GPIO-Pin verbunden ist. Importiert ebenfalls die Bibliothek ``ADC0834`` f√ºr die Schnittstelle mit dem ADC0834 ADC (Analog-Digital-Wandler) Modul.

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import Button
       import ADC0834
       import time

#. Initialisiert einen Button, der mit dem GPIO-Pin 22 verbunden ist, und richtet das ADC0834-Modul f√ºr die Nutzung ein.

   .. code-block:: python

       # Initialize the button connected to GPIO pin 22
       BtnPin = Button(22)

       # Setup the ADC0834 ADC
       ADC0834.setup()

#. Die VRX- und VRY-Verbindungen des Joysticks sind mit CH0 und CH1 des ADC0834 verbunden. Dies erm√∂glicht das Lesen der Werte von CH0 und CH1, die dann in den Variablen ``x_val`` und ``y_val`` gespeichert werden. Zus√§tzlich wird der SW-Wert des Joysticks gelesen und der Variablen ``Btn_val`` zugewiesen. Die abgerufenen Werte von ``x_val``, ``y_val`` und ``Btn_val`` werden anschlie√üend mit der Funktion ``print()`` angezeigt.

   .. code-block:: python

       try:
           # Main loop to read and print ADC values and button state
           while True:
               # Read X and Y values from ADC channels 0 and 1
               x_val = ADC0834.getResult(0)
               y_val = ADC0834.getResult(1)

               # Read the state of the button (pressed or not)
               Btn_val = BtnPin.value

               # Print the X, Y, and button values
               print('X: %d  Y: %d  Btn: %d' % (x_val, y_val, Btn_val))

               # Delay of 0.2 seconds before the next read
               time.sleep(0.2)

       # Gracefully handle script termination (e.g., via KeyboardInterrupt)
       except KeyboardInterrupt: 
           pass


