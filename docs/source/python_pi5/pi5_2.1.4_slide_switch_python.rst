.. note::

    춰Hola! Bienvenido a la comunidad de entusiastas de SunFounder Raspberry Pi & Arduino & ESP32 en Facebook. Sum칠rgete m치s en Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **쯇or qu칠 unirte?**

    - **Soporte experto**: Resuelve problemas postventa y desaf칤os t칠cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprende y comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Avances exclusivos**: Accede anticipadamente a nuevos anuncios de productos y adelantos.
    - **Descuentos especiales**: Disfruta de descuentos exclusivos en nuestros productos m치s nuevos.
    - **Promociones y sorteos festivos**: Participa en sorteos y promociones de temporada.

    游녤 쯃isto para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y 칰nete hoy mismo.

.. _2.1.4_py_pi5:

2.1.4 Interruptor Deslizante
=================================

Introducci칩n
-----------------

En este proyecto, aprenderemos c칩mo usar un interruptor deslizante. Usualmente, 
el interruptor deslizante est치 soldado en una PCB como interruptor de encendido, 
pero aqu칤 necesitamos insertarlo en la placa de pruebas, por lo que puede que no quede 
ajustado. Lo utilizamos en la placa de pruebas para mostrar su funci칩n.

Componentes Necesarios
------------------------------

En este proyecto, necesitamos los siguientes componentes.

.. image:: ../python_pi5/img/2.1.4_slide_switch_list.png

Es definitivamente conveniente comprar un kit completo, aqu칤 est치 el enlace:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre	
        - ELEMENTOS EN ESTE KIT
        - ENLACE
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Tambi칠n puedes comprarlos por separado en los enlaces a continuaci칩n.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCI칍N DE COMPONENTES
        - ENLACE DE COMPRA

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_slide_switch`
        - |link_slide_switch_buy|
    *   - :ref:`cpn_capacitor`
        - |link_capacitor_buy|

Diagrama Esquem치tico
---------------------

Conecta el pin del medio del interruptor deslizante al GPIO17, y dos LEDs a los pines 
GPIO22 y GPIO27 respectivamente. Luego, cuando muevas el interruptor, ver치s que los dos 
LEDs se encienden alternadamente.

.. image:: ../python_pi5/img/2.1.4_slide_switch_schematic_1.png

.. image:: ../python_pi5/img/2.1.4_slide_switch_schematic_2.png


Procedimientos Experimentales
---------------------------------

**Paso 1:** Construye el circuito.

.. image:: ../python_pi5/img/2.1.4_slide_switch_circuit.png

**Paso 2:** Accede a la carpeta del c칩digo.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python-pi5

**Paso 3:** Ejecuta.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.1.4_Slider_zero.py

Mientras el c칩digo se est치 ejecutando, conecta el interruptor a la izquierda, entonces el LED amarillo se encender치; a la derecha, se encender치 el LED rojo.

.. warning::

    Si recibe el mensaje de error ``RuntimeError: Cannot determine SOC peripheral base address``, consulte :ref:`faq_soc`


**C칩digo**

.. note::

    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el c칩digo a continuaci칩n. Pero antes de eso, necesitas ir a la ruta del c칩digo fuente como ``raphael-kit/python-pi5``. Despu칠s de modificar el c칩digo, puedes ejecutarlo directamente para ver el efecto.


.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import LED, Button  # Importar clases LED y Button para control de GPIO
   from time import sleep  # Importar funci칩n sleep para a침adir retrasos

   # Inicializar el micro interruptor en el pin GPIO 17 con la resistencia pull-up deshabilitada
   micro_switch = Button(17, pull_up=False)
   # Inicializar LED1 en el pin GPIO 22
   led1 = LED(22)
   # Inicializar LED2 en el pin GPIO 27
   led2 = LED(27)

   try:
       # Bucle principal para controlar los estados del LED seg칰n el estado del micro interruptor
       while True:
           if micro_switch.is_pressed:  # Check if the micro switch is pressed
               print('    LED1 ON    ')  # Print status message
               led1.on()   # Turn on LED1
               led2.off()  # Turn off LED2
           else:  # If the micro switch is not pressed
               print('    LED2 ON    ')  # Print status message
               led1.off()  # Turn off LED1
               led2.on()   # Turn on LED2

           sleep(0.5)  # Esperar 0.5 segundos antes de verificar nuevamente el estado del interruptor

   except KeyboardInterrupt:
       # Manejar una interrupci칩n de teclado (Ctrl+C) para salir limpiamente del bucle
       pass
 

**Explicaci칩n del C칩digo**

#. Esta l칤nea configura el script para ejecutarse con Python 3. Importa ``LED`` y ``Button`` de ``gpiozero`` para controlar dispositivos GPIO, y ``sleep`` de ``time`` para a침adir retrasos.

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import LED, Button  # Importar clases LED y Button para control de GPIO
       from time import sleep  # Importar funci칩n sleep para a침adir retrasos

#. Inicializa un micro interruptor conectado al pin GPIO 17 con la resistencia pull-up deshabilitada, y dos LEDs conectados a los pines GPIO 22 y 27.

   .. code-block:: python

       # Inicializar el micro interruptor en el pin GPIO 17 con la resistencia pull-up deshabilitada
       micro_switch = Button(17, pull_up=False)
       # Inicializar LED1 en el pin GPIO 22
       led1 = LED(22)
       # Inicializar LED2 en el pin GPIO 27
       led2 = LED(27)

#. El bucle principal verifica el estado del micro interruptor. Si est치 presionado, LED1 se enciende y LED2 se apaga; si no est치 presionado, LED1 se apaga y LED2 se enciende. El bucle se repite cada 0.5 segundos. Captura una KeyboardInterrupt (como Ctrl+C) para permitir la terminaci칩n del script de manera limpia.

   .. code-block:: python

       try:
       # Bucle principal para controlar los estados del LED seg칰n el estado del micro interruptor
       while True:
           if micro_switch.is_pressed:  # Check if the micro switch is pressed
               print('    LED1 ON    ')  # Print status message
               led1.on()   # Turn on LED1
               led2.off()  # Turn off LED2
           else:  # If the micro switch is not pressed
               print('    LED2 ON    ')  # Print status message
               led1.off()  # Turn off LED1
               led2.on()   # Turn on LED2

           sleep(0.5)  # Esperar 0.5 segundos antes de verificar nuevamente el estado del interruptor

       except KeyboardInterrupt:
           # Manejar una interrupci칩n de teclado (Ctrl+C) para salir limpiamente del bucle
           pass
