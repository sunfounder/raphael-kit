.. note::

    ¡Hola! Bienvenido a la comunidad de entusiastas de SunFounder Raspberry Pi & Arduino & ESP32 en Facebook. Sumérgete más en Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **¿Por qué unirte?**

    - **Soporte experto**: Resuelve problemas postventa y desafíos técnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprende y comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Avances exclusivos**: Accede anticipadamente a nuevos anuncios de productos y adelantos.
    - **Descuentos especiales**: Disfruta de descuentos exclusivos en nuestros productos más nuevos.
    - **Promociones y sorteos festivos**: Participa en sorteos y promociones de temporada.

    👉 ¿Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y únete hoy mismo.

.. _2.1.4_py_pi5:

2.1.4 Interruptor Deslizante
=================================

Introducción
-----------------

En este proyecto, aprenderemos cómo usar un interruptor deslizante. Usualmente, 
el interruptor deslizante está soldado en una PCB como interruptor de encendido, 
pero aquí necesitamos insertarlo en la placa de pruebas, por lo que puede que no quede 
ajustado. Lo utilizamos en la placa de pruebas para mostrar su función.

Componentes Necesarios
------------------------------

En este proyecto, necesitamos los siguientes componentes.

.. image:: ../python_pi5/img/2.1.4_slide_switch_list.png

Es definitivamente conveniente comprar un kit completo, aquí está el enlace:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre	
        - ELEMENTOS EN ESTE KIT
        - ENLACE
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

También puedes comprarlos por separado en los enlaces a continuación.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCIÓN DE COMPONENTES
        - ENLACE DE COMPRA

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_slide_switch`
        - |link_slide_switch_buy|
    *   - :ref:`cpn_capacitor`
        - |link_capacitor_buy|

Diagrama Esquemático
---------------------

Conecta el pin del medio del interruptor deslizante al GPIO17, y dos LEDs a los pines 
GPIO22 y GPIO27 respectivamente. Luego, cuando muevas el interruptor, verás que los dos 
LEDs se encienden alternadamente.

.. image:: ../python_pi5/img/2.1.4_slide_switch_schematic_1.png

.. image:: ../python_pi5/img/2.1.4_slide_switch_schematic_2.png


Procedimientos Experimentales
---------------------------------

**Paso 1:** Construye el circuito.

.. image:: ../python_pi5/img/2.1.4_slide_switch_circuit.png

**Paso 2:** Accede a la carpeta del código.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python-pi5

**Paso 3:** Ejecuta.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.1.4_Slider_zero.py

Mientras el código se está ejecutando, conecta el interruptor a la izquierda, entonces el LED amarillo se encenderá; a la derecha, se encenderá el LED rojo.

.. warning::

    Si recibe el mensaje de error ``RuntimeError: Cannot determine SOC peripheral base address``, consulte :ref:`faq_soc`

**Código**

.. note::

    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el código a continuación. Pero antes de eso, necesitas ir a la ruta del código fuente como ``raphael-kit/python-pi5``. Después de modificar el código, puedes ejecutarlo directamente para ver el efecto.


.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import LED, Button  # Importar clases LED y Button para control de GPIO
   from time import sleep  # Importar función sleep para añadir retrasos

   # Inicializar el micro interruptor en el pin GPIO 17 con la resistencia pull-up deshabilitada
   micro_switch = Button(17, pull_up=False)
   # Inicializar LED1 en el pin GPIO 22
   led1 = LED(22)
   # Inicializar LED2 en el pin GPIO 27
   led2 = LED(27)

   try:
       # Bucle principal para controlar los estados del LED según el estado del micro interruptor
       while True:
           if micro_switch.is_pressed:  # Check if the micro switch is pressed
               print('    LED1 ON    ')  # Print status message
               led1.on()   # Turn on LED1
               led2.off()  # Turn off LED2
           else:  # If the micro switch is not pressed
               print('    LED2 ON    ')  # Print status message
               led1.off()  # Turn off LED1
               led2.on()   # Turn on LED2

           sleep(0.5)  # Esperar 0.5 segundos antes de verificar nuevamente el estado del interruptor

   except KeyboardInterrupt:
       # Manejar una interrupción de teclado (Ctrl+C) para salir limpiamente del bucle
       pass
 

**Explicación del Código**

#. Esta línea configura el script para ejecutarse con Python 3. Importa ``LED`` y ``Button`` de ``gpiozero`` para controlar dispositivos GPIO, y ``sleep`` de ``time`` para añadir retrasos.

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import LED, Button  # Importar clases LED y Button para control de GPIO
       from time import sleep  # Importar función sleep para añadir retrasos

#. Inicializa un micro interruptor conectado al pin GPIO 17 con la resistencia pull-up deshabilitada, y dos LEDs conectados a los pines GPIO 22 y 27.

   .. code-block:: python

       # Inicializar el micro interruptor en el pin GPIO 17 con la resistencia pull-up deshabilitada
       micro_switch = Button(17, pull_up=False)
       # Inicializar LED1 en el pin GPIO 22
       led1 = LED(22)
       # Inicializar LED2 en el pin GPIO 27
       led2 = LED(27)

#. El bucle principal verifica el estado del micro interruptor. Si está presionado, LED1 se enciende y LED2 se apaga; si no está presionado, LED1 se apaga y LED2 se enciende. El bucle se repite cada 0.5 segundos. Captura una KeyboardInterrupt (como Ctrl+C) para permitir la terminación del script de manera limpia.

   .. code-block:: python

       try:
       # Bucle principal para controlar los estados del LED según el estado del micro interruptor
       while True:
           if micro_switch.is_pressed:  # Check if the micro switch is pressed
               print('    LED1 ON    ')  # Print status message
               led1.on()   # Turn on LED1
               led2.off()  # Turn off LED2
           else:  # If the micro switch is not pressed
               print('    LED2 ON    ')  # Print status message
               led1.off()  # Turn off LED1
               led2.on()   # Turn on LED2

           sleep(0.5)  # Esperar 0.5 segundos antes de verificar nuevamente el estado del interruptor

       except KeyboardInterrupt:
           # Manejar una interrupción de teclado (Ctrl+C) para salir limpiamente del bucle
           pass
