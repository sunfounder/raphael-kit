 
.. _2.2.6_py_pi5:

2.2.5 Module de capteur de vitesse
=====================================

Introduction
---------------

Dans ce projet, nous allons apprendre à utiliser le module de capteur de vitesse. Un module de capteur de vitesse est un type de tachymètre utilisé pour mesurer la vitesse d'un objet en rotation, comme un moteur.

Composants nécessaires
-------------------------

Dans ce projet, nous avons besoin des composants suivants.

.. image:: ../python_pi5/img/2.2.6_photo_interrrupter_list.png
    :width: 700
    :align: center

Il est certainement pratique d'acheter un kit complet, voici le lien :

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom	
        - ARTICLES DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez également les acheter séparément via les liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DU COMPOSANT
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_speed_sensor`
        - \-

Schéma
---------

.. image:: ../python_pi5/img/2.2.6_photo_interrrupter_schematic.png
    :width: 400
    :align: center

Procédures expérimentales
----------------------------

**Étape 1 :** Construisez le circuit.

.. image:: ../python_pi5/img/2.2.6_photo_interrrupter_circuit.png
    :width: 700
    :align: center

**Étape 2 :** Changez de répertoire.

.. raw:: html

   <run></run>

.. code-block::
    
    cd ~/raphael-kit/python-pi5

**Étape 3 :** Exécutez.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.2.6_speed_sensor_module_zero.py

Après l'exécution du code, la LED verte s'allumera. Si vous placez un obstacle 
dans l'espace du module de capteur de vitesse, "light blocked" sera imprimé à 
l'écran et la LED rouge s'allumera. Retirez l'obstacle et la LED verte s'allumera de nouveau.

**Code**

.. note::

    Vous pouvez **Modifier/Réinitialiser/Copier/Exécuter/Arrêter** le code ci-dessous. Mais avant cela, vous devez vous rendre au chemin du code source comme ``raphael-kit/python-pi5``. Après avoir modifié le code, vous pouvez l'exécuter directement pour voir l'effet.


.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import LED, Button
   from signal import pause

   # Initialize GPIO pins for the speed sensor and LEDs using GPIO Zero library
   speed_sensor = Button(17, pull_up=False)  # Speed sensor connected to GPIO pin 17 without pull-up
   green_led = LED(27)                      # Green LED connected to GPIO pin 27
   red_led = LED(22)                        # Red LED connected to GPIO pin 22

   def update_leds():
       """
       Update the state of LEDs based on the speed sensor.
       - If the sensor is pressed (triggered), the red LED is turned on and a message is printed.
       - If the sensor is released (not triggered), the green LED is turned on.
       """
       if speed_sensor.is_pressed:
           green_led.off()  # Turn off green LED
           red_led.on()     # Turn on red LED
           print('Light was blocked')  # Print message indicating sensor is triggered
       else:
           green_led.on()   # Turn on green LED
           red_led.off()    # Turn off red LED

   try:
       # Main loop to continuously check sensor state
       while True:
           # Update LEDs based on sensor state changes
           speed_sensor.when_pressed = update_leds   # Update LEDs when sensor is pressed
           speed_sensor.when_released = update_leds  # Update LEDs when sensor is released

   except KeyboardInterrupt:
       # Handle KeyboardInterrupt (Ctrl+C) for a graceful script termination
       pass

**Explication du code**

#. La bibliothèque ``gpiozero`` est importée pour utiliser ses classes ``LED`` et ``Button`` afin d'interagir avec les broches GPIO. La bibliothèque ``signal`` est importée pour la fonction ``pause``, qui est utilisée pour maintenir le script en cours d'exécution.

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import LED, Button
       from signal import pause

#. ``speed_sensor`` est défini comme un ``Button`` sur la broche GPIO 17. Le paramètre ``pull_up=False`` indique que la résistance pull-up interne n'est pas utilisée. ``green_led`` et ``red_led`` sont initialisés comme des objets ``LED`` connectés respectivement aux broches GPIO 27 et 22.

   .. code-block:: python

       # Initialize GPIO pins for the speed sensor and LEDs using GPIO Zero library
       speed_sensor = Button(17, pull_up=False)  # Speed sensor connected to GPIO pin 17 without pull-up
       green_led = LED(27)                      # Green LED connected to GPIO pin 27
       red_led = LED(22)                        # Red LED connected to GPIO pin 22

#. La fonction ``update_leds`` vérifie l'état du capteur de vitesse. Si le capteur est pressé (activé), elle éteint la LED verte, allume la LED rouge et imprime un message. Si le capteur est relâché, elle fait l'inverse.

   .. code-block:: python

       def update_leds():
           """
           Update the state of LEDs based on the speed sensor.
           - If the sensor is pressed (triggered), the red LED is turned on and a message is printed.
           - If the sensor is released (not triggered), the green LED is turned on.
           """
           if speed_sensor.is_pressed:
               green_led.off()  # Turn off green LED
               red_led.on()     # Turn on red LED
               print('Light was blocked')  # Print message indicating sensor is triggered
           else:
               green_led.on()   # Turn on green LED
               red_led.off()    # Turn off red LED

#. La boucle principale vérifie continuellement l'état du capteur de vitesse. Les attributs ``when_pressed`` et ``when_released`` sont des gestionnaires d'événements qui appellent la fonction ``update_leds`` lorsque l'état du capteur change. Le bloc try-except est utilisé pour gérer une interruption clavier (KeyboardInterrupt) pour une sortie propre.

   .. code-block:: python

       try:
           # Main loop to continuously check sensor state
           while True:
               # Update LEDs based on sensor state changes
               speed_sensor.when_pressed = update_leds   # Update LEDs when sensor is pressed
               speed_sensor.when_released = update_leds  # Update LEDs when sensor is released

       except KeyboardInterrupt:
           # Handle KeyboardInterrupt (Ctrl+C) for a graceful script termination
           pass