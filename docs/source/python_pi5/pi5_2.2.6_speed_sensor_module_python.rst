.. note::

    ¡Hola, bienvenido a la comunidad de entusiastas de SunFounder Raspberry Pi & Arduino & ESP32 en Facebook! Sumérgete más en Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **¿Por qué unirse?**

    - **Soporte experto**: Resuelve problemas postventa y desafíos técnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprender y compartir**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Avances exclusivos**: Obtén acceso anticipado a anuncios de nuevos productos y adelantos.
    - **Descuentos especiales**: Disfruta de descuentos exclusivos en nuestros productos más recientes.
    - **Promociones y sorteos festivos**: Participa en sorteos y promociones de temporada.

    👉 ¿Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y únete hoy mismo!

.. _2.2.6_py_pi5:

2.2.6 Módulo Sensor de Velocidad
=====================================

Introducción
------------------

En este proyecto, aprenderemos el uso del módulo sensor de velocidad. Un módulo sensor de velocidad es un tipo de tacómetro que se utiliza para medir la velocidad de un objeto rotativo como un motor.

Componentes Necesarios
----------------------------

En este proyecto, necesitamos los siguientes componentes. 

.. image:: ../python_pi5/img/2.2.6_photo_interrrupter_list.png
    :width: 700
    :align: center

Es definitivamente conveniente comprar un kit completo, aquí está el enlace: 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre
        - ARTÍCULOS EN ESTE KIT
        - ENLACE
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

También puedes comprarlos por separado en los enlaces a continuación.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCIÓN DEL COMPONENTE
        - ENLACE DE COMPRA

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_speed_sensor`
        - \-

Diagrama Esquemático
-------------------------

.. image:: ../python_pi5/img/2.2.6_photo_interrrupter_schematic.png
    :width: 400
    :align: center

Procedimientos Experimentales
---------------------------------

**Paso 1:** Construir el circuito.

.. image:: ../python_pi5/img/2.2.6_photo_interrrupter_circuit.png
    :width: 700
    :align: center

**Paso 2:** Cambiar de directorio.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python-pi5

**Paso 3:** Ejecutar.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.2.6_speed_sensor_module_zero.py

Después de ejecutar el código, el LED verde se encenderá. Si colocas un obstáculo en el hueco del módulo sensor de velocidad, se imprimirá "luz bloqueada" en la pantalla y el LED rojo se encenderá.
Retira el obstáculo y el LED verde se encenderá de nuevo.

.. warning::

    Si recibe el mensaje de error ``RuntimeError: Cannot determine SOC peripheral base address``, consulte :ref:`faq_soc`

**Código**

.. note::

    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el código a continuación. Pero antes de eso, necesitas ir a la ruta del código fuente como ``raphael-kit/python-pi5``. Después de modificar el código, puedes ejecutarlo directamente para ver el efecto.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import LED, Button
   from signal import pause

   # Inicializar pines GPIO para el sensor de velocidad y los LEDs utilizando la biblioteca GPIO Zero
   speed_sensor = Button(17, pull_up=False)  # Sensor de velocidad conectado al pin GPIO 17 sin pull-up
   green_led = LED(27)                      # LED verde conectado al pin GPIO 27
   red_led = LED(22)                        # LED rojo conectado al pin GPIO 22

   def update_leds():
       """
       Update the state of LEDs based on the speed sensor.
       - If the sensor is pressed (triggered), the red LED is turned on and a message is printed.
       - If the sensor is released (not triggered), the green LED is turned on.
       """
       if speed_sensor.is_pressed:
           green_led.off()  # Turn off green LED
           red_led.on()     # Turn on red LED
           print('Light was blocked')  # Print message indicating sensor is triggered
       else:
           green_led.on()   # Encender LED verde
           red_led.off()    # Apagar LED rojo

   try:
       # Bucle principal para verificar continuamente el estado del sensor
       while True:
           # Actualizar LEDs basado en cambios en el estado del sensor
           speed_sensor.when_pressed = update_leds   # Actualizar LEDs cuando el sensor está presionado
           speed_sensor.when_released = update_leds  # Actualizar LEDs cuando el sensor está liberado

   except KeyboardInterrupt:
       # Manejar KeyboardInterrupt (Ctrl+C) para una terminación segura del script
       pass


**Explicación del Código**

#. Se importa la biblioteca ``gpiozero`` para usar sus clases ``LED`` y ``Button`` para interactuar con los pines GPIO. Se importa la biblioteca ``signal`` para usar la función ``pause``, que se utiliza para mantener el script en ejecución.

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import LED, Button
       from signal import pause

#. El sensor de velocidad se configura como un ``Button`` en el pin GPIO 17. El parámetro ``pull_up=False`` indica que no se utiliza la resistencia pull-up interna. ``green_led`` y ``red_led`` se inicializan como objetos ``LED`` conectados a los pines GPIO 27 y 22, respectivamente.

   .. code-block:: python

       # Inicializar pines GPIO para el sensor de velocidad y los LEDs utilizando la biblioteca GPIO Zero
       speed_sensor = Button(17, pull_up=False)  # Sensor de velocidad conectado al pin GPIO 17 sin pull-up
       green_led = LED(27)                      # LED verde conectado al pin GPIO 27
       red_led = LED(22)                        # LED rojo conectado al pin GPIO 22

#. La función ``update_leds`` verifica el estado del sensor de velocidad. Si el sensor está presionado (activado), apaga el LED verde, enciende el LED rojo e imprime un mensaje. Si el sensor está liberado, hace lo contrario.

   .. code-block:: python

       def update_leds():
           """
           Update the state of LEDs based on the speed sensor.
           - If the sensor is pressed (triggered), the red LED is turned on and a message is printed.
           - If the sensor is released (not triggered), the green LED is turned on.
           """
           if speed_sensor.is_pressed:
               green_led.off()  # Turn off green LED
               red_led.on()     # Turn on red LED
               print('Light was blocked')  # Print message indicating sensor is triggered
           else:
               green_led.on()   # Encender LED verde
               red_led.off()    # Apagar LED rojo

#. El bucle principal verifica continuamente el estado del sensor de velocidad. Los atributos ``when_pressed`` y ``when_released`` son manejadores de eventos que llaman a la función ``update_leds`` cuando el estado del sensor cambia. El bloque try-except se utiliza para manejar una excepción KeyboardInterrupt para una salida limpia.

   .. code-block:: python

       try:
           # Bucle principal para verificar continuamente el estado del sensor
           while True:
               # Actualizar LEDs basado en cambios en el estado del sensor
               speed_sensor.when_pressed = update_leds   # Actualizar LEDs cuando el sensor está presionado
               speed_sensor.when_released = update_leds  # Actualizar LEDs cuando el sensor está liberado

       except KeyboardInterrupt:
           # Manejar KeyboardInterrupt (Ctrl+C) para una terminación segura del script
           pass











