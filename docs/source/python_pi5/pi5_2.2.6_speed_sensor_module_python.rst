.. note::

    こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。

    **参加する理由は？**

    - **エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。
    - **学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。
    - **独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。
    - **特別割引**：最新製品の独占割引をお楽しみください。
    - **祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。

    👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！

.. _2.2.6_py_pi5:

2.2.6 スピードセンサーモジュール
=========================================

はじめに
------------------

このプロジェクトでは、スピードセンサーモジュールの使用方法について学びます。スピードセンサーモジュールはタコメーターの一種で、モーターなどの回転する物体の速度を測定するために使用されます。

必要な部品
------------------------------

このプロジェクトには、次のコンポーネントが必要です。 

.. image:: ../python_pi5/img/2.2.6_photo_interrrupter_list.png
    :width: 700
    :align: center

一式を購入するのが便利です、こちらがリンクです： 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - 名前	
        - このキットのアイテム
        - リンク
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

以下のリンクから別々に購入することもできます。

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - コンポーネントの紹介
        - 購入リンク

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_speed_sensor`
        - \-

回路図
-----------------------

.. image:: ../python_pi5/img/2.2.6_photo_interrrupter_schematic.png
    :width: 400
    :align: center

実験手順
------------------------------

**ステップ 1:** 回路を組み立てる。

.. image:: ../python_pi5/img/2.2.6_photo_interrrupter_circuit.png
    :width: 700
    :align: center


**ステップ 2:** ディレクトリを変更する。

.. raw:: html

   <run></run>

.. code-block::
    
    cd ~/raphael-kit/python-pi5

**ステップ 3:** 実行する。

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.2.6_speed_sensor_module_zero.py

コードを実行した後、緑色のLEDが点灯します。スピードセンサーモジュールの隙間に障害物を置くと、「Light was blocked」と画面に表示され、赤色のLEDが点灯します。障害物を取り除くと、緑色のLEDが再び点灯します。

.. warning::

    エラー メッセージ ``RuntimeError: Cannot determine SOC peripheral base address`` が表示された場合は、 :ref:`faq_soc` を参照してください。

**コード**

.. note::

    下記のコードを **変更/リセット/コピー/実行/停止** することができます。しかし、その前に ``raphael-kit/python-pi5`` のようなソースコードのパスに移動する必要があります。コードを変更した後、直接実行して効果を見ることができます。


.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import LED, Button
   from signal import pause

   # Initialize GPIO pins for the speed sensor and LEDs using GPIO Zero library
   speed_sensor = Button(17, pull_up=False)  # Speed sensor connected to GPIO pin 17 without pull-up
   green_led = LED(27)                      # Green LED connected to GPIO pin 27
   red_led = LED(22)                        # Red LED connected to GPIO pin 22

   def update_leds():
       """
       Update the state of LEDs based on the speed sensor.
       - If the sensor is pressed (triggered), the red LED is turned on and a message is printed.
       - If the sensor is released (not triggered), the green LED is turned on.
       """
       if speed_sensor.is_pressed:
           green_led.off()  # Turn off green LED
           red_led.on()     # Turn on red LED
           print('Light was blocked')  # Print message indicating sensor is triggered
       else:
           green_led.on()   # Turn on green LED
           red_led.off()    # Turn off red LED

   try:
       # Main loop to continuously check sensor state
       while True:
           # Update LEDs based on sensor state changes
           speed_sensor.when_pressed = update_leds   # Update LEDs when sensor is pressed
           speed_sensor.when_released = update_leds  # Update LEDs when sensor is released

   except KeyboardInterrupt:
       # Handle KeyboardInterrupt (Ctrl+C) for a graceful script termination
       pass


**コード説明**

#. ``gpiozero`` ライブラリをインポートして、GPIOピンとのやり取りに ``LED`` と ``Button`` クラスを使用します。 ``signal`` ライブラリから ``pause`` 関数をインポートし、スクリプトが実行され続けるようにします。

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import LED, Button
       from signal import pause

#. スピードセンサーをGPIOピン17に ``Button`` として設定します。 ``pull_up=False`` パラメーターは内部プルアップ抵抗が使用されないことを示します。 ``green_led`` と ``red_led`` はそれぞれGPIOピン27と22に接続された ``LED`` オブジェクトとして初期化されます。

   .. code-block:: python

       # Initialize GPIO pins for the speed sensor and LEDs using GPIO Zero library
       speed_sensor = Button(17, pull_up=False)  # Speed sensor connected to GPIO pin 17 without pull-up
       green_led = LED(27)                      # Green LED connected to GPIO pin 27
       red_led = LED(22)                        # Red LED connected to GPIO pin 22

#. スピードセンサーの状態をチェックする ``update_leds`` 関数を定義します。センサーが押される（活性化する）と、緑色LEDを消し、赤色LEDを点け、メッセージを表示します。センサーが解放されると、逆の動作をします。

   .. code-block:: python

       def update_leds():
           """
           Update the state of LEDs based on the speed sensor.
           - If the sensor is pressed (triggered), the red LED is turned on and a message is printed.
           - If the sensor is released (not triggered), the green LED is turned on.
           """
           if speed_sensor.is_pressed:
               green_led.off()  # Turn off green LED
               red_led.on()     # Turn on red LED
               print('Light was blocked')  # Print message indicating sensor is triggered
           else:
               green_led.on()   # Turn on green LED
               red_led.off()    # Turn off red LED

#. メインループはスピードセンサーの状態を連続的にチェックします。 ``when_pressed`` と ``when_released`` 属性は、センサーの状態が変化したときに ``update_leds`` 関数を呼び出すイベントハンドラです。try-exceptブロックは、Ctrl+Cでの優雅な終了を処理するために使用されます。

   .. code-block:: python

       try:
           # Main loop to continuously check sensor state
           while True:
               # Update LEDs based on sensor state changes
               speed_sensor.when_pressed = update_leds   # Update LEDs when sensor is pressed
               speed_sensor.when_released = update_leds  # Update LEDs when sensor is released

       except KeyboardInterrupt:
           # Handle KeyboardInterrupt (Ctrl+C) for a graceful script termination
           pass
