 
.. note::

    Bonjour et bienvenue dans la Communaut√© Facebook des passionn√©s de Raspberry Pi, Arduino et ESP32 de SunFounder ! Plongez plus profond√©ment dans l'univers des Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre et partager** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits et aux aper√ßus.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos produits les plus r√©cents.
    - **Promotions festives et cadeaux** : Participez √† des cadeaux et des promotions de vacances.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez [|link_sf_facebook|] et rejoignez-nous aujourd'hui !

.. _2.2.6_py_pi5:

2.2.6 Module de capteur de vitesse
=====================================

Introduction
---------------

Dans ce projet, nous allons apprendre √† utiliser le module de capteur de vitesse. Un module de capteur de vitesse est un type de tachym√®tre utilis√© pour mesurer la vitesse d'un objet en rotation, comme un moteur.

Composants n√©cessaires
-------------------------

Dans ce projet, nous avons besoin des composants suivants.

.. image:: ../python_pi5/img/2.2.6_photo_interrrupter_list.png
    :width: 700
    :align: center

Il est certainement pratique d'acheter un kit complet, voici le lien :

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom	
        - ARTICLES DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez √©galement les acheter s√©par√©ment via les liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DU COMPOSANT
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_speed_sensor`
        - \-

Sch√©ma
---------

.. image:: ../python_pi5/img/2.2.6_photo_interrrupter_schematic.png
    :width: 400
    :align: center

Proc√©dures exp√©rimentales
----------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: ../python_pi5/img/2.2.6_photo_interrrupter_circuit.png
    :width: 700
    :align: center

**√âtape 2 :** Changez de r√©pertoire.

.. raw:: html

   <run></run>

.. code-block::
    
    cd ~/raphael-kit/python-pi5

**√âtape 3 :** Ex√©cutez.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.2.6_speed_sensor_module_zero.py

Apr√®s l'ex√©cution du code, la LED verte s'allumera. Si vous placez un obstacle 
dans l'espace du module de capteur de vitesse, "light blocked" sera imprim√© √† 
l'√©cran et la LED rouge s'allumera. Retirez l'obstacle et la LED verte s'allumera de nouveau.

.. warning::

    Si vous recevez le message d'erreur ``RuntimeError: Cannot determine SOC peripheral base address``, veuillez consulter :ref:`faq_soc`

**Code**

.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez vous rendre au chemin du code source comme ``raphael-kit/python-pi5``. Apr√®s avoir modifi√© le code, vous pouvez l'ex√©cuter directement pour voir l'effet.


.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import LED, Button
   from signal import pause

   # Initialize GPIO pins for the speed sensor and LEDs using GPIO Zero library
   speed_sensor = Button(17, pull_up=False)  # Speed sensor connected to GPIO pin 17 without pull-up
   green_led = LED(27)                      # Green LED connected to GPIO pin 27
   red_led = LED(22)                        # Red LED connected to GPIO pin 22

   def update_leds():
       """
       Update the state of LEDs based on the speed sensor.
       - If the sensor is pressed (triggered), the red LED is turned on and a message is printed.
       - If the sensor is released (not triggered), the green LED is turned on.
       """
       if speed_sensor.is_pressed:
           green_led.off()  # Turn off green LED
           red_led.on()     # Turn on red LED
           print('Light was blocked')  # Print message indicating sensor is triggered
       else:
           green_led.on()   # Turn on green LED
           red_led.off()    # Turn off red LED

   try:
       # Main loop to continuously check sensor state
       while True:
           # Update LEDs based on sensor state changes
           speed_sensor.when_pressed = update_leds   # Update LEDs when sensor is pressed
           speed_sensor.when_released = update_leds  # Update LEDs when sensor is released

   except KeyboardInterrupt:
       # Handle KeyboardInterrupt (Ctrl+C) for a graceful script termination
       pass

**Explication du code**

#. La biblioth√®que ``gpiozero`` est import√©e pour utiliser ses classes ``LED`` et ``Button`` afin d'interagir avec les broches GPIO. La biblioth√®que ``signal`` est import√©e pour la fonction ``pause``, qui est utilis√©e pour maintenir le script en cours d'ex√©cution.

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import LED, Button
       from signal import pause

#. ``speed_sensor`` est d√©fini comme un ``Button`` sur la broche GPIO 17. Le param√®tre ``pull_up=False`` indique que la r√©sistance pull-up interne n'est pas utilis√©e. ``green_led`` et ``red_led`` sont initialis√©s comme des objets ``LED`` connect√©s respectivement aux broches GPIO 27 et 22.

   .. code-block:: python

       # Initialize GPIO pins for the speed sensor and LEDs using GPIO Zero library
       speed_sensor = Button(17, pull_up=False)  # Speed sensor connected to GPIO pin 17 without pull-up
       green_led = LED(27)                      # Green LED connected to GPIO pin 27
       red_led = LED(22)                        # Red LED connected to GPIO pin 22

#. La fonction ``update_leds`` v√©rifie l'√©tat du capteur de vitesse. Si le capteur est press√© (activ√©), elle √©teint la LED verte, allume la LED rouge et imprime un message. Si le capteur est rel√¢ch√©, elle fait l'inverse.

   .. code-block:: python

       def update_leds():
           """
           Update the state of LEDs based on the speed sensor.
           - If the sensor is pressed (triggered), the red LED is turned on and a message is printed.
           - If the sensor is released (not triggered), the green LED is turned on.
           """
           if speed_sensor.is_pressed:
               green_led.off()  # Turn off green LED
               red_led.on()     # Turn on red LED
               print('Light was blocked')  # Print message indicating sensor is triggered
           else:
               green_led.on()   # Turn on green LED
               red_led.off()    # Turn off red LED

#. La boucle principale v√©rifie continuellement l'√©tat du capteur de vitesse. Les attributs ``when_pressed`` et ``when_released`` sont des gestionnaires d'√©v√©nements qui appellent la fonction ``update_leds`` lorsque l'√©tat du capteur change. Le bloc try-except est utilis√© pour g√©rer une interruption clavier (KeyboardInterrupt) pour une sortie propre.

   .. code-block:: python

       try:
           # Main loop to continuously check sensor state
           while True:
               # Update LEDs based on sensor state changes
               speed_sensor.when_pressed = update_leds   # Update LEDs when sensor is pressed
               speed_sensor.when_released = update_leds  # Update LEDs when sensor is released

       except KeyboardInterrupt:
           # Handle KeyboardInterrupt (Ctrl+C) for a graceful script termination
           pass