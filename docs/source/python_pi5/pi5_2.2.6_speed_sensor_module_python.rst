.. note::

    Ciao, benvenuto nella Community di SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts su Facebook! Approfondisci le tue conoscenze su Raspberry Pi, Arduino ed ESP32 insieme ad altri appassionati.

    **Perch√© Unirsi?**

    - **Supporto Tecnico Esperto**: Risolvi i problemi post-vendita e affronta le sfide tecniche con l'aiuto della nostra comunit√† e del nostro team.
    - **Impara e Condividi**: Scambia suggerimenti e tutorial per migliorare le tue competenze.
    - **Anteprime Esclusive**: Ottieni accesso anticipato agli annunci di nuovi prodotti e anteprime.
    - **Sconti Speciali**: Approfitta di sconti esclusivi sui nostri prodotti pi√π recenti.
    - **Promozioni Festive e Giveaway**: Partecipa a giveaway e promozioni festive.

    üëâ Sei pronto a esplorare e creare con noi? Clicca [|link_sf_facebook|] e unisciti oggi stesso!

.. _2.2.6_py_pi5:

2.2.6 Modulo Sensore di Velocit√†
==================================

Introduzione
---------------

In questo progetto, impareremo ad usare il modulo sensore di velocit√†. Il sensore di velocit√† √® un tipo di tachimetro utilizzato per misurare la velocit√† di un oggetto rotante come un motore.

Componenti Necessari
----------------------

In questo progetto, abbiamo bisogno dei seguenti componenti.

.. image:: ../python_pi5/img/2.2.6_photo_interrrupter_list.png
    :width: 700
    :align: center

√à decisamente conveniente acquistare un kit completo, ecco il link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nome	
        - COMPONENTI NEL KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Puoi anche acquistarli separatamente dai link sottostanti.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUZIONE AI COMPONENTI
        - LINK PER L'ACQUISTO

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_speed_sensor`
        - \-

Schema Elettrico
-------------------

.. image:: ../python_pi5/img/2.2.6_photo_interrrupter_schematic.png
    :width: 400
    :align: center

Procedure Sperimentali
-------------------------

**Passo 1:** Costruisci il circuito.

.. image:: ../python_pi5/img/2.2.6_photo_interrrupter_circuit.png
    :width: 700
    :align: center

**Passo 2:** Cambia directory.

.. raw:: html

   <run></run>

.. code-block::
    
    cd ~/raphael-kit/python-pi5

**Passo 3:** Esegui.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.2.6_speed_sensor_module_zero.py

Dopo aver eseguito il codice, il LED verde si accender√†. Se posizioni un 
ostacolo nella fessura del modulo sensore di velocit√†, sullo schermo verr√† 
stampato "luce bloccata" e il LED rosso si accender√†.
Rimuovi l'ostacolo e il LED verde si riaccender√†.

**Codice**

.. note::

    Puoi **Modificare/Resettare/Copiare/Eseguire/Fermare** il codice qui sotto. 
    Ma prima, devi andare al percorso sorgente del codice come ``raphael-kit/python-pi5``. 
    Dopo aver modificato il codice, puoi eseguirlo direttamente per vedere l'effetto.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import LED, Button
   from signal import pause

   # Inizializza i pin GPIO per il sensore di velocit√† e i LED utilizzando la libreria GPIO Zero
   speed_sensor = Button(17, pull_up=False)  # Sensore di velocit√† collegato al pin GPIO 17 senza pull-up
   green_led = LED(27)                      # LED verde collegato al pin GPIO 27
   red_led = LED(22)                        # LED rosso collegato al pin GPIO 22

   def update_leds():
       """
       Update the state of LEDs based on the speed sensor.
       - If the sensor is pressed (triggered), the red LED is turned on and a message is printed.
       - If the sensor is released (not triggered), the green LED is turned on.
       """
       if speed_sensor.is_pressed:
           green_led.off()  # Spegni il LED verde
           red_led.on()     # Accendi il LED rosso
           print('Light was blocked')  # Stampa il messaggio che indica che il sensore √® attivato
       else:
           green_led.on()   # Accendi il LED verde
           red_led.off()    # Spegni il LED rosso

   try:
       # Loop principale per controllare continuamente lo stato del sensore
       while True:
           # Aggiorna i LED in base ai cambiamenti dello stato del sensore
           speed_sensor.when_pressed = update_leds   # Aggiorna i LED quando il sensore √® premuto
           speed_sensor.when_released = update_leds  # Aggiorna i LED quando il sensore √® rilasciato

   except KeyboardInterrupt:
       # Gestisce KeyboardInterrupt (Ctrl+C) per una terminazione pulita dello script
       pass


**Spiegazione del Codice**

#. La libreria ``gpiozero`` viene importata per utilizzare le classi ``LED`` e ``Button`` per interagire con i pin GPIO. La libreria ``signal`` viene importata per la funzione ``pause``, utilizzata per mantenere in esecuzione lo script.

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import LED, Button
       from signal import pause

#. Il sensore di velocit√† viene impostato come ``Button`` sul pin GPIO 17. Il parametro ``pull_up=False`` indica che non viene utilizzata la resistenza di pull-up interna. ``green_led`` e ``red_led`` sono inizializzati come oggetti ``LED`` collegati rispettivamente ai pin GPIO 27 e 22.

   .. code-block:: python

       # Inizializza i pin GPIO per il sensore di velocit√† e i LED utilizzando la libreria GPIO Zero
       speed_sensor = Button(17, pull_up=False)  # Sensore di velocit√† collegato al pin GPIO 17 senza pull-up
       green_led = LED(27)                      # LED verde collegato al pin GPIO 27
       red_led = LED(22)                        # LED rosso collegato al pin GPIO 22

#. La funzione ``update_leds`` controlla lo stato del sensore di velocit√†. Se il sensore √® premuto (attivato), spegne il LED verde, accende il LED rosso e stampa un messaggio. Se il sensore √® rilasciato, fa l'opposto.

   .. code-block:: python

       def update_leds():
           """
           Update the state of LEDs based on the speed sensor.
           - If the sensor is pressed (triggered), the red LED is turned on and a message is printed.
           - If the sensor is released (not triggered), the green LED is turned on.
           """
           if speed_sensor.is_pressed:
               green_led.off()  # Spegni il LED verde
               red_led.on()     # Accendi il LED rosso
               print('Light was blocked')  # Stampa il messaggio che indica che il sensore √® attivato
           else:
               green_led.on()   # Accendi il LED verde
               red_led.off()    # Spegni il LED rosso

#. Il loop principale controlla continuamente lo stato del sensore di velocit√†. Gli attributi ``when_pressed`` e ``when_released`` sono gestori di eventi che chiamano la funzione ``update_leds`` quando lo stato del sensore cambia. Il blocco try-except gestisce KeyboardInterrupt per una chiusura pulita.

   .. code-block:: python

       try:
           # Loop principale per controllare continuamente lo stato del sensore
           while True:
               # Aggiorna i LED in base ai cambiamenti dello stato del sensore
               speed_sensor.when_pressed = update_leds   # Aggiorna i LED quando il sensore √® premuto
               speed_sensor.when_released = update_leds  # Aggiorna i LED quando il sensore √® rilasciato

       except KeyboardInterrupt:
           # Gestisce KeyboardInterrupt (Ctrl+C) per una terminazione pulita dello script
           pass
