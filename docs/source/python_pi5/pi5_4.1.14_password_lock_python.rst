.. note::

    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten.

    **Warum beitreten?**

    - **Expertenunterst√ºtzung**: L√∂sen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams.
    - **Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre F√§higkeiten zu verbessern.
    - **Exklusive Vorschauen**: Erhalten Sie fr√ºhzeitigen Zugang zu neuen Produktank√ºndigungen und exklusiven Einblicken.
    - **Spezialrabatte**: Genie√üen Sie exklusive Rabatte auf unsere neuesten Produkte.
    - **Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil.

    üëâ Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!

.. _4.1.14_py_pi5:

4.1.11 Passwortschloss
================================

Einf√ºhrung
-------------

In diesem Projekt verwenden wir ein Tastenfeld und ein LCD, um ein Kombinationsschloss zu erstellen. Das LCD zeigt eine entsprechende Aufforderung an, um Ihr Passwort auf dem Tastenfeld einzugeben. Wenn das Passwort korrekt eingegeben wird, wird ‚ÄûKorrekt‚Äú angezeigt.

Auf Basis dieses Projekts k√∂nnen wir zus√§tzliche elektronische Komponenten hinzuf√ºgen, wie z.B. einen Summer, LEDs und so weiter, um verschiedene experimentelle Ph√§nomene bei der Passworteingabe hinzuzuf√ºgen.

Ben√∂tigte Komponenten
------------------------------

F√ºr dieses Projekt ben√∂tigen wir die folgenden Komponenten.

.. image:: ../python_pi5/img/4.1.14_password_lock_list.png
    :width: 800
    :align: center

Es ist definitiv praktisch, ein ganzes Kit zu kaufen, hier ist der Link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Name	
        - ARTIKEL IN DIESEM KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Sie k√∂nnen sie auch separat √ºber die untenstehenden Links kaufen.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - KOMPONENTENVORSTELLUNG
        - KAUF-LINK

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_i2c_lcd1602`
        - |link_i2clcd1602_buy|
    *   - :ref:`cpn_keypad`
        - \-

Schaltplan
------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO18       Pin 12   1        18
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
GPIO25       Pin 22   6        25
GPIO17       Pin 11   0        17
GPIO27       Pin 13   2        27
GPIO22       Pin 15   3        22
SPIMOSI      Pin 19   12       10
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: ../python_pi5/img/4.1.14_password_lock_schematic.png
   :align: center

Experimentelle Verfahren
----------------------------

**Schritt 1:** Bauen Sie den Schaltkreis.

.. image:: ../python_pi5/img/4.1.14_password_lock_circuit.png

**Schritt 2:** Verzeichnis wechseln.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python-pi5

**Schritt 3:** Ausf√ºhren.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 4.1.14_PasswordLock_zero.py

Nachdem der Code ausgef√ºhrt wurde, wird das Tastenfeld verwendet, um das Passwort: 1984 einzugeben. Wenn auf dem LCD1602 ‚ÄûCORRECT‚Äú erscheint, ist das Passwort korrekt; andernfalls wird ‚ÄûWRONG KEY‚Äú angezeigt.

.. note::

    * Wenn Sie den Fehler ``FileNotFoundError: [Errno 2] No such file or directory: '/dev/i2c-1'`` erhalten, m√ºssen Sie :ref:`i2c_config` zu Rate ziehen, um das I2C zu aktivieren.
    * Wenn der Fehler ``ModuleNotFoundError: No module named 'smbus2'`` auftritt, f√ºhren Sie bitte ``sudo pip3 install smbus2`` aus.
    * Wenn der Fehler ``OSError: [Errno 121] Remote I/O error`` erscheint, bedeutet das, dass das Modul falsch verdrahtet ist oder das Modul defekt ist.
    * Wenn der Code und die Verdrahtung in Ordnung sind, aber das LCD immer noch keinen Inhalt anzeigt, k√∂nnen Sie das Potentiometer auf der R√ºckseite drehen, um den Kontrast zu erh√∂hen.

.. warning::

    Wenn die Fehlermeldung ``RuntimeError: Cannot determine SOC peripheral base address`` angezeigt wird, lesen Sie bitte :ref:`faq_soc`

**Code**

.. note::
    Sie k√∂nnen den untenstehenden Code **Modifizieren/Zur√ºcksetzen/Kopieren/Ausf√ºhren/Stoppen**. Aber davor m√ºssen Sie zum Quellcodepfad wie ``raphael-kit/python-pi5`` gehen. Nachdem Sie den Code modifiziert haben, k√∂nnen Sie ihn direkt ausf√ºhren, um den Effekt zu sehen.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3

   from gpiozero import DigitalOutputDevice, Button
   from time import sleep
   import LCD1602

   class Keypad:
       def __init__(self, rows_pins, cols_pins, keys):
           """
           Initialize the Keypad with specified row and column pins and keys.
           :param rows_pins: List of GPIO pins for the rows.
           :param cols_pins: List of GPIO pins for the columns.
           :param keys: List of keys in the keypad layout.
           """
           self.rows = [DigitalOutputDevice(pin) for pin in rows_pins]  # Row pins setup
           self.cols = [Button(pin, pull_up=False) for pin in cols_pins]  # Column pins setup
           self.keys = keys  # Keypad key layout

       def read(self):
           """
           Read and return a list of keys that are currently pressed.
           :return: List of pressed keys.
           """
           pressed_keys = []
           for i, row in enumerate(self.rows):
               row.on()  # Activate current row
               for j, col in enumerate(self.cols):
                   if col.is_pressed:
                       index = i * len(self.cols) + j
                       pressed_keys.append(self.keys[index])
               row.off()  # Deactivate row after checking
           return pressed_keys

   # Password verification setup
   LENS = 4
   password = ['1', '9', '8', '4']  # Preset password
   testword = ['0', '0', '0', '0']  # User input storage
   keyIndex = 0  # Index for input keys

   def check():
       """
       Check if the entered password matches the preset password.
       :return: 1 if match, 0 otherwise.
       """
       for i in range(LENS):
           if password[i] != testword[i]:
               return 0
       return 1

   def setup():
       """
       Setup the keypad and LCD display.
       """
       global keypad, last_key_pressed
       # Pin configuration for keypad
       rows_pins = [18, 23, 24, 25]
       cols_pins = [10, 22, 27, 17]
       keys = ["1", "2", "3", "A",
               "4", "5", "6", "B",
               "7", "8", "9", "C",
               "*", "0", "#", "D"]

       # Initialize keypad and LCD
       keypad = Keypad(rows_pins, cols_pins, keys)
       last_key_pressed = []
       LCD1602.init(0x27, 1)  # Initialize LCD
       LCD1602.clear()
       LCD1602.write(0, 0, 'WELCOME!')
       LCD1602.write(2, 1, 'Enter password')
       sleep(2)

   def loop():
       """
       Main loop for handling keypad input and password verification.
       """
       global keyIndex, LENS, keypad, last_key_pressed
       while True:
           pressed_keys = keypad.read()
           if pressed_keys and pressed_keys != last_key_pressed:
               if keyIndex < LENS:
                   LCD1602.clear()
                   LCD1602.write(0, 0, "Enter password:")
                   LCD1602.write(15 - keyIndex, 1, pressed_keys[0])
                   testword[keyIndex] = pressed_keys[0]
                   keyIndex += 1

               if keyIndex == LENS:
                   if check() == 0:
                       LCD1602.clear()
                       LCD1602.write(3, 0, "WRONG KEY!")
                       LCD1602.write(0, 1, "please try again")
                   else:
                       LCD1602.clear()
                       LCD1602.write(4, 0, "CORRECT!")
                       LCD1602.write(2, 1, "welcome back")
                   keyIndex = 0  # Reset key index after checking

           last_key_pressed = pressed_keys
           sleep(0.1)

   try:
       setup()
       loop()
   except KeyboardInterrupt:
       LCD1602.clear()  # Clear LCD display on interrupt


**Code-Erkl√§rung**

#. Dieser Abschnitt importiert die notwendigen Bibliotheken f√ºr das Projekt. ``LCD1602`` wird f√ºr das LCD-Display verwendet, ``gpiozero`` stellt Klassen f√ºr LED, Buzzer und Button zur Verf√ºgung, ``ADC0834`` ist f√ºr die Analog-Digital-Umwandlung, und ``time`` sowie ``math`` sind Python-Standardbibliotheken f√ºr zeitbezogene Funktionen und mathematische Operationen.

   .. code-block:: python

       #!/usr/bin/env python3

       import LCD1602
       from gpiozero import LED, Buzzer, Button
       import ADC0834
       import time
       import math

#. Definiert eine benutzerdefinierte Klasse f√ºr die Verwaltung des Keypads. Sie initialisiert das Keypad mit spezifischen Zeilen- und Spaltenpins und bietet eine ``read`` Methode, um gedr√ºckte Tasten zu erkennen.

   .. code-block:: python

       class Keypad:
           def __init__(self, rows_pins, cols_pins, keys):
               """
               Initialize the Keypad with specified row and column pins and keys.
               :param rows_pins: List of GPIO pins for the rows.
               :param cols_pins: List of GPIO pins for the columns.
               :param keys: List of keys in the keypad layout.
               """
               self.rows = [DigitalOutputDevice(pin) for pin in rows_pins]  # Row pins setup
               self.cols = [Button(pin, pull_up=False) for pin in cols_pins]  # Column pins setup
               self.keys = keys  # Keypad key layout

           def read(self):
               """
               Read and return a list of keys that are currently pressed.
               :return: List of pressed keys.
               """
               pressed_keys = []
               for i, row in enumerate(self.rows):
                   row.on()  # Activate current row
                   for j, col in enumerate(self.cols):
                       if col.is_pressed:
                           index = i * len(self.cols) + j
                           pressed_keys.append(self.keys[index])
                   row.off()  # Deactivate row after checking
               return pressed_keys

#. Richtet das Passwort√ºberpr√ºfungssystem ein. ``LENS`` definiert die L√§nge des Passworts. ``password`` ist das voreingestellte korrekte Passwort, w√§hrend ``testword`` verwendet wird, um die Eingabe des Benutzers zu speichern. ``keyIndex`` verfolgt die aktuelle Position in der Eingabe des Benutzers.

   .. code-block:: python

       # Password verification setup
       LENS = 4
       password = ['1', '9', '8', '4']  # Preset password
       testword = ['0', '0', '0', '0']  # User input storage
       keyIndex = 0  # Index for input keys

#. Funktion zum Vergleichen des eingegebenen Passworts (``testword``) mit dem voreingestellten Passwort (``password``) und R√ºckgabe des Ergebnisses.

   .. code-block:: python

       def check():
           """
           Check if the entered password matches the preset password.
           :return: 1 if match, 0 otherwise.
           """
           for i in range(LENS):
               if password[i] != testword[i]:
                   return 0
           return 1

#. Initialisiert das Keypad und das LCD-Display. Zeigt eine Willkommensnachricht und Anweisungen zur Passworteingabe an.

   .. code-block:: python

       def setup():
           """
           Setup the keypad and LCD display.
           """
           global keypad, last_key_pressed
           # Pin configuration for keypad
           rows_pins = [18, 23, 24, 25]
           cols_pins = [10, 22, 27, 17]
           keys = ["1", "2", "3", "A",
                   "4", "5", "6", "B",
                   "7", "8", "9", "C",
                   "*", "0", "#", "D"]

           # Initialize keypad and LCD
           keypad = Keypad(rows_pins, cols_pins, keys)
           last_key_pressed = []
           LCD1602.init(0x27, 1)  # Initialize LCD
           LCD1602.clear()
           LCD1602.write(0, 0, 'WELCOME!')
           LCD1602.write(2, 1, 'Enter password')
           sleep(2)

#. Die Hauptschleife f√ºr die Verarbeitung der Keypadeingabe und die Passwort√ºberpr√ºfung. Sie aktualisiert das LCD-Display basierend auf dem eingegebenen Passwort und gibt Feedback, ob das Passwort korrekt oder falsch ist.

   .. code-block:: python

       def loop():
           """
           Main loop for handling keypad input and password verification.
           """
           global keyIndex, LENS, keypad, last_key_pressed
           while True:
               pressed_keys = keypad.read()
               if pressed_keys and pressed_keys != last_key_pressed:
                   if keyIndex < LENS:
                       LCD1602.clear()
                       LCD1602.write(0, 0, "Enter password:")
                       LCD1602.write(15 - keyIndex, 1, pressed_keys[0])
                       testword[keyIndex] = pressed_keys[0]
                       keyIndex += 1

                   if keyIndex == LENS:
                       if check() == 0:
                           LCD1602.clear()
                           LCD1602.write(3, 0, "WRONG KEY!")
                           LCD1602.write(0, 1, "please try again")
                       else:
                           LCD1602.clear()
                           LCD1602.write(4, 0, "CORRECT!")
                           LCD1602.write(2, 1, "welcome back")
                       keyIndex = 0  # Reset key index after checking

               last_key_pressed = pressed_keys
               sleep(0.1)

#. F√ºhrt die Einrichtung durch und tritt in die Hauptschleife ein. Erm√∂glicht einen sauberen Ausstieg aus dem Programm mittels Tastaturunterbrechung (Ctrl+C), wobei das LCD-Display gel√∂scht wird.

   .. code-block:: python

       try:
           setup()
           loop()
       except KeyboardInterrupt:
           LCD1602.clear()  # Clear LCD display on interrupt


