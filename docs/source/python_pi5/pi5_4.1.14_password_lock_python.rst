.. note::

    춰Hola, bienvenido a la comunidad de entusiastas de SunFounder Raspberry Pi & Arduino & ESP32 en Facebook! Sum칠rgete m치s en Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **쯇or qu칠 unirte?**

    - **Soporte Experto**: Resuelve problemas postventa y desaf칤os t칠cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprende y Comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Preestrenos Exclusivos**: Obt칠n acceso anticipado a anuncios de nuevos productos y avances exclusivos.
    - **Descuentos Especiales**: Disfruta de descuentos exclusivos en nuestros productos m치s recientes.
    - **Promociones y Sorteos Festivos**: Participa en sorteos y promociones de temporada.

    游녤 쯃isto para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y 칰nete hoy mismo!

.. _4.1.14_py_pi5:

4.1.11 Cerradura de Contrase침a
================================

Introducci칩n
-------------

En este proyecto, usaremos un teclado y una pantalla LCD para hacer una 
cerradura de combinaci칩n. La pantalla LCD mostrar치 un mensaje correspondiente 
para que escribas tu contrase침a en el teclado. Si la contrase침a se ingresa 
correctamente, se mostrar치 "Correcto".

Sobre la base de este proyecto, podemos agregar componentes electr칩nicos 
adicionales, como zumbadores, LED y otros, para a침adir diferentes fen칩menos 
experimentales para la entrada de contrase침a.

Componentes Necesarios
------------------------------

En este proyecto, necesitamos los siguientes componentes.

.. image:: ../python_pi5/img/4.1.14_password_lock_list.png
    :width: 800
    :align: center

Es definitivamente conveniente comprar un kit completo, aqu칤 est치 el enlace: 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre	
        - ART칈CULOS EN ESTE KIT
        - ENLACE
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Tambi칠n puedes comprarlos por separado en los enlaces a continuaci칩n.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCI칍N DEL COMPONENTE
        - ENLACE DE COMPRA

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_i2c_lcd`
        - |link_i2clcd1602_buy|
    *   - :ref:`cpn_keypad`
        - \-

Diagrama Esquem치tico
------------------------

============== ====== ======== ===
Nombre T-Board f칤sica WiringPi BCM
GPIO18         Pin 12  1       18
GPIO23         Pin 16  4       23
GPIO24         Pin 18  5       24
GPIO25         Pin 22  6       25
GPIO17         Pin 11  0       17
GPIO27         Pin 13  2       27
GPIO22         Pin 15  3       22
SPIMOSI        Pin 19  12      10
SDA1           Pin 3             
SCL1           Pin 5             
============== ====== ======== ===

.. image:: ../python_pi5/img/4.1.14_password_lock_schematic.png
   :align: center

Procedimientos Experimentales
--------------------------------------

**Paso 1:** Construye el circuito.

.. image:: ../python_pi5/img/4.1.14_password_lock_circuit.png

**Paso 2:** Cambia de directorio.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python-pi5

**Paso 3:** Ejecuta.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 4.1.14_PasswordLock_zero.py

Despu칠s de ejecutar el c칩digo, el teclado se utilizar치 para ingresar la contrase침a: 1984. 
Si aparece "CORRECT" en el LCD1602, la contrase침a es correcta; de lo contrario, aparecer치 
"WRONG KEY".

.. note::

    * Si obtienes el error ``FileNotFoundError: [Errno 2] No such file or directory: '/dev/i2c-1'``, necesitas consultar :ref:`i2c_config` para habilitar el I2C.
    * Si obtienes el error ``ModuleNotFoundError: No module named 'smbus2'``, por favor ejecuta ``sudo pip3 install smbus2``.
    * Si aparece el error ``OSError: [Errno 121] Remote I/O error``, significa que el m칩dulo est치 mal conectado o est치 da침ado.
    * Si el c칩digo y el cableado est치n bien, pero la pantalla LCD a칰n no muestra contenido, puedes girar el potenci칩metro en la parte trasera para aumentar el contraste.

**C칩digo**

.. note::
    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el c칩digo a continuaci칩n. Pero antes de eso, necesitas ir a la ruta del c칩digo fuente como ``raphael-kit/python-pi5``. Despu칠s de modificar el c칩digo, puedes ejecutarlo directamente para ver el efecto.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3

   from gpiozero import DigitalOutputDevice, Button
   from time import sleep
   import LCD1602

   class Keypad:
       def __init__(self, rows_pins, cols_pins, keys):
           """
           Initialize the Keypad with specified row and column pins and keys.
           :param rows_pins: List of GPIO pins for the rows.
           :param cols_pins: List of GPIO pins for the columns.
           :param keys: List of keys in the keypad layout.
           """
           self.rows = [DigitalOutputDevice(pin) for pin in rows_pins]  # Configuraci칩n de pines de fila
           self.cols = [Button(pin, pull_up=False) for pin in cols_pins]  # Configuraci칩n de pines de columna
           self.keys = keys  # Dise침o de teclas del teclado

       def read(self):
           """
           Read and return a list of keys that are currently pressed.
           :return: List of pressed keys.
           """
           pressed_keys = []
           for i, row in enumerate(self.rows):
               row.on()  # Activa la fila actual
               for j, col in enumerate(self.cols):
                   if col.is_pressed:
                       index = i * len(self.cols) + j
                       pressed_keys.append(self.keys[index])
               row.off()  # Desactiva la fila despu칠s de comprobar
           return pressed_keys

   # Configuraci칩n de verificaci칩n de contrase침a
   LENS = 4
   password = ['1', '9', '8', '4']  # Contrase침a preestablecida
   testword = ['0', '0', '0', '0']  # Almacenamiento de entrada del usuario
   keyIndex = 0  # 칈ndice para teclas de entrada

   def check():
       """
       Check if the entered password matches the preset password.
       :return: 1 if match, 0 otherwise.
       """
       for i in range(LENS):
           if password[i] != testword[i]:
               return 0
       return 1

   def setup():
       """
       Setup the keypad and LCD display.
       """
       global keypad, last_key_pressed
       # Configuraci칩n de pines para el teclado
       rows_pins = [18, 23, 24, 25]
       cols_pins = [10, 22, 27, 17]
       keys = ["1", "2", "3", "A",
               "4", "5", "6", "B",
               "7", "8", "9", "C",
               "*", "0", "#", "D"]

       # Inicializa el teclado y la LCD
       keypad = Keypad(rows_pins, cols_pins, keys)
       last_key_pressed = []
       LCD1602.init(0x27, 1)  # Inicializa la LCD
       LCD1602.clear()
       LCD1602.write(0, 0, 'WELCOME!')
       LCD1602.write(2, 1, 'Enter password')
       sleep(2)

   def loop():
       """
       Main loop for handling keypad input and password verification.
       """
       global keyIndex, LENS, keypad, last_key_pressed
       while True:
           pressed_keys = keypad.read()
           if pressed_keys and pressed_keys != last_key_pressed:
               if keyIndex < LENS:
                   LCD1602.clear()
                   LCD1602.write(0, 0, "Enter password:")
                   LCD1602.write(15 - keyIndex, 1, pressed_keys[0])
                   testword[keyIndex] = pressed_keys[0]
                   keyIndex += 1

               if keyIndex == LENS:
                   if check() == 0:
                       LCD1602.clear()
                       LCD1602.write(3, 0, "WRONG KEY!")
                       LCD1602.write(0, 1, "please try again")
                   else:
                       LCD1602.clear()
                       LCD1602.write(4, 0, "CORRECT!")
                       LCD1602.write(2, 1, "welcome back")
                   keyIndex = 0  # Restablecer el 칤ndice de teclas despu칠s de verificar

           last_key_pressed = pressed_keys
           sleep(0.1)

   try:
       setup()
       loop()
   except KeyboardInterrupt:
       LCD1602.clear()  # Limpiar pantalla LCD al interrumpir


Explicaci칩n del C칩digo
--------------------------

#. El script importa clases para manejar dispositivos de salida digital y botones de la biblioteca gpiozero. Tambi칠n importa la funci칩n sleep del m칩dulo time, lo que permite a침adir retrasos en la ejecuci칩n del script. Adicionalmente, se importa la biblioteca LCD1602 para controlar la pantalla LCD1602.

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import DigitalOutputDevice, Button
       from time import sleep
       import LCD1602

#. Define una clase personalizada para manejar el teclado. Inicializa el teclado con los pines de filas y columnas especificados y proporciona un m칠todo ``read`` para detectar las teclas presionadas.

   .. code-block:: python

       class Keypad:
           def __init__(self, rows_pins, cols_pins, keys):
               """
               Initialize the Keypad with specified row and column pins and keys.
               :param rows_pins: List of GPIO pins for the rows.
               :param cols_pins: List of GPIO pins for the columns.
               :param keys: List of keys in the keypad layout.
               """
               self.rows = [DigitalOutputDevice(pin) for pin in rows_pins]  # Configuraci칩n de pines de fila
               self.cols = [Button(pin, pull_up=False) for pin in cols_pins]  # Configuraci칩n de pines de columna
               self.keys = keys  # Dise침o de teclas del teclado

           def read(self):
               """
               Read and return a list of keys that are currently pressed.
               :return: List of pressed keys.
               """
               pressed_keys = []
               for i, row in enumerate(self.rows):
                   row.on()  # Activa la fila actual
                   for j, col in enumerate(self.cols):
                       if col.is_pressed:
                           index = i * len(self.cols) + j
                           pressed_keys.append(self.keys[index])
                   row.off()  # Desactiva la fila despu칠s de comprobar
               return pressed_keys

#. Configura el sistema de verificaci칩n de contrase침a. ``LENS`` define la longitud de la contrase침a. ``password`` es la contrase침a correcta preestablecida, mientras que ``testword`` se usa para almacenar la entrada del usuario. ``keyIndex`` rastrea la posici칩n actual en la entrada del usuario.

   .. code-block:: python

       # Configuraci칩n de verificaci칩n de contrase침a
       LENS = 4
       password = ['1', '9', '8', '4']  # Contrase침a preestablecida
       testword = ['0', '0', '0', '0']  # Almacenamiento de entrada del usuario
       keyIndex = 0  # 칈ndice para teclas de entrada

#. Funci칩n para comparar la contrase침a ingresada (``testword``) con la contrase침a preestablecida (``password``) y devolver el resultado.

   .. code-block:: python

       def check():
           """
           Check if the entered password matches the preset password.
           :return: 1 if match, 0 otherwise.
           """
           for i in range(LENS):
               if password[i] != testword[i]:
                   return 0
           return 1

#. Inicializa el teclado y la pantalla LCD. Muestra un mensaje de bienvenida e instrucciones para ingresar la contrase침a.

   .. code-block:: python

       def setup():
           """
           Setup the keypad and LCD display.
           """
           global keypad, last_key_pressed
           # Configuraci칩n de pines para el teclado
           rows_pins = [18, 23, 24, 25]
           cols_pins = [10, 22, 27, 17]
           keys = ["1", "2", "3", "A",
                   "4", "5", "6", "B",
                   "7", "8", "9", "C",
                   "*", "0", "#", "D"]

           # Inicializa el teclado y la LCD
           keypad = Keypad(rows_pins, cols_pins, keys)
           last_key_pressed = []
           LCD1602.init(0x27, 1)  # Inicializa la LCD
           LCD1602.clear()
           LCD1602.write(0, 0, 'WELCOME!')
           LCD1602.write(2, 1, 'Enter password')
           sleep(2)

#. El bucle principal para manejar la entrada del teclado y la verificaci칩n de la contrase침a. Actualiza la pantalla LCD seg칰n la contrase침a ingresada y proporciona retroalimentaci칩n si la contrase침a es correcta o incorrecta.

   .. code-block:: python

       def loop():
           """
           Main loop for handling keypad input and password verification.
           """
           global keyIndex, LENS, keypad, last_key_pressed
           while True:
               pressed_keys = keypad.read()
               if pressed_keys and pressed_keys != last_key_pressed:
                   if keyIndex < LENS:
                       LCD1602.clear()
                       LCD1602.write(0, 0, "Enter password:")
                       LCD1602.write(15 - keyIndex, 1, pressed_keys[0])
                       testword[keyIndex] = pressed_keys[0]
                       keyIndex += 1

                   if keyIndex == LENS:
                       if check() == 0:
                           LCD1602.clear()
                           LCD1602.write(3, 0, "WRONG KEY!")
                           LCD1602.write(0, 1, "please try again")
                       else:
                           LCD1602.clear()
                           LCD1602.write(4, 0, "CORRECT!")
                           LCD1602.write(2, 1, "welcome back")
                       keyIndex = 0  # Restablecer el 칤ndice de teclas despu칠s de verificar

               last_key_pressed = pressed_keys
               sleep(0.1)

#. Ejecuta la configuraci칩n y entra en el bucle principal. Permite una salida limpia del programa utilizando una interrupci칩n de teclado (Ctrl+C), limpiando la pantalla LCD.

   .. code-block:: python

       try:
           setup()
           loop()
       except KeyboardInterrupt:
           LCD1602.clear()  # Limpiar pantalla LCD al interrumpir

