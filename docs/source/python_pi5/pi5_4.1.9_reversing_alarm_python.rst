.. note::

    隆Hola, bienvenido a la comunidad de entusiastas de SunFounder Raspberry Pi & Arduino & ESP32 en Facebook! Sum茅rgete m谩s en Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **驴Por qu茅 unirte?**

    - **Soporte Experto**: Resuelve problemas post-venta y desaf铆os t茅cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprende y Comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Preestrenos Exclusivos**: Obt茅n acceso anticipado a anuncios de nuevos productos y avances.
    - **Descuentos Especiales**: Disfruta de descuentos exclusivos en nuestros productos m谩s recientes.
    - **Promociones y Sorteos Festivos**: Participa en sorteos y promociones de temporada.

     驴Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y 煤nete hoy mismo.

.. _4.1.9_py_pi5:

4.1.6 Alarma de Reversa
======================================

Introducci贸n
------------------

En este proyecto, usaremos una pantalla LCD, un zumbador y sensores ultras贸nicos 
para crear un sistema de asistencia de reversa. Podemos colocarlo en un veh铆culo 
controlado a distancia para simular el proceso real de reversa de un autom贸vil en el garaje.

Componentes Necesarios
------------------------------

En este proyecto, necesitamos los siguientes componentes.

.. image:: ../python_pi5/img/4.1.9_reversing_alarm_list.png
    :width: 800
    :align: center

Es definitivamente conveniente comprar un kit completo, aqu铆 est谩 el enlace: 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre	
        - ARTCULOS EN ESTE KIT
        - ENLACE
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Tambi茅n puedes comprarlos por separado desde los enlaces a continuaci贸n.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCIN DEL COMPONENTE
        - ENLACE DE COMPRA

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_buzzer`
        - \-
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|
    *   - :ref:`cpn_ultrasonic_sensor`
        - |link_ultrasonic_buy|
    *   - :ref:`cpn_i2c_lcd`
        - |link_i2clcd1602_buy|

Diagrama Esquem谩tico
---------------------------

El sensor ultras贸nico detecta la distancia entre 茅l y el obst谩culo, la cual se 
mostrar谩 en la pantalla LCD en forma de c贸digo. Al mismo tiempo, el sensor ultras贸nico 
hace que el zumbador emita un sonido de advertencia de diferente frecuencia seg煤n el 
valor de la distancia.

============== ====== ======== ===
Nombre T-Board f铆sica WiringPi BCM
GPIO23         Pin 16 4        23
GPIO24         Pin 18 5        24
GPIO17         Pin 11 0        17
SDA1           Pin 3             
SCL1           Pin 5             
============== ====== ======== ===

.. image:: ../python_pi5/img/4.1.9_reversing_alarm_schematic.png
   :align: center

Procedimientos Experimentales
---------------------------------

**Paso 1:** Construye el circuito.

.. image:: ../python_pi5/img/4.1.9_reversing_alarm_circuit.png
    :align: center

**Paso 2:** Cambia de directorio.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python-pi5

**Paso 3:** Ejecuta.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 4.1.9_ReversingAlarm_zero.py

A medida que se ejecuta el c贸digo, el m贸dulo del sensor ultras贸nico detecta la 
distancia al obst谩culo y luego muestra la informaci贸n sobre la distancia en el 
LCD1602; adem谩s, el zumbador emite un tono de advertencia cuya frecuencia cambia 
con la distancia.

.. note::

    * Si obtienes el error ``FileNotFoundError: [Errno 2] No such file or directory: '/dev/i2c-1'``, necesitas referirte a :ref:`i2c_config` para habilitar el I2C.
    * Si obtienes el error ``ModuleNotFoundError: No module named 'smbus2'``, por favor ejecuta ``sudo pip3 install smbus2``.
    * Si aparece el error ``OSError: [Errno 121] Remote I/O error``, significa que el m贸dulo est谩 mal conectado o est谩 da帽ado.
    * Si el c贸digo y el cableado est谩n bien, pero la pantalla LCD a煤n no muestra contenido, puedes girar el potenci贸metro en la parte trasera para aumentar el contraste.

.. warning::

    Si recibe el mensaje de error ``RuntimeError: Cannot determine SOC peripheral base address``, consulte :ref:`faq_soc`

**C贸digo**

.. note::
    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el c贸digo a continuaci贸n. Pero antes de eso, necesitas ir a la ruta del c贸digo fuente como ``raphael-kit/python-pi5``. Despu茅s de modificar el c贸digo, puedes ejecutarlo directamente para ver el efecto.

.. raw:: html

    <run></run>

.. code-block:: python

    #!/usr/bin/env python3
    import LCD1602
    import time
    from gpiozero import DistanceSensor, Buzzer

    # Inicializar el sensor ultras贸nico con pines GPIO
    sensor = DistanceSensor(echo=24, trigger=23)  # El pin Echo es GPIO 24, el pin Trigger es GPIO 23

    # Inicializar el zumbador conectado al pin GPIO 17
    buzzer = Buzzer(17)

    def lcdsetup():
        # Inicializar la pantalla LCD con direcci贸n I2C y habilitar la luz de fondo
        LCD1602.init(0x27, 1)  # 0x27 es la direcci贸n I2C de la pantalla LCD
        LCD1602.clear()  # Limpiar la pantalla LCD
        # Mostrar mensajes de inicio en la pantalla LCD
        LCD1602.write(0, 0, 'Ultrasonic Starting')
        LCD1602.write(1, 1, 'By SunFounder')
        time.sleep(2)  # Esperar 2 segundos

    def distance():
        # Calcular y devolver la distancia medida por el sensor
        dis = sensor.distance * 100  # Convertir distancia a cent铆metros
        print('Distance: {:.2f} cm'.format(dis))  # Imprimir distancia con dos decimales
        time.sleep(0.3)  # Esperar 0.3 segundos antes de la siguiente medici贸n
        return dis

    def loop():
        # Medir continuamente la distancia y actualizar la pantalla LCD y el zumbador
        while True:
            dis = distance()  # Obtener la distancia actual
            # Mostrar la distancia y manejar las alertas basadas en la distancia
            if dis > 400:  # Comprobar si la distancia est谩 fuera de rango
                LCD1602.clear()
                LCD1602.write(0, 0, 'Error')
                LCD1602.write(3, 1, 'Out of range')
                time.sleep(0.5)
            else:
                # Mostrar la distancia actual en la pantalla LCD
                LCD1602.clear()
                LCD1602.write(0, 0, 'Distance is')
                LCD1602.write(5, 1, str(round(dis, 2)) + ' cm')
                # Ajustar la frecuencia del zumbador seg煤n la distancia
                if dis >= 50:
                    time.sleep(0.5)
                elif 20 < dis < 50:
                    # Distancia media: frecuencia media del zumbador
                    for _ in range(2):
                        buzzer.on()
                        time.sleep(0.05)
                        buzzer.off()
                        time.sleep(0.2)
                elif dis <= 20:
                    # Distancia cercana: alta frecuencia del zumbador
                    for _ in range(5):
                        buzzer.on()
                        time.sleep(0.05)
                        buzzer.off()
                        time.sleep(0.05)

    try:
        lcdsetup()  # Configurar la pantalla LCD
        loop()      # Iniciar el bucle de medici贸n
    except KeyboardInterrupt:
        # Apagar el zumbador y limpiar la pantalla LCD en caso de interrupci贸n del usuario (por ejemplo, Ctrl+C)
        buzzer.off()
    LCD1602.clear()



**Explicaci贸n del C贸digo**

#. Este script utiliza varias bibliotecas para su funcionalidad. La biblioteca ``LCD1602`` gestiona la pantalla LCD, mientras que ``time`` proporciona funciones relacionadas con el tiempo. La biblioteca ``gpiozero`` es esencial para las interacciones con los pines GPIO de Raspberry Pi, particularmente para operar el DistanceSensor y el Buzzer.

   .. code-block:: python

       #!/usr/bin/env python3
       import LCD1602
       import time
       from gpiozero import DistanceSensor, Buzzer

#. El sensor ultras贸nico se configura con sus pines de eco y disparo conectados a los pines GPIO 24 y 23, respectivamente. Adem谩s, un zumbador est谩 conectado al pin GPIO 17.

   .. code-block:: python

       # Inicializar el sensor ultras贸nico con pines GPIO
       sensor = DistanceSensor(echo=24, trigger=23)  # El pin Echo es GPIO 24, el pin Trigger es GPIO 23

       # Inicializar el zumbador conectado al pin GPIO 17
       buzzer = Buzzer(17)

#. La inicializaci贸n de la pantalla LCD implica limpiarla y mostrar un mensaje de inicio.

   .. code-block:: python

       def lcdsetup():
           # Inicializar la pantalla LCD con direcci贸n I2C y habilitar la luz de fondo
           LCD1602.init(0x27, 1)  # 0x27 es la direcci贸n I2C de la pantalla LCD
           LCD1602.clear()  # Limpiar la pantalla LCD
           # Mostrar mensajes de inicio en la pantalla LCD
           LCD1602.write(0, 0, 'Ultrasonic Starting')
           LCD1602.write(1, 1, 'By SunFounder')
           time.sleep(2)  # Esperar 2 segundos

#. La funci贸n ``distance`` calcula la distancia medida por el sensor ultras贸nico y la muestra, devolviendo el valor en cent铆metros.

   .. code-block:: python

       def distance():
           # Calcular y devolver la distancia medida por el sensor
           dis = sensor.distance * 100  # Convertir distancia a cent铆metros
           print('Distance: {:.2f} cm'.format(dis))  # Imprimir distancia con dos decimales
           time.sleep(0.3)  # Esperar 0.3 segundos antes de la siguiente medici贸n
           return dis

#. El bucle principal mide continuamente la distancia, actualizando tanto la pantalla LCD como el zumbador. Maneja diferentes rangos de distancia con acciones espec铆ficas, como mostrar mensajes de error o variar las frecuencias del zumbador seg煤n la distancia medida.

   .. code-block:: python

       def loop():
           # Medir continuamente la distancia y actualizar la pantalla LCD y el zumbador
           while True:
               dis = distance()  # Obtener la distancia actual
               # Mostrar la distancia y manejar las alertas basadas en la distancia
               if dis > 400:  # Comprobar si la distancia est谩 fuera de rango
                   LCD1602.clear()
                   LCD1602.write(0, 0, 'Error')
                   LCD1602.write(3, 1, 'Out of range')
                   time.sleep(0.5)
               else:
                   # Mostrar la distancia actual en la pantalla LCD
                   LCD1602.clear()
                   LCD1602.write(0, 0, 'Distance is')
                   LCD1602.write(5, 1, str(round(dis, 2)) + ' cm')
                   # Ajustar la frecuencia del zumbador seg煤n la distancia
                   if dis >= 50:
                       time.sleep(0.5)
                   elif 20 < dis < 50:
                       # Distancia media: frecuencia media del zumbador
                       for _ in range(2):
                           buzzer.on()
                           time.sleep(0.05)
                           buzzer.off()
                           time.sleep(0.2)
                   elif dis <= 20:
                       # Distancia cercana: alta frecuencia del zumbador
                       for _ in range(5):
                           buzzer.on()
                           time.sleep(0.05)
                           buzzer.off()
                           time.sleep(0.05)

#. Al ejecutarse, el script configura la pantalla LCD y entra en el bucle principal. Puede ser interrumpido con un comando de teclado (Ctrl+C), que apaga el zumbador y limpia la pantalla LCD.

   .. code-block:: python

       try:
           lcdsetup()  # Configurar la pantalla LCD
           loop()      # Iniciar el bucle de medici贸n
       except KeyboardInterrupt:
           # Apagar el zumbador y limpiar la pantalla LCD en caso de interrupci贸n del usuario (por ejemplo, Ctrl+C)
           buzzer.off()
           LCD1602.clear()
