.. nota::

    ¬°Hola! Bienvenido a la comunidad de entusiastas de SunFounder Raspberry Pi & Arduino & ESP32 en Facebook. Sum√©rgete en el mundo de Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **¬øPor qu√© unirse?**

    - **Soporte experto**: Resuelve problemas postventa y desaf√≠os t√©cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprende y comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Vistas previas exclusivas**: Obt√©n acceso anticipado a anuncios de nuevos productos y adelantos.
    - **Descuentos especiales**: Disfruta de descuentos exclusivos en nuestros productos m√°s recientes.
    - **Promociones festivas y sorteos**: Participa en sorteos y promociones festivas.

    üëâ ¬øListo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y √∫nete hoy.

.. _4.1.7_py_pi5:

4.1.4 Dispositivo de Conteo
=================================

Introducci√≥n
---------------------

Aqu√≠ haremos un sistema contador con pantalla num√©rica, que consiste en un sensor PIR 
y una pantalla de 4 d√≠gitos. Cuando el PIR detecta que alguien pasa, el n√∫mero en la 
pantalla de 4 d√≠gitos aumentar√° en 1. Puedes usar este contador para contar el n√∫mero 
de personas que pasan por el pasillo.


Componentes Necesarios
--------------------------------

En este proyecto, necesitamos los siguientes componentes.

.. image:: ../python_pi5/img/4.1.7_counting_device_list_1.png
    :align: center

.. image:: ../python_pi5/img/4.1.7_counting_device_list_2.png
    :align: center

Es definitivamente conveniente comprar un kit completo, aqu√≠ est√° el enlace:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre	
        - ITEMS IN THIS KIT
        - ENLACE
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Tambi√©n puedes comprarlos por separado en los enlaces a continuaci√≥n.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCI√ìN DEL COMPONENTE
        - ENLACE DE COMPRA

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_4_digit`
        - \-
    *   - :ref:`cpn_74hc595`
        - |link_74hc595_buy|
    *   - :ref:`cpn_pir`
        - \-


Diagrama Esquem√°tico
--------------------------

============== ======== ======== ===
Nombre T-Board  f√≠sico  wiringPi BCM
GPIO17         Pin 11   0        17
GPIO27         Pin 13   2        27
GPIO22         Pin 15   3        22
SPIMOSI        Pin 19   12       10
GPIO18         Pin 12   1        18
GPIO23         Pin 16   4        23
GPIO24         Pin 18   5        24
GPIO26         Pin 37   25       26
============== ======== ======== ===

.. image:: ../python_pi5/img/4.1.7_counting_device_schematic.png
   :align: center

Procedimientos Experimentales
-------------------------------------

**Paso 1**: Construir el circuito.

.. image:: ../python_pi5/img/4.1.7_counting_device_circuit.png


**Paso 2**: Ir a la carpeta del c√≥digo.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python-pi5

**Paso 3**: Ejecutar el archivo ejecutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 4.1.7_CountingDevice_zero.py

Despu√©s de ejecutar el c√≥digo, cuando el PIR detecte que alguien est√° pasando, el n√∫mero en la pantalla de 4 d√≠gitos aumentar√° en 1.

Hay dos potenci√≥metros en el m√≥dulo PIR: uno para ajustar la sensibilidad y otro para ajustar la distancia de detecci√≥n. Para que el m√≥dulo PIR funcione mejor, debes girar ambos completamente en sentido antihorario.

.. image:: ../python_pi5/img/4.1.7_PIR_TTE.png
    :width: 400
    :align: center

.. warning::

    Si recibe el mensaje de error ``RuntimeError: Cannot determine SOC peripheral base address``, consulte :ref:`faq_soc`

**C√≥digo**

.. nota::
    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el c√≥digo a continuaci√≥n. Pero antes de eso, necesitas ir a la ruta del c√≥digo fuente como ``raphael-kit/python-pi5``. Despu√©s de modificar el c√≥digo, puedes ejecutarlo directamente para ver el efecto.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import OutputDevice, MotionSensor

   # Inicializar el sensor de movimiento PIR en GPIO 26
   pir = MotionSensor(26)

   # Inicializar los pines del registro de desplazamiento
   SDI = OutputDevice(24)    # Entrada de Datos Seriales
   RCLK = OutputDevice(23)   # Entrada del Reloj del Registro
   SRCLK = OutputDevice(18)  # Entrada del Reloj del Registro de Desplazamiento

   # Inicializar los pines de la pantalla de 7 segmentos
   placePin = [OutputDevice(pin) for pin in (10, 22, 27, 17)]

   # Definir c√≥digos de d√≠gitos para la pantalla de 7 segmentos
   number = (0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90)

   # Contador para el n√∫mero mostrado
   counter = 0

   def clearDisplay():
       # Borra la pantalla apagando todos los segmentos
       for _ in range(8):
           SDI.on()
           SRCLK.on()
           SRCLK.off()
       RCLK.on()
       RCLK.off()

   def hc595_shift(data):
       # Desplaza los datos en el registro de desplazamiento 74HC595
       for i in range(8):
           SDI.value = 0x80 & (data << i)
           SRCLK.on()
           SRCLK.off()
       RCLK.on()
       RCLK.off()

   def pickDigit(digit):
       # Activa un d√≠gito espec√≠fico de la pantalla de 7 segmentos
       for pin in placePin:
           pin.off()
       placePin[digit].on()

   def display():
       # Actualiza la pantalla con el valor actual del contador
       global counter
       clearDisplay()
       pickDigit(0)
       hc595_shift(number[counter % 10])

       clearDisplay()
       pickDigit(1)
       hc595_shift(number[counter % 100//10])

       clearDisplay()
       pickDigit(2)
       hc595_shift(number[counter % 1000//100])

       clearDisplay()
       pickDigit(3)
       hc595_shift(number[counter % 10000//1000])

   def loop():
       # Bucle principal para actualizar la pantalla y comprobar el movimiento
       global counter
       currentState = 0
       lastState = 0
       while True:
           display()
           currentState = 1 si pir.motion_detected else 0
           if currentState == 1 y lastState == 0:
               counter += 1
           lastState = currentState

   try:
       loop()
   except KeyboardInterrupt:
       # Apaga todos los pines cuando se interrumpe el script
       SDI.off()
       SRCLK.off()
       RCLK.off()
       pass


**Explicaci√≥n del C√≥digo**

#. Esta l√≠nea importa las clases ``OutputDevice`` y ``MotionSensor`` de la biblioteca ``gpiozero``. ``OutputDevice`` puede ser un LED, motor, o cualquier dispositivo que desees controlar como salida. El ``MotionSensor`` es t√≠picamente un sensor PIR (Infrarrojo Pasivo) utilizado para detectar movimiento.

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import OutputDevice, MotionSensor

#. Inicializa el sensor de movimiento PIR conectado al pin GPIO 26.

   .. code-block:: python

       # Inicializar el sensor de movimiento PIR en GPIO 26
       pir = MotionSensor(26)

#. Inicializa los pines GPIO conectados a la Entrada de Datos Seriales (SDI), Entrada del Reloj del Registro (RCLK) y Entrada del Reloj del Registro de Desplazamiento (SRCLK) del registro de desplazamiento.

   .. code-block:: python

       # Inicializar los pines del registro de desplazamiento
       SDI = OutputDevice(24)    # Entrada de Datos Seriales
       RCLK = OutputDevice(23)   # Entrada del Reloj del Registro
       SRCLK = OutputDevice(18)  # Entrada del Reloj del Registro de Desplazamiento

#. Inicializa los pines para cada d√≠gito de la pantalla de 7 segmentos y define los c√≥digos binarios para mostrar los n√∫meros del 0 al 9.

   .. code-block:: python

       # Inicializar los pines de la pantalla de 7 segmentos
       placePin = [OutputDevice(pin) for pin in (10, 22, 27, 17)]

       # Definir c√≥digos de d√≠gitos para la pantalla de 7 segmentos
       number = (0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90)

#. Borra la pantalla de 7 segmentos apagando todos los segmentos antes de mostrar el siguiente d√≠gito.

   .. code-block:: python

       def clearDisplay():
           # Borra la pantalla apagando todos los segmentos
           for _ in range(8):
               SDI.on()
               SRCLK.on()
               SRCLK.off()
           RCLK.on()
           RCLK.off()

#. Desplaza un byte de datos en el registro de desplazamiento 74HC595, controlando los segmentos de la pantalla.

   .. code-block:: python

       def hc595_shift(data):
           # Desplaza los datos en el registro de desplazamiento 74HC595
           for i in range(8):
               SDI.value = 0x80 & (data << i)
               SRCLK.on()
               SRCLK.off()
           RCLK.on()
           RCLK.off()

#. Selecciona qu√© d√≠gito de la pantalla de 7 segmentos activar. Cada d√≠gito es controlado por un pin GPIO separado.

   .. code-block:: python

       def pickDigit(digit):
           # Activa un d√≠gito espec√≠fico de la pantalla de 7 segmentos
           for pin in placePin:
               pin.off()
           placePin[digit].on()

#. Inicia la pantalla para el d√≠gito de las unidades primero, seguido de la activaci√≥n de la pantalla para el d√≠gito de las decenas. Posteriormente, activa las pantallas para los d√≠gitos de las centenas y los millares en orden. Esta r√°pida sucesi√≥n de activaciones crea la ilusi√≥n de una pantalla de cuatro d√≠gitos continua.

   .. code-block:: python

       def display():
           # Actualiza la pantalla con el valor actual del contador
           global counter
           clearDisplay()
           pickDigit(0)
           hc595_shift(number[counter % 10])

           clearDisplay()
           pickDigit(1)
           hc595_shift(number[counter % 100//10])

           clearDisplay()
           pickDigit(2)
           hc595_shift(number[counter % 1000//100])

           clearDisplay()
           pickDigit(3)
           hc595_shift(number[counter % 10000//1000])

#. Define el bucle principal donde se actualiza continuamente la pantalla y se verifica el estado del sensor PIR. Si se detecta movimiento, el contador se incrementa.

   .. code-block:: python

       def loop():
           # Bucle principal para actualizar la pantalla y comprobar el movimiento
           global counter
           currentState = 0
           lastState = 0
           while True:
               display()
               currentState = 1 si pir.motion_detected else 0
               if currentState == 1 y lastState == 0:
                   counter += 1
               lastState = currentState

#. Ejecuta el bucle principal y asegura que el script pueda ser interrumpido con un comando de teclado (Ctrl+C), apagando todos los pines para una salida limpia.

   .. code-block:: python

       try:
           loop()
       except KeyboardInterrupt:
           # Apaga todos los pines cuando se interrumpe el script
           SDI.off()
           SRCLK.off()
           RCLK.off()
           pass



