.. note::

    ¡Hola, bienvenido a la Comunidad de Entusiastas de SunFounder Raspberry Pi & Arduino & ESP32 en Facebook! Sumérgete más en Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **¿Por qué unirse?**

    - **Soporte experto**: Resuelve problemas postventa y desafíos técnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprender y compartir**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Preestrenos exclusivos**: Obtén acceso anticipado a nuevos anuncios de productos y adelantos.
    - **Descuentos especiales**: Disfruta de descuentos exclusivos en nuestros productos más nuevos.
    - **Promociones festivas y sorteos**: Participa en sorteos y promociones navideñas.

    👉 ¿Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y únete hoy mismo.

.. _2.2.5_py_pi5:

2.2.5 Sensor de Evitación de Obstáculos por IR
==================================================

Introducción
----------------

En este proyecto, aprenderemos sobre el módulo de evitación de obstáculos por IR, que es un módulo sensor que se puede utilizar para detectar obstáculos a distancias cortas, con poca interferencia, fácil de ensamblar, fácil de usar, etc. Puede ser ampliamente utilizado en la evitación de obstáculos de robots, carros de evitación de obstáculos, conteo en líneas de ensamblaje, etc.

Componentes necesarios
-----------------------------

En este proyecto, necesitamos los siguientes componentes.

.. image:: ../python_pi5/img/2.2.5_ir_obstacle_list.png
   :width: 700
   :align: center

Es definitivamente conveniente comprar un kit completo, aquí está el enlace:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre
        - COMPONENTES EN ESTE KIT
        - ENLACE
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

También puedes comprarlos por separado en los enlaces a continuación.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCIÓN DE COMPONENTES
        - ENLACE DE COMPRA

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_avoid_module`
        - |link_obstacle_avoidance_buy|

Diagrama Esquemático
------------------------

.. image:: ../python_pi5/img/2.2.5_ir_obstacle_list_schematic.png
   :width: 500
   :align: center

Procedimientos Experimentales
---------------------------------

**Paso 1:** Construye el circuito

.. image:: ../python_pi5/img/2.2.5_ir_obstacle_circuit.png
   :width: 700
   :align: center

**Paso 2:** Cambia de directorio.

.. raw:: html

   <run></run>

.. code-block::

   cd ~/raphael-kit/python-pi5

**Paso 3:** Ejecuta.

.. raw:: html

   <run></run>

.. code-block::

   sudo python3 2.2.5_IrObstacle_zero.py

Después de ejecutar el código, cuando pongas tu mano frente a la sonda del módulo, 
el indicador de salida en el módulo se encenderá y se imprimirá repetidamente en la 
pantalla "¡Barrera detectada!" hasta que retires tu mano.

.. warning::

    Si recibe el mensaje de error ``RuntimeError: Cannot determine SOC peripheral base address``, consulte :ref:`faq_soc`

**Código**

.. note::

   Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el código a continuación. Pero antes, debes ir a la ruta del código fuente como ``raphael-kit/python-pi5``. Después de modificar el código, puedes ejecutarlo directamente para ver el efecto.


.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import Button
   import time

   # Inicializar el sensor de obstáculos conectado al pin GPIO 17
   # El sensor está configurado con una resistencia pull-up
   obstacle_sensor = Button(17, pull_up=True)  

   try:
      # Monitorear continuamente los obstáculos
      while True:
         if obstacle_sensor.is_pressed:  # Check if the sensor is triggered
               print("Detected Barrier!")  # Print a message when an obstacle is detected
               time.sleep(1)  # Delay for 1 second to avoid repetitive messages

   except KeyboardInterrupt:
      # Manejar KeyboardInterrupt (Ctrl+C) para una salida limpia y segura
      pass


**Explicación del Código**

#. Esta línea configura el script para ejecutarse utilizando Python 3. Importa la clase ``Button`` de gpiozero (utilizada para el sensor de obstáculos) y el módulo ``time`` para retrasos.

   .. code-block:: python

      #!/usr/bin/env python3
      from gpiozero import Button
      import time

#. Inicializa un sensor de obstáculos conectado al pin GPIO 17 con una resistencia pull-up interna.

   .. code-block:: python

      # Inicializar el sensor de obstáculos conectado al pin GPIO 17
      # El sensor está configurado con una resistencia pull-up
      obstacle_sensor = Button(17, pull_up=True)  

#. En un bucle continuo, el programa verifica si el sensor de obstáculos está activado (``is_pressed``). Si se detecta un obstáculo, imprime "¡Obstáculo detectado!" y luego espera un segundo (para evitar mensajes repetitivos). La estructura ``try-except`` se utiliza para manejar un KeyboardInterrupt y permitir una salida limpia.

   .. code-block:: python

      try:
         # Monitorear continuamente los obstáculos
         while True:
            if obstacle_sensor.is_pressed:  # Check if the sensor is triggered
                  print("Detected Barrier!")  # Print a message when an obstacle is detected
                  time.sleep(1)  # Delay for 1 second to avoid repetitive messages

      except KeyboardInterrupt:
         # Manejar KeyboardInterrupt (Ctrl+C) para una salida limpia y segura
         pass

