 
.. _2.2.5_py_pi5:

2.2.4 Capteur d'évitement d'obstacles IR
===========================================

Introduction
---------------

Dans ce projet, nous allons apprendre à utiliser le module d'évitement d'obstacles IR, qui est un module capteur pouvant être utilisé pour détecter des obstacles à courte distance, avec une petite interférence, facile à assembler, facile à utiliser, etc. Il peut être largement utilisé dans l'évitement d'obstacles pour robots, chariots d'évitement d'obstacles, comptage sur ligne de production, etc.

Composants nécessaires
--------------------------

Dans ce projet, nous avons besoin des composants suivants.

.. image:: ../python_pi5/img/2.2.5_ir_obstacle_list.png
   :width: 700
   :align: center

Il est certainement pratique d'acheter un kit complet, voici le lien :

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom	
        - ARTICLES DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez également les acheter séparément via les liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DU COMPOSANT
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_avoid_module`
        - |link_obstacle_avoidance_buy|

Schéma
---------

.. image:: ../python_pi5/img/2.2.5_ir_obstacle_list_schematic.png
   :width: 500
   :align: center

Procédures expérimentales
---------------------------

**Étape 1 :** Construisez le circuit

.. image:: ../python_pi5/img/2.2.5_ir_obstacle_circuit.png
   :width: 700
   :align: center

**Étape 2 :** Changez de répertoire.

.. raw:: html

   <run></run>

.. code-block::
   
   cd ~/raphael-kit/python-pi5

**Étape 3 :** Exécutez.

.. raw:: html

   <run></run>

.. code-block::

   sudo python3 2.2.5_IrObstacle_zero.py

Après l'exécution du code, lorsque vous placez votre main devant la sonde du module, 
l'indicateur de sortie sur le module s'allume et "Detected Barrier!" sera imprimé de manière répétée à l'écran jusqu'à ce que votre main soit retirée.

**Code**

.. note::

   Vous pouvez **Modifier/Réinitialiser/Copier/Exécuter/Arrêter** le code ci-dessous. Mais avant cela, vous devez vous rendre au chemin du code source comme ``raphael-kit/python-pi5``. Après avoir modifié le code, vous pouvez l'exécuter directement pour voir l'effet.


.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import Button
   import time

   # Initialize the obstacle sensor connected to GPIO pin 17
   # The sensor is configured with a pull-up resistor
   obstacle_sensor = Button(17, pull_up=True)  

   try:
      # Continuously monitor for obstacles
      while True:
         if obstacle_sensor.is_pressed:  # Check if the sensor is triggered
               print("Detected Barrier!")  # Print a message when an obstacle is detected
               time.sleep(1)  # Delay for 1 second to avoid repetitive messages

   except KeyboardInterrupt:
      # Handle KeyboardInterrupt (Ctrl+C) for a clean and safe exit
      pass


**Explication du code**

#. Cette ligne configure le script pour qu'il s'exécute en utilisant Python 3. Elle importe la classe ``Button`` de gpiozero (utilisée pour le capteur d'obstacles) et le module ``time`` pour les délais.

   .. code-block:: python

      #!/usr/bin/env python3
      from gpiozero import Button
      import time

#. Initialise un capteur d'obstacles connecté à la broche GPIO 17 avec une résistance pull-up interne.

   .. code-block:: python

      # Initialize the obstacle sensor connected to GPIO pin 17
      # The sensor is configured with a pull-up resistor
      obstacle_sensor = Button(17, pull_up=True)  

#. Dans une boucle continue, le programme vérifie si le capteur d'obstacles est activé (``is_pressed``). Si un obstacle est détecté, il affiche "Detected Barrier!" puis attend une seconde (pour éviter les messages répétitifs). La structure ``try-except`` est utilisée pour gérer un KeyboardInterrupt pour une sortie propre.

   .. code-block:: python

      try:
         # Continuously monitor for obstacles
         while True:
            if obstacle_sensor.is_pressed:  # Check if the sensor is triggered
                  print("Detected Barrier!")  # Print a message when an obstacle is detected
                  time.sleep(1)  # Delay for 1 second to avoid repetitive messages

      except KeyboardInterrupt:
         # Handle KeyboardInterrupt (Ctrl+C) for a clean and safe exit
         pass

