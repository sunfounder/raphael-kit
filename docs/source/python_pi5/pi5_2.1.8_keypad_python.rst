.. note::

    ã“ã‚“ã«ã¡ã¯ã€SunFounderã®Raspberry Pi & Arduino & ESP32æ„›å¥½å®¶ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã¸ã‚ˆã†ã“ãï¼Facebookä¸Šã§Raspberry Piã€Arduinoã€ESP32ã«ã¤ã„ã¦ã‚‚ã£ã¨æ·±ãæ˜ã‚Šä¸‹ã’ã€ä»–ã®æ„›å¥½å®¶ã¨äº¤æµã—ã¾ã—ã‚‡ã†ã€‚

    **å‚åŠ ã™ã‚‹ç†ç”±ã¯ï¼Ÿ**

    - **ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆã‚µãƒãƒ¼ãƒˆ**ï¼šã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã‚„ãƒãƒ¼ãƒ ã®åŠ©ã‘ã‚’å€Ÿã‚Šã¦ã€è²©å£²å¾Œã®å•é¡Œã‚„æŠ€è¡“çš„ãªèª²é¡Œã‚’è§£æ±ºã—ã¾ã™ã€‚
    - **å­¦ã³ï¼†å…±æœ‰**ï¼šãƒ’ãƒ³ãƒˆã‚„ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚’äº¤æ›ã—ã¦ã‚¹ã‚­ãƒ«ã‚’å‘ä¸Šã•ã›ã¾ã—ã‚‡ã†ã€‚
    - **ç‹¬å çš„ãªãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼**ï¼šæ–°è£½å“ã®ç™ºè¡¨ã‚„å…ˆè¡Œãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã«æ—©æœŸã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã—ã‚‡ã†ã€‚
    - **ç‰¹åˆ¥å‰²å¼•**ï¼šæœ€æ–°è£½å“ã®ç‹¬å å‰²å¼•ã‚’ãŠæ¥½ã—ã¿ãã ã•ã„ã€‚
    - **ç¥­ã‚Šã®ãƒ—ãƒ­ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã‚®ãƒ•ãƒˆ**ï¼šã‚®ãƒ•ãƒˆã‚„ç¥æ—¥ã®ãƒ—ãƒ­ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã«å‚åŠ ã—ã¾ã—ã‚‡ã†ã€‚

    ğŸ‘‰ ç§ãŸã¡ã¨ä¸€ç·’ã«æ¢ç´¢ã—ã€å‰µé€ ã™ã‚‹æº–å‚™ã¯ã§ãã¦ã„ã¾ã™ã‹ï¼Ÿ[|link_sf_facebook|]ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ä»Šã™ãå‚åŠ ã—ã¾ã—ã‚‡ã†ï¼

.. _2.1.8_py_pi5:

2.1.8 ã‚­ãƒ¼ãƒ‘ãƒƒãƒ‰
================

ã¯ã˜ã‚ã«
------------

ã‚­ãƒ¼ãƒ‘ãƒƒãƒ‰ã¯ãƒœã‚¿ãƒ³ã®é•·æ–¹å½¢ã®é…åˆ—ã§ã™ã€‚ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã€
ã‚­ãƒ¼ãƒ‘ãƒƒãƒ‰ã‚’æ–‡å­—ã®å…¥åŠ›ã«ä½¿ç”¨ã—ã¾ã™ã€‚

å¿…è¦ãªéƒ¨å“
------------------------------

ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ã€æ¬¡ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒå¿…è¦ã§ã™ã€‚ 

.. image:: ../python_pi5/img/2.1.8_keypad_list.png

ä¸€å¼ã‚’è³¼å…¥ã™ã‚‹ã®ãŒä¾¿åˆ©ã§ã™ã€ã“ã¡ã‚‰ãŒãƒªãƒ³ã‚¯ã§ã™ï¼š 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - åå‰	
        - ã“ã®ã‚­ãƒƒãƒˆã®ã‚¢ã‚¤ãƒ†ãƒ 
        - ãƒªãƒ³ã‚¯
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

ä»¥ä¸‹ã®ãƒªãƒ³ã‚¯ã‹ã‚‰åˆ¥ã€…ã«è³¼å…¥ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ç´¹ä»‹
        - è³¼å…¥ãƒªãƒ³ã‚¯

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_keypad`
        - \-
        
å›è·¯å›³
-----------------

.. image:: ../python_pi5/img/2.1.8_keypad_chematic_1.png


.. image:: ../python_pi5/img/2.1.8_keypad_chematic_2.png


å®Ÿé¨“æ‰‹é †
-----------------------

**ã‚¹ãƒ†ãƒƒãƒ— 1:** å›è·¯ã‚’çµ„ã¿ç«‹ã¦ã¾ã™ã€‚

.. image:: ../python_pi5/img/2.1.8_keypad_circuit.png

**ã‚¹ãƒ†ãƒƒãƒ— 2:** ã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ãã¾ã™ã€‚

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python-pi5

**ã‚¹ãƒ†ãƒƒãƒ— 3:** å®Ÿè¡Œã—ã¾ã™ã€‚

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 2.1.5_Keypad_zero.py

ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€ã‚­ãƒ¼ãƒ‘ãƒƒãƒ‰ã®ãƒœã‚¿ãƒ³ã®æŠ¼ä¸‹å€¤ï¼ˆãƒœã‚¿ãƒ³ã®å€¤ï¼‰ãŒç”»é¢ã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚

.. warning::

    ã‚¨ãƒ©ãƒ¼ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ ``RuntimeError: Cannot determine SOC peripheral base address`` ãŒè¡¨ç¤ºã•ã‚ŒãŸå ´åˆã¯ã€ :ref:`faq_soc` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

**ã‚³ãƒ¼ãƒ‰**

.. note::

    ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’ **å¤‰æ›´/ãƒªã‚»ãƒƒãƒˆ/ã‚³ãƒ”ãƒ¼/å®Ÿè¡Œ/åœæ­¢** ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãŸã ã—ã€ãã®å‰ã« ``raphael-kit/python_5`` ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ãƒ‘ã‚¹ã«ç§»å‹•ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã—ãŸå¾Œã€åŠ¹æœã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«ç›´æ¥å®Ÿè¡Œã§ãã¾ã™ã€‚


.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import DigitalOutputDevice, Button
   from time import sleep

   class Keypad:
       def __init__(self, rows_pins, cols_pins, keys):
           """
           Initialize the Keypad with specified row and column pins and keypad layout.
           :param rows_pins: List of GPIO pins for the rows.
           :param cols_pins: List of GPIO pins for the columns.
           :param keys: List of keys in the keypad layout.
           """
           # Initialize row pins as DigitalOutputDevice
           self.rows = [DigitalOutputDevice(pin) for pin in rows_pins]
           # Initialize column pins as Buttons
           self.cols = [Button(pin, pull_up=False) for pin in cols_pins]
           self.keys = keys  # Set the keypad layout

       def read(self):
           """
           Read the currently pressed keys on the keypad.
           :return: A list of pressed keys.
           """
           pressed_keys = []
           # Scan each row and column to identify pressed keys
           for i, row in enumerate(self.rows):
               row.on()  # Enable the current row
               for j, col in enumerate(self.cols):
                   if col.is_pressed:  # Check if the column button is pressed
                       # Calculate the key index based on row and column
                       index = i * len(self.cols) + j
                       pressed_keys.append(self.keys[index])
               row.off()  # Disable the current row
           return pressed_keys

   try:
       # Configure rows, columns, and keypad layout
       rows_pins = [18, 23, 24, 25]
       cols_pins = [10, 22, 27, 17]
       keys = ["1", "2", "3", "A",
               "4", "5", "6", "B",
               "7", "8", "9", "C",
               "*", "0", "#", "D"]

       # Create an instance of the Keypad class
       keypad = Keypad(rows_pins, cols_pins, keys)
       last_key_pressed = []

       # Continuously read the keypad and print newly pressed keys
       while True:
           pressed_keys = keypad.read()
           if pressed_keys and pressed_keys != last_key_pressed:
               print(pressed_keys)  # Print the list of pressed keys
               last_key_pressed = pressed_keys
           sleep(0.1)  # Short delay to reduce CPU load

   except KeyboardInterrupt:
       # Handle a keyboard interrupt (Ctrl+C) for a clean exit
       pass



**ã‚³ãƒ¼ãƒ‰ã®èª¬æ˜**

1. ``gpiozero`` ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‹ã‚‰ ``DigitalOutputDevice`` ãŠã‚ˆã³ ``Button`` ã‚¯ãƒ©ã‚¹ã€é…å»¶ã®ãŸã‚ã® ``sleep`` é–¢æ•°ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import DigitalOutputDevice, Button
       from time import sleep

2. ``Keypad`` ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã—ã¾ã™ã€‚ ``__init__`` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€æŒ‡å®šã•ã‚ŒãŸè¡Œã¨åˆ—ã®ãƒ”ãƒ³ã¨ã‚­ãƒ¼ãƒ‘ãƒƒãƒ‰ã®ã‚­ãƒ¼ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã§ã‚­ãƒ¼ãƒ‘ãƒƒãƒ‰ã‚’åˆæœŸåŒ–ã—ã¾ã™ã€‚ ``read`` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚­ãƒ¼ãƒ‘ãƒƒãƒ‰ã‚’ã‚¹ã‚­ãƒ£ãƒ³ã—ã€æŠ¼ã•ã‚ŒãŸã‚­ãƒ¼ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚

   .. code-block:: python

       class Keypad:
           def __init__(self, rows_pins, cols_pins, keys):
               """
               Initialize the Keypad with specified row and column pins and keypad layout.
               :param rows_pins: List of GPIO pins for the rows.
               :param cols_pins: List of GPIO pins for the columns.
               :param keys: List of keys in the keypad layout.
               """
               # Initialize row pins as DigitalOutputDevice
               self.rows = [DigitalOutputDevice(pin) for pin in rows_pins]
               # Initialize column pins as Buttons
               self.cols = [Button(pin, pull_up=False) for pin in cols_pins]
               self.keys = keys  # Set the keypad layout

           def read(self):
               """
               Read the currently pressed keys on the keypad.
               :return: A list of pressed keys.
               """
               pressed_keys = []
               # Scan each row and column to identify pressed keys
               for i, row in enumerate(self.rows):
                   row.on()  # Enable the current row
                   for j, col in enumerate(self.cols):
                       if col.is_pressed:  # Check if the column button is pressed
                           # Calculate the key index based on row and column
                           index = i * len(self.cols) + j
                           pressed_keys.append(self.keys[index])
                   row.off()  # Disable the current row
               return pressed_keys

3. GPIOãƒ”ãƒ³ã®è¡Œã¨åˆ—ã‚’è¨­å®šã—ã€ã‚­ãƒ¼ãƒ‘ãƒƒãƒ‰ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’å®šç¾©ã—ã¾ã™ã€‚

   .. code-block:: python

       try:
           # Configure rows, columns, and keypad layout
           rows_pins = [18, 23, 24, 25]
           cols_pins = [10, 22, 27, 17]
           keys = ["1", "2", "3", "A",
                   "4", "5", "6", "B",
                   "7", "8", "9", "C",
                   "*", "0", "#", "D"]

4. æŒ‡å®šã•ã‚ŒãŸè¨­å®šã§ ``Keypad`` ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã—ã¾ã™ã€‚

   .. code-block:: python

       try:
           ...

           # Create an instance of the Keypad class
           keypad = Keypad(rows_pins, cols_pins, keys)
           last_key_pressed = []

5. ã‚­ãƒ¼ãƒ‘ãƒƒãƒ‰ã‚’é€£ç¶šçš„ã«èª­ã¿å–ã‚Šã€ã‚­ãƒ¼ã®çŠ¶æ…‹ã«å¤‰æ›´ãŒã‚ã‚Œã°ãã‚Œã‚’è¡¨ç¤ºã—ã€CPUè² è·ã‚’è»½æ¸›ã™ã‚‹ãŸã‚ã«çŸ­ã„é…å»¶ã‚’å°å…¥ã—ã¾ã™ã€‚ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å‰²ã‚Šè¾¼ã¿ï¼ˆCtrl+Cãªã©ï¼‰ãŒç™ºç”Ÿã—ãŸå ´åˆã€ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ãã‚Œã„ã«çµ‚äº†ã™ã‚‹ãŸã‚ã«å‡¦ç†ã—ã¾ã™ã€‚

   .. code-block:: python

       try:
           ...

           # Continuously read the keypad and print newly pressed keys
           while True:
               pressed_keys = keypad.read()
               if pressed_keys and pressed_keys != last_key_pressed:
                   print(pressed_keys)  # Print the list of pressed keys
                   last_key_pressed = pressed_keys
               sleep(0.1)  # Short delay to reduce CPU load

       except KeyboardInterrupt:
           # Handle a keyboard interrupt (Ctrl+C) for a clean exit
           pass
