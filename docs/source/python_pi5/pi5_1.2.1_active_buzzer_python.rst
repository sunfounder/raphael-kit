.. _1.2.1_py_pi5:

1.2.1 Buzzer Actif
======================

Introduction
---------------

Dans ce projet, nous apprendrons comment faire sonner un buzzer actif avec un transistor PNP.

Composants Nécessaires
--------------------------

Pour ce projet, nous avons besoin des composants suivants.

.. image:: ../python_pi5/img/1.2.1_active_buzzer_list.png

Il est certainement pratique d'acheter un kit complet, voici le lien :

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom
        - ÉLÉMENTS DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez également les acheter séparément via les liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DES COMPOSANTS
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_buzzer`
        - \-
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|


Schéma de Montage
--------------------

Dans cette expérience, un buzzer actif, un transistor PNP et une résistance de 1k sont utilisés entre la base du transistor et le GPIO pour protéger le transistor. Lorsque le GPIO17 du Raspberry Pi est alimenté par un niveau haut (3,3V) par programmation, le transistor sera en conduction en raison de la saturation de courant et le buzzer émettra des sons. Mais lorsque le niveau bas est fourni au GPIO du Raspberry Pi, le transistor sera coupé et le buzzer ne fera pas de sons.

============ ======== ======== ===
Nom T-Board  Physique wiringPi BCM
GPIO17       Pin 11   0        17
============ ======== ======== ===

.. image:: ../python_pi5/img/1.2.1_active_buzzer_schematic.png


Procédures Expérimentales
--------------------------------

**Étape 1 :** Construisez le circuit. (Le buzzer actif a une étiquette blanche sur la surface et un dos noir.)

.. image:: ../python_pi5/img/1.2.1_ActiveBuzzer_circuit.png

**Étape 2 :** Ouvrez le fichier de code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python-pi5

**Étape 3 :** Exécutez.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 1.2.1_ActiveBuzzer_zero.py

Le code s'exécute et le buzzer émet un bip.

**Code**

.. note::

    Vous pouvez **Modifier/Réinitialiser/Copier/Exécuter/Arrêter** le code ci-dessous. Mais avant cela, vous devez aller au chemin source du code comme ``raphael-kit/python-pi5``. Après avoir modifié le code, vous pouvez l'exécuter directement pour voir l'effet.


.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import Buzzer
   from time import sleep

   # Initialize a Buzzer object on GPIO pin 17
   buzzer = Buzzer(17)

   try:
       while True:
           # Turn on the buzzer
           print('Buzzer On')
           buzzer.on()
           sleep(0.1)  # Keep the buzzer on for 0.1 seconds

           # Turn off the buzzer
           print('Buzzer Off')
           buzzer.off()
           sleep(0.1)  # Keep the buzzer off for 0.1 seconds

   except KeyboardInterrupt:
       # Handle KeyboardInterrupt (Ctrl+C) for clean script termination
       pass


**Explication du Code**

#. Ces instructions importent la classe ``Buzzer`` de la bibliothèque ``gpiozero`` et la fonction ``sleep`` du module ``time``.

   .. code-block:: python
       
       #!/usr/bin/env python3
       from gpiozero import Buzzer
       from time import sleep

#. Cette ligne crée un objet ``Buzzer`` connecté au GPIO pin 17 sur le Raspberry Pi.
    
   .. code-block:: python
       
       # Initialize a Buzzer object on GPIO pin 17
       buzzer = Buzzer(17)

#. Dans une boucle infinie (``while True``), le buzzer est allumé et éteint toutes les 0,1 secondes. Les instructions ``print`` fournissent une sortie console pour chaque action.
      
   .. code-block:: python
       
       try:
           while True:
               # Turn on the buzzer
               print('Buzzer On')
               buzzer.on()
               sleep(0.1)  # Keep the buzzer on for 0.1 seconds

               # Turn off the buzzer
               print('Buzzer Off')
               buzzer.off()
               sleep(0.1)  # Keep the buzzer off for 0.1 seconds

#. Ce segment assure que le programme peut être terminé en toute sécurité en utilisant une interruption clavier (Ctrl+C) sans générer d'erreur.
      
   .. code-block:: python
       
       except KeyboardInterrupt:
       # Handle KeyboardInterrupt (Ctrl+C) for clean script termination
           pass
      
