.. note::

    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten.

    **Warum beitreten?**

    - **Expertenunterst√ºtzung**: L√∂sen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams.
    - **Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre F√§higkeiten zu verbessern.
    - **Exklusive Vorschauen**: Erhalten Sie fr√ºhzeitigen Zugang zu neuen Produktank√ºndigungen und exklusiven Einblicken.
    - **Spezialrabatte**: Genie√üen Sie exklusive Rabatte auf unsere neuesten Produkte.
    - **Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil.

    üëâ Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!

.. _4.1.13_py_pi5:

4.1.10 √úberhitzungs√ºberwachung
===================================

Einf√ºhrung
-------------------

M√∂glicherweise m√∂chten Sie ein Ger√§t zur √úberhitzungs√ºberwachung bauen, das in verschiedenen Situationen Anwendung findet, z.B. in der Fabrik, wenn wir bei einer Schaltkreis√ºberhitzung einen Alarm und das zeitnahe automatische Abschalten der Maschine w√ºnschen. In diesem Projekt werden wir einen Thermistor, einen Joystick, einen Summer, eine LED und ein LCD verwenden, um ein intelligentes Temperatur√ºberwachungsger√§t zu erstellen, dessen Schwellenwert einstellbar ist.

Ben√∂tigte Komponenten
------------------------------

F√ºr dieses Projekt ben√∂tigen wir die folgenden Komponenten.

.. image:: ../python_pi5/img/4.1.13_overheat_monitor_list.png
    :width: 800
    :align: center

Es ist definitiv praktisch, ein komplettes Kit zu kaufen, hier ist der Link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Name	
        - ARTIKEL IN DIESEM KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Sie k√∂nnen sie auch einzeln √ºber die untenstehenden Links kaufen.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - KOMPONENTENVORSTELLUNG
        - KAUF-LINK

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_joystick`
        - \-
    *   - :ref:`cpn_adc0834`
        - \-
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|
    *   - :ref:`cpn_i2c_lcd1602`
        - |link_i2clcd1602_buy|
    *   - :ref:`cpn_thermistor`
        - |link_thermistor_buy|
    *   - :ref:`cpn_buzzer`
        - \-

Schaltplan
--------------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin 15   3        22
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: ../python_pi5/img/4.1.13_overheat_monitor_schematic.png
   :align: center

Experimentelle Verfahren
-----------------------------

**Schritt 1:** Bauen Sie den Schaltkreis auf.

.. image:: ../python_pi5/img/4.1.13_overheat_monitor_circuit.png


**Schritt 2**: Wechseln Sie in den Ordner des Codes.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python-pi5

**Schritt 3**: F√ºhren Sie die ausf√ºhrbare Datei aus.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 4.1.13_OverheatMonitor_zero.py

W√§hrend der Code ausgef√ºhrt wird, werden die aktuelle Temperatur und der hohe Temperaturschwellenwert **40** auf dem **I2C LCD1602** angezeigt. Wenn die aktuelle Temperatur den Schwellenwert √ºberschreitet, werden der Summer und die LED aktiviert, um Sie zu alarmieren.

Der **Joystick** dient hier dazu, den hohen Temperaturschwellenwert anzupassen. Durch Bewegen des **Joysticks** in X- und Y-Achsenrichtung kann der aktuelle hohe Temperaturschwellenwert erh√∂ht oder verringert werden. Ein erneutes Dr√ºcken des **Joysticks** setzt den Schwellenwert auf den Anfangswert zur√ºck.

.. note::

    * Wenn Sie den Fehler ``FileNotFoundError: [Errno 2] No such file or directory: '/dev/i2c-1'`` erhalten, m√ºssen Sie :ref:`i2c_config` konsultieren, um den I2C zu aktivieren.
    * Wenn der Fehler ``ModuleNotFoundError: No module named 'smbus2'`` auftritt, f√ºhren Sie bitte ``sudo pip3 install smbus2`` aus.
    * Erscheint der Fehler ``OSError: [Errno 121] Remote I/O error``, bedeutet dies, dass das Modul falsch verdrahtet ist oder das Modul defekt ist.
    * Wenn der Code und die Verdrahtung korrekt sind, das LCD aber immer noch keinen Inhalt anzeigt, k√∂nnen Sie das Potentiometer auf der R√ºckseite drehen, um den Kontrast zu erh√∂hen.


.. warning::

    Wenn die Fehlermeldung ``RuntimeError: Cannot determine SOC peripheral base address`` angezeigt wird, lesen Sie bitte :ref:`faq_soc`

**Code**

.. note::
    Sie k√∂nnen den untenstehenden Code **Modifizieren/Zur√ºcksetzen/Kopieren/Ausf√ºhren/Stoppen**. Aber zuerst m√ºssen Sie zum Quellcodepfad wie ``raphael-kit/python`` gehen. Nach der Modifikation des Codes k√∂nnen Sie ihn direkt ausf√ºhren, um das Ergebnis zu sehen.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3

   import LCD1602
   from gpiozero import LED, Buzzer, Button
   import ADC0834
   import time
   import math

   # Initialize joystick button, buzzer, and LED
   Joy_BtnPin = Button(22)
   buzzPin = Buzzer(23)
   ledPin = LED(24)

   # Set initial upper temperature threshold
   upperTem = 40

   # Setup ADC and LCD modules
   ADC0834.setup()
   LCD1602.init(0x27, 1)

   def get_joystick_value():
       """
       Reads the joystick values and returns a change value based on the joystick's position.
       """
       x_val = ADC0834.getResult(1)
       y_val = ADC0834.getResult(2)
       if x_val > 200:
           return 1
       elif x_val < 50:
           return -1
       elif y_val > 200:
           return -10
       elif y_val < 50:
           return 10
       else:
           return 0

   def upper_tem_setting():
       """
       Adjusts and displays the upper temperature threshold on the LCD.
       """
       global upperTem
       LCD1602.write(0, 0, 'Upper Adjust: ')
       change = int(get_joystick_value())
       upperTem += change
       strUpperTem = str(upperTem)
       LCD1602.write(0, 1, strUpperTem)
       LCD1602.write(len(strUpperTem), 1, '              ')
       time.sleep(0.1)

   def temperature():
       """
       Reads the current temperature from the sensor and returns it in Celsius.
       """
       analogVal = ADC0834.getResult()
       Vr = 5 * float(analogVal) / 255
       Rt = 10000 * Vr / (5 - Vr)
       temp = 1 / (((math.log(Rt / 10000)) / 3950) + (1 / (273.15 + 25)))
       Cel = temp - 273.15
       return round(Cel, 2)

   def monitoring_temp():
       """
       Monitors and displays the current temperature and upper temperature threshold. 
       Activates buzzer and LED if the temperature exceeds the upper limit.
       """
       global upperTem
       Cel = temperature()
       LCD1602.write(0, 0, 'Temp: ')
       LCD1602.write(0, 1, 'Upper: ')
       LCD1602.write(6, 0, str(Cel))
       LCD1602.write(7, 1, str(upperTem))
       time.sleep(0.1)
       if Cel >= upperTem:
           buzzPin.on()
           ledPin.on()
       else:
           buzzPin.off()
           ledPin.off()

   # Main execution loop
   try:
       lastState = 1
       stage = 0
       while True:
           currentState = Joy_BtnPin.value
           # Toggle between settings and monitoring mode
           if currentState == 1 and lastState == 0:
               stage = (stage + 1) % 2
               time.sleep(0.1)
               LCD1602.clear()
           lastState = currentState
           if stage == 1:
               upper_tem_setting()
           else:
               monitoring_temp()
   except KeyboardInterrupt:
       # Clean up and exit
       LCD1602.clear()
       ADC0834.destroy()


**Code-Erkl√§rung**

#. Dieser Abschnitt importiert die notwendigen Bibliotheken f√ºr das Projekt. ``LCD1602`` wird f√ºr das LCD-Display verwendet, ``gpiozero`` stellt Klassen f√ºr LED, Buzzer und Button bereit, ``ADC0834`` dient der Analog-Digital-Umwandlung, und ``time`` sowie ``math`` sind Python-Standardbibliotheken f√ºr zeitbezogene Funktionen und mathematische Operationen.

   .. code-block:: python

       #!/usr/bin/env python3

       import LCD1602
       from gpiozero import LED, Buzzer, Button
       import ADC0834
       import time
       import math

#. Hier werden der Joystick-Knopf, der Buzzer und die LED initialisiert. ``Button(22)`` erstellt ein Button-Objekt, das mit dem GPIO-Pin 22 verbunden ist. ``Buzzer(23)`` und ``LED(24)`` initialisieren den Buzzer und die LED an den GPIO-Pins 23 und 24.

   .. code-block:: python

       # Initialize joystick button, buzzer, and LED
       Joy_BtnPin = Button(22)
       buzzPin = Buzzer(23)
       ledPin = LED(24)

#. Legt die anf√§ngliche obere Temperaturgrenze fest und initialisiert die ADC- und LCD-Module. Das LCD wird mit einer Adresse (``0x27``) und einem Modus (``1``) initialisiert.

   .. code-block:: python

       # Set initial upper temperature threshold
       upperTem = 40

       # Setup ADC and LCD modules
       ADC0834.setup()
       LCD1602.init(0x27, 1)
    
#. Diese Funktion liest die X- und Y-Werte des Joysticks unter Verwendung von ADC0834. Sie gibt einen √Ñnderungswert basierend auf der Position des Joysticks zur√ºck, der zur Anpassung der Temperaturschwelle verwendet wird.

   .. code-block:: python

       def get_joystick_value():
           """
           Reads the joystick values and returns a change value based on the joystick's position.
           """
           x_val = ADC0834.getResult(1)
           y_val = ADC0834.getResult(2)
           if x_val > 200:
               return 1
           elif x_val < 50:
               return -1
           elif y_val > 200:
               return -10
           elif y_val < 50:
               return 10
           else:
               return 0

#. Passt die obere Temperaturgrenze unter Verwendung des Joystick-Eingangs an. Die neue Grenze wird auf dem LCD angezeigt.

   .. code-block:: python

       def upper_tem_setting():
           """
           Adjusts and displays the upper temperature threshold on the LCD.
           """
           global upperTem
           LCD1602.write(0, 0, 'Upper Adjust: ')
           change = int(get_joystick_value())
           upperTem += change
           strUpperTem = str(upperTem)
           LCD1602.write(0, 1, strUpperTem)
           LCD1602.write(len(strUpperTem), 1, '              ')
           time.sleep(0.1)

#. Liest die aktuelle Temperatur vom Sensor mit ADC0834 und konvertiert sie in Celsius.

   .. code-block:: python

       def temperature():
           """
           Reads the current temperature from the sensor and returns it in Celsius.
           """
           analogVal = ADC0834.getResult()
           Vr = 5 * float(analogVal) / 255
           Rt = 10000 * Vr / (5 - Vr)
           temp = 1 / (((math.log(Rt / 10000)) / 3950) + (1 / (273.15 + 25)))
           Cel = temp - 273.15
           return round(Cel, 2)

#. √úberwacht und zeigt die aktuelle Temperatur und die obere Grenze an. Wenn die Temperatur die obere Grenze √ºberschreitet, werden der Buzzer und die LED aktiviert.

   .. code-block:: python

       def monitoring_temp():
           """
           Monitors and displays the current temperature and upper temperature threshold. 
           Activates buzzer and LED if the temperature exceeds the upper limit.
           """
           global upperTem
           Cel = temperature()
           LCD1602.write(0, 0, 'Temp: ')
           LCD1602.write(0, 1, 'Upper: ')
           LCD1602.write(6, 0, str(Cel))
           LCD1602.write(7, 1, str(upperTem))
           time.sleep(0.1)
           if Cel >= upperTem:
               buzzPin.on()
               ledPin.on()
           else:
               buzzPin.off()
               ledPin.off()

#. Die Hauptausf√ºhrungsschleife wechselt basierend auf Joystick-Knopfdr√ºcken zwischen Einstellungs- und √úberwachungsmodi. Sie aktualisiert kontinuierlich entweder die Temperatureinstellung oder √ºberwacht die aktuelle Temperatur.

   .. code-block:: python

       # Main execution loop
       try:
           lastState = 1
           stage = 0
           while True:
               currentState = Joy_BtnPin.value
               # Toggle between settings and monitoring mode
               if currentState == 1 and lastState == 0:
                   stage = (stage + 1) % 2
                   time.sleep(0.1)
                   LCD1602.clear()
               lastState = currentState
               if stage == 1:
                   upper_tem_setting()
               else:
                   monitoring_temp()

#. Dieser Abschnitt stellt eine ordnungsgem√§√üe Bereinigung und Ressourcenfreigabe sicher, wenn das Programm unterbrochen wird.

   .. code-block:: python

       except KeyboardInterrupt:
           # Clean up and exit
           LCD1602.clear()
           ADC0834.destroy()
