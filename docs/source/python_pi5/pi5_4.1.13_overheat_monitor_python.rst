.. note::

    Ciao, benvenuto nella community di SunFounder per gli appassionati di Raspberry Pi, Arduino e ESP32 su Facebook! Approfondisci le tue conoscenze su Raspberry Pi, Arduino ed ESP32 insieme ad altri appassionati.

    **Perch√© unirti a noi?**

    - **Supporto Esperto**: Risolvi problemi post-vendita e affronta sfide tecniche con l'aiuto della nostra community e del nostro team.
    - **Impara e Condividi**: Scambia consigli e tutorial per migliorare le tue competenze.
    - **Anteprime Esclusive**: Ottieni accesso anticipato agli annunci di nuovi prodotti e alle anteprime esclusive.
    - **Sconti Speciali**: Approfitta di sconti esclusivi sui nostri ultimi prodotti.
    - **Promozioni Festive e Giveaway**: Partecipa a giveaway e promozioni durante le festivit√†.

    üëâ Sei pronto a esplorare e creare con noi? Clicca [|link_sf_facebook|] e unisciti oggi stesso!

.. _4.1.13_py_pi5:

4.1.10 Monitor di Surriscaldamento
=======================================

Introduzione
-------------------

Potresti voler creare un dispositivo di monitoraggio del surriscaldamento 
da applicare in varie situazioni, ad esempio in una fabbrica, se desideriamo 
avere un allarme e lo spegnimento automatico della macchina in caso di 
surriscaldamento di un circuito. In questo progetto, utilizzeremo un termistore,
un joystick, un cicalino, un LED e un display LCD per realizzare un dispositivo 
intelligente di monitoraggio della temperatura con soglia regolabile.

Componenti Necessari
------------------------------

In questo progetto, ci servono i seguenti componenti.

.. image:: ../python_pi5/img/4.1.13_overheat_monitor_list.png
    :width: 800
    :align: center

√à sicuramente conveniente acquistare un kit completo, ecco il link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nome	
        - ELEMENTI NEL KIT
        - LINK
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Puoi anche acquistare i componenti separatamente dai link qui sotto.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUZIONE AI COMPONENTI
        - LINK D'ACQUISTO

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_joystick`
        - \-
    *   - :ref:`cpn_adc0834`
        - \-
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|
    *   - :ref:`cpn_i2c_lcd`
        - |link_i2clcd1602_buy|
    *   - :ref:`cpn_thermistor`
        - |link_thermistor_buy|
    *   - :ref:`cpn_buzzer`
        - \-

Schema Elettrico
--------------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin15    3        22
GPIO23       Pin16    4        23
GPIO24       Pin18    5        24
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: ../python_pi5/img/4.1.13_overheat_monitor_schematic.png
   :align: center

Procedure Sperimentali
-----------------------------

**Passo 1:** Costruisci il circuito.

.. image:: ../python_pi5/img/4.1.13_overheat_monitor_circuit.png


**Passo 2**: Vai alla cartella del codice.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python-pi5

**Passo 3**: Esegui il file eseguibile.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 4.1.13_OverheatMonitor_zero.py

Durante l'esecuzione del codice, la temperatura corrente e la soglia di 
alta temperatura **40** vengono visualizzate su **I2C LCD1602**. Se la 
temperatura corrente supera la soglia, il cicalino e il LED si attivano 
per avvisarti.

Il **Joystick** qui serve per regolare la soglia di alta temperatura. 
Spostando il **Joystick** lungo l'asse X e Y, puoi aumentare o diminuire 
la soglia di alta temperatura. Premi nuovamente il **Joystick** per resettare 
la soglia al valore iniziale.

.. note::

    * Se ricevi l'errore ``FileNotFoundError: [Errno 2] No such file or directory: '/dev/i2c-1'``, devi fare riferimento a :ref:`i2c_config` per abilitare l'I2C.
    * Se ricevi l'errore ``ModuleNotFoundError: No module named 'smbus2'``, esegui ``sudo pip3 install smbus2``.
    * Se compare l'errore ``OSError: [Errno 121] Remote I/O error``, significa che il modulo √® cablato male o √® difettoso.
    * Se il codice e i collegamenti sono corretti, ma il display LCD non mostra ancora contenuti, puoi ruotare il potenziometro sul retro per aumentare il contrasto.


.. warning::

    Se viene visualizzato l'errore ``RuntimeError: Cannot determine SOC peripheral base address``, fare riferimento a :ref:`faq_soc`. 

**Code**

.. note::
    Puoi **Modificare/Resettare/Copiare/Eseguire/Fermare** il codice qui sotto. Ma prima devi accedere al percorso del codice sorgente come ``raphael-kit/python``. Dopo aver modificato il codice, puoi eseguirlo direttamente per vedere l'effetto.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3

   import LCD1602
   from gpiozero import LED, Buzzer, Button
   import ADC0834
   import time
   import math

   # Inizializza il pulsante del joystick, il cicalino e il LED
   Joy_BtnPin = Button(22)
   buzzPin = Buzzer(23)
   ledPin = LED(24)

   # Imposta la soglia di temperatura massima iniziale
   upperTem = 40

   # Configura i moduli ADC e LCD
   ADC0834.setup()
   LCD1602.init(0x27, 1)

   def get_joystick_value():
       """
       Reads the joystick values and returns a change value based on the joystick's position.
       """
       x_val = ADC0834.getResult(1)
       y_val = ADC0834.getResult(2)
       if x_val > 200:
           return 1
       elif x_val < 50:
           return -1
       elif y_val > 200:
           return -10
       elif y_val < 50:
           return 10
       else:
           return 0

   def upper_tem_setting():
       """
       Adjusts and displays the upper temperature threshold on the LCD.
       """
       global upperTem
       LCD1602.write(0, 0, 'Upper Adjust: ')
       change = int(get_joystick_value())
       upperTem += change
       strUpperTem = str(upperTem)
       LCD1602.write(0, 1, strUpperTem)
       LCD1602.write(len(strUpperTem), 1, '              ')
       time.sleep(0.1)

   def temperature():
       """
       Reads the current temperature from the sensor and returns it in Celsius.
       """
       analogVal = ADC0834.getResult()
       Vr = 5 * float(analogVal) / 255
       Rt = 10000 * Vr / (5 - Vr)
       temp = 1 / (((math.log(Rt / 10000)) / 3950) + (1 / (273.15 + 25)))
       Cel = temp - 273.15
       return round(Cel, 2)

   def monitoring_temp():
       """
       Monitors and displays the current temperature and upper temperature threshold. 
       Activates buzzer and LED if the temperature exceeds the upper limit.
       """
       global upperTem
       Cel = temperature()
       LCD1602.write(0, 0, 'Temp: ')
       LCD1602.write(0, 1, 'Upper: ')
       LCD1602.write(6, 0, str(Cel))
       LCD1602.write(7, 1, str(upperTem))
       time.sleep(0.1)
       if Cel >= upperTem:
           buzzPin.on()
           ledPin.on()
       else:
           buzzPin.off()
           ledPin.off()

   # Ciclo principale di esecuzione
   try:
       lastState = 1
       stage = 0
       while True:
           currentState = Joy_BtnPin.value
           # Passa tra la modalit√† impostazioni e la modalit√† monitoraggio
           if currentState == 1 e lastState == 0:
               stage = (stage + 1) % 2
               time.sleep(0.1)
               LCD1602.clear()
           lastState = currentState
           if stage == 1:
               upper_tem_setting()
           else:
               monitoring_temp()
   except KeyboardInterrupt:
       # Pulisci e esci
       LCD1602.clear()
       ADC0834.destroy()


**Spiegazione del Codice**

#. Questa sezione importa le librerie necessarie per il progetto. ``LCD1602`` √® per il display LCD, ``gpiozero`` fornisce classi per LED, Cicalino e Pulsante, ``ADC0834`` √® per la conversione da analogico a digitale, e ``time`` e ``math`` sono librerie standard di Python per funzioni correlate al tempo e operazioni matematiche.

   .. code-block:: python

       #!/usr/bin/env python3

       import LCD1602
       from gpiozero import LED, Buzzer, Button
       import ADC0834
       import time
       import math

#. Qui vengono inizializzati il pulsante del joystick, il cicalino e il LED. ``Button(22)`` crea un oggetto pulsante collegato al pin GPIO 22. ``Buzzer(23)`` e ``LED(24)`` inizializzano il cicalino e il LED sui pin GPIO 23 e 24, rispettivamente.

   .. code-block:: python

       # Inizializza il pulsante del joystick, il cicalino e il LED
       Joy_BtnPin = Button(22)
       buzzPin = Buzzer(23)
       ledPin = LED(24)

#. Imposta il limite massimo di temperatura iniziale e configura i moduli ADC e LCD. L'LCD √® inizializzato con un indirizzo (``0x27``) e una modalit√† (``1``).

   .. code-block:: python

       # Imposta la soglia di temperatura massima iniziale
       upperTem = 40

       # Configura i moduli ADC e LCD
       ADC0834.setup()
       LCD1602.init(0x27, 1)
#. Questa funzione legge i valori X e Y del joystick utilizzando l'ADC0834. Restituisce un valore di modifica basato sulla posizione del joystick, che verr√† utilizzato per regolare la soglia di temperatura.

   .. code-block:: python

       def get_joystick_value():
           """
           Reads the joystick values and returns a change value based on the joystick's position.
           """
           x_val = ADC0834.getResult(1)
           y_val = ADC0834.getResult(2)
           if x_val > 200:
               return 1
           elif x_val < 50:
               return -1
           elif y_val > 200:
               return -10
           elif y_val < 50:
               return 10
           else:
               return 0

#. Regola il limite massimo della temperatura utilizzando l'input del joystick. Il nuovo limite viene visualizzato sul display LCD.

   .. code-block:: python

       def upper_tem_setting():
           """
           Adjusts and displays the upper temperature threshold on the LCD.
           """
           global upperTem
           LCD1602.write(0, 0, 'Upper Adjust: ')
           change = int(get_joystick_value())
           upperTem += change
           strUpperTem = str(upperTem)
           LCD1602.write(0, 1, strUpperTem)
           LCD1602.write(len(strUpperTem), 1, '              ')
           time.sleep(0.1)

#. Legge la temperatura corrente dal sensore utilizzando l'ADC0834 e la converte in gradi Celsius.

   .. code-block:: python

       def temperature():
           """
           Reads the current temperature from the sensor and returns it in Celsius.
           """
           analogVal = ADC0834.getResult()
           Vr = 5 * float(analogVal) / 255
           Rt = 10000 * Vr / (5 - Vr)
           temp = 1 / (((math.log(Rt / 10000)) / 3950) + (1 / (273.15 + 25)))
           Cel = temp - 273.15
           return round(Cel, 2)

#. Monitora e visualizza la temperatura corrente e il limite massimo. Se la temperatura supera il limite massimo, il cicalino e il LED si attivano.

   .. code-block:: python

       def monitoring_temp():
           """
           Monitors and displays the current temperature and upper temperature threshold. 
           Activates buzzer and LED if the temperature exceeds the upper limit.
           """
           global upperTem
           Cel = temperature()
           LCD1602.write(0, 0, 'Temp: ')
           LCD1602.write(0, 1, 'Upper: ')
           LCD1602.write(6, 0, str(Cel))
           LCD1602.write(7, 1, str(upperTem))
           time.sleep(0.1)
           if Cel >= upperTem:
               buzzPin.on()
               ledPin.on()
           else:
               buzzPin.off()
               ledPin.off()

#. Il ciclo principale di esecuzione alterna tra la modalit√† impostazioni e la modalit√† monitoraggio in base alle pressioni del pulsante del joystick. Aggiorna continuamente la soglia di temperatura o monitora la temperatura corrente.

   .. code-block:: python

       # Ciclo principale di esecuzione
       try:
           lastState = 1
           stage = 0
           while True:
               currentState = Joy_BtnPin.value
               # Passa tra la modalit√† impostazioni e monitoraggio
               if currentState == 1 e lastState == 0:
                   stage = (stage + 1) % 2
                   time.sleep(0.1)
                   LCD1602.clear()
               lastState = currentState
               if stage == 1:
                   upper_tem_setting()
               else:
                   monitoring_temp()

#. Questa sezione garantisce una corretta pulizia e rilascio delle risorse quando il programma viene interrotto.

   .. code-block:: python

       except KeyboardInterrupt:
           # Pulisci e esci
           LCD1602.clear()
           ADC0834.destroy()
