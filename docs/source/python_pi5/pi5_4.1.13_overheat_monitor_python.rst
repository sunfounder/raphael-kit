 
.. note::

    Bonjour et bienvenue dans la Communaut√© Facebook des passionn√©s de Raspberry Pi, Arduino et ESP32 de SunFounder ! Plongez plus profond√©ment dans l'univers des Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre et partager** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits et aux aper√ßus.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos produits les plus r√©cents.
    - **Promotions festives et cadeaux** : Participez √† des cadeaux et des promotions de vacances.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez [|link_sf_facebook|] et rejoignez-nous aujourd'hui !

.. _4.1.13_py_pi5:

4.1.10 Moniteur de surchauffe
================================

Introduction
-------------------

Vous pourriez vouloir fabriquer un dispositif de surveillance de la surchauffe 
applicable √† diverses situations, par exemple, dans une usine, si nous voulons 
avoir une alarme et un arr√™t automatique de la machine en cas de surchauffe du 
circuit. Dans ce projet, nous utiliserons une thermistance, un joystick, un buzzer, 
une LED et un LCD pour cr√©er un dispositif intelligent de surveillance de la temp√©rature 
dont le seuil est r√©glable.

Composants n√©cessaires
------------------------------

Pour ce projet, nous avons besoin des composants suivants.

.. image:: ../python_pi5/img/4.1.13_overheat_monitor_list.png
    :width: 800
    :align: center

Il est certainement pratique d'acheter un kit complet, voici le lien : 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom
        - √âL√âMENTS DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez √©galement les acheter s√©par√©ment via les liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION AUX COMPOSANTS
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_joystick`
        - \-
    *   - :ref:`cpn_adc0834`
        - \-
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|
    *   - :ref:`cpn_i2c_lcd`
        - |link_i2clcd1602_buy|
    *   - :ref:`cpn_thermistor`
        - |link_thermistor_buy|
    *   - :ref:`cpn_buzzer`
        - \-

Sch√©ma
--------------------------

============ ======== ======== ===
Nom T-Board  Physique wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin15    3        22
GPIO23       Pin16    4        23
GPIO24       Pin18    5        24
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: ../python_pi5/img/4.1.13_overheat_monitor_schematic.png
   :align: center

Proc√©dures exp√©rimentales
-----------------------------

**√âtape 1 :** Construire le circuit.

.. image:: ../python_pi5/img/4.1.13_overheat_monitor_circuit.png


**√âtape 2 :** Aller dans le dossier du code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python-pi5

**√âtape 3 :** Ex√©cuter le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 4.1.13_OverheatMonitor_zero.py

Lorsque le code s'ex√©cute, la temp√©rature actuelle et le seuil de haute 
temp√©rature **40** s'affichent sur l'√©cran **I2C LCD1602**. Si la temp√©rature 
actuelle d√©passe le seuil, le buzzer et la LED s'activent pour vous alerter.

Le **joystick** vous permet de r√©gler le seuil de haute temp√©rature. En le basculant 
dans la direction de l'axe X ou de l'axe Y, vous pouvez augmenter ou diminuer le seuil 
de haute temp√©rature actuel. Appuyez √† nouveau sur le **joystick** pour r√©initialiser 
le seuil √† sa valeur initiale.

.. note::

    * Si vous obtenez l'erreur ``FileNotFoundError: [Errno 2] No such file or directory: '/dev/i2c-1'``, vous devez vous r√©f√©rer √† :ref:`i2c_config` pour activer l'I2C.
    * Si vous obtenez l'erreur ``ModuleNotFoundError: No module named 'smbus2'``, veuillez ex√©cuter ``sudo pip3 install smbus2``.
    * Si l'erreur ``OSError: [Errno 121] Remote I/O error`` appara√Æt, cela signifie que le module est mal c√¢bl√© ou que le module est d√©fectueux.
    * Si le code et le c√¢blage sont corrects, mais que le LCD n'affiche toujours pas de contenu, vous pouvez tourner le potentiom√®tre √† l'arri√®re pour augmenter le contraste.

.. warning::

    Si vous recevez le message d'erreur ``RuntimeError: Cannot determine SOC peripheral base address``, veuillez consulter :ref:`faq_soc`

**Code**

.. note::
    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez acc√©der au chemin du code source comme ``raphael-kit/python``. Apr√®s avoir modifi√© le code, vous pouvez l'ex√©cuter directement pour voir l'effet.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3

   import LCD1602
   from gpiozero import LED, Buzzer, Button
   import ADC0834
   import time
   import math

   # Initialize joystick button, buzzer, and LED
   Joy_BtnPin = Button(22)
   buzzPin = Buzzer(23)
   ledPin = LED(24)

   # Set initial upper temperature threshold
   upperTem = 40

   # Setup ADC and LCD modules
   ADC0834.setup()
   LCD1602.init(0x27, 1)

   def get_joystick_value():
       """
       Reads the joystick values and returns a change value based on the joystick's position.
       """
       x_val = ADC0834.getResult(1)
       y_val = ADC0834.getResult(2)
       if x_val > 200:
           return 1
       elif x_val < 50:
           return -1
       elif y_val > 200:
           return -10
       elif y_val < 50:
           return 10
       else:
           return 0

   def upper_tem_setting():
       """
       Adjusts and displays the upper temperature threshold on the LCD.
       """
       global upperTem
       LCD1602.write(0, 0, 'Upper Adjust: ')
       change = int(get_joystick_value())
       upperTem += change
       strUpperTem = str(upperTem)
       LCD1602.write(0, 1, strUpperTem)
       LCD1602.write(len(strUpperTem), 1, '              ')
       time.sleep(0.1)

   def temperature():
       """
       Reads the current temperature from the sensor and returns it in Celsius.
       """
       analogVal = ADC0834.getResult()
       Vr = 5 * float(analogVal) / 255
       Rt = 10000 * Vr / (5 - Vr)
       temp = 1 / (((math.log(Rt / 10000)) / 3950) + (1 / (273.15 + 25)))
       Cel = temp - 273.15
       return round(Cel, 2)

   def monitoring_temp():
       """
       Monitors and displays the current temperature and upper temperature threshold. 
       Activates buzzer and LED if the temperature exceeds the upper limit.
       """
       global upperTem
       Cel = temperature()
       LCD1602.write(0, 0, 'Temp: ')
       LCD1602.write(0, 1, 'Upper: ')
       LCD1602.write(6, 0, str(Cel))
       LCD1602.write(7, 1, str(upperTem))
       time.sleep(0.1)
       if Cel >= upperTem:
           buzzPin.on()
           ledPin.on()
       else:
           buzzPin.off()
           ledPin.off()

   # Main execution loop
   try:
       lastState = 1
       stage = 0
       while True:
           currentState = Joy_BtnPin.value
           # Toggle between settings and monitoring mode
           if currentState == 1 and lastState == 0:
               stage = (stage + 1) % 2
               time.sleep(0.1)
               LCD1602.clear()
           lastState = currentState
           if stage == 1:
               upper_tem_setting()
           else:
               monitoring_temp()
   except KeyboardInterrupt:
       # Clean up and exit
       LCD1602.clear()
       ADC0834.destroy()


**Explication du code**

#. Cette section importe les biblioth√®ques n√©cessaires au projet. ``LCD1602`` est pour l'affichage LCD, ``gpiozero`` fournit des classes pour LED, Buzzer et Button, ``ADC0834`` est pour la conversion analogique-num√©rique, et ``time`` et ``math`` sont des biblioth√®ques standard de Python pour les fonctions li√©es au temps et les op√©rations math√©matiques, respectivement.

   .. code-block:: python

       #!/usr/bin/env python3

       import LCD1602
       from gpiozero import LED, Buzzer, Button
       import ADC0834
       import time
       import math

#. Ici, le bouton du joystick, le buzzer et la LED sont initialis√©s. ``Button(22)`` cr√©e un objet bouton connect√© au GPIO pin 22. ``Buzzer(23)`` et ``LED(24)`` initialisent le buzzer et la LED aux GPIO pins 23 et 24, respectivement.

   .. code-block:: python

       # Initialize joystick button, buzzer, and LED
       Joy_BtnPin = Button(22)
       buzzPin = Buzzer(23)
       ledPin = LED(24)

#. D√©finit la limite de temp√©rature sup√©rieure initiale et initialise les modules ADC et LCD. Le LCD est initialis√© avec une adresse (``0x27``) et un mode (``1``).

   .. code-block:: python

       # Set initial upper temperature threshold
       upperTem = 40

       # Setup ADC and LCD modules
       ADC0834.setup()
       LCD1602.init(0x27, 1)

#. Cette fonction lit les valeurs du joystick √† l'aide d'ADC0834. Elle renvoie une valeur de changement bas√©e sur la position du joystick, qui sera utilis√©e pour ajuster le seuil de temp√©rature.

   .. code-block:: python

       def get_joystick_value():
           """
           Reads the joystick values and returns a change value based on the joystick's position.
           """
           x_val = ADC0834.getResult(1)
           y_val = ADC0834.getResult(2)
           if x_val > 200:
               return 1
           elif x_val < 50:
               return -1
           elif y_val > 200:
               return -10
           elif y_val < 50:
               return 10
           else:
               return 0

#. Ajuste la limite de temp√©rature sup√©rieure en utilisant l'entr√©e du joystick. La nouvelle limite est affich√©e sur le LCD.

   .. code-block:: python

       def upper_tem_setting():
           """
           Adjusts and displays the upper temperature threshold on the LCD.
           """
           global upperTem
           LCD1602.write(0, 0, 'Upper Adjust: ')
           change = int(get_joystick_value())
           upperTem += change
           strUpperTem = str(upperTem)
           LCD1602.write(0, 1, strUpperTem)
           LCD1602.write(len(strUpperTem), 1, '              ')
           time.sleep(0.1)

#. Lit la temp√©rature actuelle du capteur en utilisant ADC0834 et la convertit en Celsius.

   .. code-block:: python

       def temperature():
           """
           Reads the current temperature from the sensor and returns it in Celsius.
           """
           analogVal = ADC0834.getResult()
           Vr = 5 * float(analogVal) / 255
           Rt = 10000 * Vr / (5 - Vr)
           temp = 1 / (((math.log(Rt / 10000)) / 3950) + (1 / (273.15 + 25)))
           Cel = temp - 273.15
           return round(Cel, 2)

#. Surveille et affiche la temp√©rature actuelle et la limite sup√©rieure. Si la temp√©rature d√©passe la limite sup√©rieure, le buzzer et la LED sont activ√©s.

   .. code-block:: python

       def monitoring_temp():
           """
           Monitors and displays the current temperature and upper temperature threshold. 
           Activates buzzer and LED if the temperature exceeds the upper limit.
           """
           global upperTem
           Cel = temperature()
           LCD1602.write(0, 0, 'Temp: ')
           LCD1602.write(0, 1, 'Upper: ')
           LCD1602.write(6, 0, str(Cel))
           LCD1602.write(7, 1, str(upperTem))
           time.sleep(0.1)
           if Cel >= upperTem:
               buzzPin.on()
               ledPin.on()
           else:
               buzzPin.off()
               ledPin.off()

#. La boucle d'ex√©cution principale alterne entre les modes de r√©glage et de surveillance en fonction des pressions sur le bouton du joystick. Elle met continuellement √† jour soit le r√©glage de la temp√©rature, soit surveille la temp√©rature actuelle.

   .. code-block:: python

       # Main execution loop
       try:
           lastState = 1
           stage = 0
           while True:
               currentState = Joy_BtnPin.value
               # Toggle between settings and monitoring mode
               if currentState == 1 and lastState == 0:
                   stage = (stage + 1) % 2
                   time.sleep(0.1)
                   LCD1602.clear()
               lastState = currentState
               if stage == 1:
                   upper_tem_setting()
               else:
                   monitoring_temp()

#. Cette section assure un nettoyage et une lib√©ration appropri√©s des ressources lorsque le programme est interrompu.

   .. code-block:: python

       except KeyboardInterrupt:
           # Clean up and exit
           LCD1602.clear()
           ADC0834.destroy()