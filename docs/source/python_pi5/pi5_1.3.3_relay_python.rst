.. note::

    Ciao, benvenuto nella Community di SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts su Facebook! Approfondisci il mondo di Raspberry Pi, Arduino ed ESP32 insieme ad altri appassionati.

    **Perch√© unirti a noi?**

    - **Supporto Tecnico Esperto**: Risolvi problemi post-vendita e sfide tecniche con l'aiuto della nostra comunit√† e del nostro team.
    - **Impara e Condividi**: Scambia consigli e tutorial per migliorare le tue competenze.
    - **Anteprime Esclusive**: Ottieni accesso anticipato agli annunci di nuovi prodotti e alle anteprime.
    - **Sconti Speciali**: Approfitta di sconti esclusivi sui nostri prodotti pi√π recenti.
    - **Promozioni Festive e Giveaway**: Partecipa a giveaway e promozioni durante le festivit√†.

    üëâ Sei pronto a esplorare e creare con noi? Clicca [|link_sf_facebook|] e unisciti oggi stesso!

.. _1.3.3_py_pi5:

1.3.3 Rel√®
=============

Introduzione
--------------

In questo progetto, impareremo a usare un rel√®. √à uno dei componenti pi√π utilizzati 
nei sistemi di controllo automatico. Quando la tensione, la corrente, la temperatura, 
la pressione, ecc., raggiungono, superano o sono inferiori al valore prestabilito, il 
rel√® collegher√† o interromper√† il circuito, per controllare e proteggere l'attrezzatura.

Componenti Necessari
------------------------------

Per questo progetto, avremo bisogno dei seguenti componenti. 

.. image:: ../python_pi5/img/1.3.3_relay_list.png

√à decisamente conveniente acquistare un kit completo, ecco il link: 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nome	
        - COMPONENTI NEL KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Puoi anche acquistarli separatamente dai link sottostanti.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUZIONE AI COMPONENTI
        - LINK D'ACQUISTO

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|
    *   - :ref:`cpn_relay`
        - |link_relay_buy|
    *   - :ref:`cpn_diode`
        - |link_diode_buy|

Schema Elettrico
---------------------

.. image:: ../python_pi5/img/1.3.3_relay_schematic.png


Procedure Sperimentali
---------------------------

**Passo 1:** Costruisci il circuito.

.. image:: ../python_pi5/img/1.3.3_relay_circuit.png

**Passo 2:** Apri il file del codice.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python-pi5


**Passo 3:** Esegui.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 1.3.3_Relay_zero.py

Durante l'esecuzione del codice, il LED si accender√†. Inoltre, sentirai un 
ticchettio causato dall'apertura del contatto normalmente chiuso e dalla 
chiusura del contatto normalmente aperto.

.. warning::

    Se viene visualizzato l'errore ``RuntimeError: Cannot determine SOC peripheral base address``, fare riferimento a :ref:`faq_soc`. 

**Code**

.. note::

    Puoi **Modificare/Resettare/Copiare/Eseguire/Fermare** il codice qui sotto. Ma prima, devi andare nella directory del codice come ``raphael-kit/python-pi5``. Dopo aver modificato il codice, puoi eseguirlo direttamente per vedere l'effetto.


.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import OutputDevice  # Importa la classe per il controllo dei pin GPIO
   from time import sleep  # Importa la funzione sleep per i ritardi

   # Inizializza il rel√® collegato al pin GPIO 17, partendo dallo stato 'off'
   relay = OutputDevice(17, initial_value=False)

   try:
       # Ciclo continuo per attivare e disattivare lo stato del rel√® ogni secondo
       while True:
           print('Relay open...')  # Informa che il rel√® √® stato attivato
           relay.on()  # Accende il rel√® (supponendo una configurazione a logica inversa)
           sleep(1)   # Mantiene il rel√® nello stato acceso per 1 secondo

           print('...Relay close')  # Informa che il rel√® √® stato disattivato
           relay.off()  # Spegne il rel√®
           sleep(1)   # Mantiene il rel√® nello stato spento per 1 secondo

   except KeyboardInterrupt:
       # Gestisce un'interruzione da tastiera (Ctrl+C) per uscire dal ciclo
       relay.off()  # Assicura che il rel√® sia spento prima di uscire
       pass


**Spiegazione del Codice**

#. Importa ``OutputDevice`` da ``gpiozero`` per controllare i pin GPIO e ``sleep`` da ``time`` per aggiungere ritardi.

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import OutputDevice  # Importa la classe per il controllo dei pin GPIO
       from time import sleep  # Importa la funzione sleep per i ritardi

#. Inizializza un oggetto ``OutputDevice`` per il rel√® collegato al pin GPIO 17. Il parametro ``initial_value=False`` imposta inizialmente il rel√® nello stato ``off`` (supponendo una configurazione a logica inversa).

   .. code-block:: python

       # Inizializza il rel√® collegato al pin GPIO 17, partendo dallo stato 'off'
       relay = OutputDevice(17, initial_value=False)

#. All'interno del blocco ``try``, un ciclo ``while True`` alterna continuamente lo stato del rel√®. Il rel√® viene acceso e spento con un intervallo di 1 secondo tra ciascuno stato, accompagnato da dichiarazioni di stampa sulla console.

   .. code-block:: python

       try:
           # Ciclo continuo per attivare e disattivare lo stato del rel√® ogni secondo
           while True:
               print('Relay open...')  # Informa che il rel√® √® stato attivato
               relay.on()  # Accende il rel√® (supponendo una configurazione a logica inversa)
               sleep(1)   # Mantiene il rel√® nello stato acceso per 1 secondo

               print('...Relay close')  # Informa che il rel√® √® stato disattivato
               relay.off()  # Spegne il rel√®
               sleep(1)   # Mantiene il rel√® nello stato spento per 1 secondo

#. Gestisce un'interruzione da tastiera (come Ctrl+C) per consentire la chiusura sicura dello script. Il rel√® viene spento prima di uscire dallo script.

   .. code-block:: python
      
      except KeyboardInterrupt:
        # Gestisce un'interruzione da tastiera (Ctrl+C) per uscire dal ciclo
        relay.off()  # Assicura che il rel√® sia spento prima di uscire
        pass

