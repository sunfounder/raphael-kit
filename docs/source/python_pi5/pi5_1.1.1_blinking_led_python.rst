.. nota::

    ¡Hola, bienvenido a la Comunidad de Entusiastas de SunFounder para Raspberry Pi, Arduino y ESP32 en Facebook! Sumérgete en el mundo de Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **¿Por qué unirse?**

    - **Soporte experto**: Resuelve problemas post-venta y desafíos técnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprende y comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Avances exclusivos**: Obtén acceso anticipado a nuevos anuncios de productos y adelantos exclusivos.
    - **Descuentos especiales**: Disfruta de descuentos exclusivos en nuestros productos más nuevos.
    - **Promociones y sorteos festivos**: Participa en sorteos y promociones de vacaciones.

    👉 ¿Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y únete hoy mismo!

.. _1.1.1_py_pi5:

1.1.1 LED Parpadeante
=========================

Introducción
-----------------

En este proyecto, aprenderemos cómo hacer un LED parpadeante mediante programación. 
A través de tus configuraciones, tu LED puede producir una serie de fenómenos interesantes. 
¡Vamos a por ello!

Componentes Necesarios
------------------------------

En este proyecto, necesitamos los siguientes componentes. 

.. image:: ../python_pi5/img/1.1.1_blinking_led_list.png
    :width: 800
    :align: center

Es definitivamente conveniente comprar un kit completo, aquí está el enlace: 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre	
        - ELEMENTOS EN ESTE KIT
        - ENLACE
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

También puedes comprarlos por separado en los siguientes enlaces.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCIÓN DEL COMPONENTE
        - ENLACE DE COMPRA

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|


Diagrama Esquemático
---------------------------

En este experimento, conectamos el pin GPIO 17 de la Raspberry Pi al ánodo (pin largo) del LED, luego el cátodo (pin corto) del LED a un resistor, y luego conectamos el otro extremo del resistor al pin GND en la Raspberry Pi. Para encender el LED, necesitamos configurar GPIO17 a alto (3.3V). Podemos lograr este fenómeno mediante programación.

.. nota::

    **Pin11** se refiere al 11º pin de la Raspberry Pi de izquierda a derecha, y sus números 
    de pin **BCM** correspondientes se muestran en la siguiente tabla.

En el contenido relacionado con el lenguaje Python, BCM 17 es 17 en la columna BCM de la 
siguiente tabla. Al mismo tiempo, son el mismo que el pin 11 en la Raspberry Pi, Pin 11.

============== ======== ===
Nombre T-Board físico   BCM
GPIO17         Pin 11   17
============== ======== ===

.. image:: ../python_pi5/img/1.1.1_blinking_led_schematic.png
    :width: 800
    :align: center

Procedimientos Experimentales
--------------------------------

**Paso 1:** Construye el circuito.

.. image:: ../python_pi5/img/1.1.1_blinking_led_circuit.png
    :width: 800
    :align: center

**Paso 2:** Ve a la carpeta del código y ejecútalo.

1. Si usas una pantalla, se recomienda seguir los siguientes pasos.

Encuentra ``1.1.1_BlinkingLed_zero.py`` y haz doble clic para abrirlo. Ahora estás en el archivo.

Haz clic en **Run** ->\ **Run Module** en la ventana y aparecerá el siguiente contenido.

Para detener la ejecución, simplemente haz clic en el botón X en la parte superior derecha 
para cerrarlo y volverás al código. Si modificas el código, antes de hacer clic en 
**Run Module (F5)** debes guardarlo primero. Luego puedes ver los resultados.

2. Si inicias sesión en la Raspberry Pi de forma remota, escribe el comando:

.. raw:: html

   <run></run>

.. code-block::

   cd ~/raphael-kit/python-pi5

.. nota::
    Cambia el directorio a la ruta del código en este experimento mediante ``cd``.

**Paso 3:** Ejecuta el código

.. raw:: html

   <run></run>

.. code-block::

   sudo python3 1.1.1_BlinkingLed_zero.py

.. nota::
    Aquí sudo - superuser do, y python significa ejecutar el archivo con Python.

Después de ejecutar el código, verás que el LED parpadea.

**Paso 4:** Si deseas editar el archivo de código ``1.1.1_BlinkingLed_zero.py``, presiona
 ``Ctrl + C`` para detener la ejecución del código. Luego escribe el siguiente comando para 
 abrir ``1.1.1_BlinkingLed_zero.py``:

.. raw:: html

   <run></run>

.. code-block::

   nano 1.1.1_BlinkingLed_zero.py

.. nota::
    nano es una herramienta de edición de texto. El comando se usa para abrir el archivo de 
    código ``1.1.1_BlinkingLed_zero.py`` con esta herramienta.

Presiona ``Ctrl+X`` para salir. Si has modificado el código, aparecerá un mensaje preguntando 
si deseas guardar los cambios o no. Escribe ``Y`` (guardar) o ``N`` (no guardar).

Luego presiona ``Enter`` para salir. Escribe nano ``1.1.1_BlinkingLed_zero.py`` nuevamente para 
ver el efecto después del cambio.
.. warning::

    Si recibe el mensaje de error ``RuntimeError: Cannot determine SOC peripheral base address``, consulte :ref:`faq_soc`

**Código**

El siguiente es el código del programa:

.. note::

   Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el código a continuación. Pero antes de eso, necesitas ir a la ruta del código fuente como ``raphael-kit/python-pi5``. Después de modificar el código, puedes ejecutarlo directamente para ver el efecto.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import LED
   from time import sleep

   # Initialize an LED connected to GPIO pin 17 using the GPIO Zero library.
   led = LED(17)

   try:
      # Start an infinite loop to toggle the LED state.
      while True:
         # Turn on the LED and print a message to the console.
         led.on()
         print('...LED ON')

         # Wait for 0.5 seconds with the LED on.
         sleep(0.5)

         # Turn off the LED and print a message to the console.
         led.off()
         print('LED OFF...')

         # Wait for 0.5 seconds with the LED off.
         sleep(0.5)

   except KeyboardInterrupt:
      # Gracefully handle a keyboard interrupt (Ctrl+C) by breaking the loop.
      # GPIO Zero handles cleanup of GPIO settings automatically on exit.
      pass


**Explicación del Código**

#. Cuando el sistema detecta esto, buscará la ruta de instalación de python en la configuración del entorno, luego llamará al intérprete correspondiente para completar la operación. Esto es para evitar que el usuario no instale python en la ruta predeterminada ``/usr/bin``.

   .. code-block:: python

       #!/usr/bin/env python3

#. Estas líneas importan las clases y funciones necesarias. ``LED`` de ``gpiozero`` para el control del LED y ``sleep`` de ``time`` para los retrasos.

   .. code-block:: python

       from gpiozero import LED
       from time import sleep

#. Esta línea crea un objeto LED conectado al pin GPIO 17. 

   .. code-block:: python

       # Initialize an LED connected to GPIO pin 17 using the GPIO Zero library.
       led = LED(17)

#. Se inicia un bucle infinito usando ``while True:``. Dentro del bucle, se enciende el LED (``led.on()``) y se imprime un mensaje. El programa luego se pausa durante 0.5 segundos (``sleep(0.5)``). Después de eso, se apaga el LED (``led.off()``), se imprime otro mensaje y el programa se pausa nuevamente durante 0.5 segundos.

    .. code-block:: python

       try:
           # Start an infinite loop to toggle the LED state.
           while True:
               # Turn on the LED and print a message to the console.
               led.on()
               print('...LED ON')

               # Wait for 0.5 seconds with the LED on.
               sleep(0.5)

               # Turn off the LED and print a message to the console.
               led.off()
               print('LED OFF...')

               # Wait for 0.5 seconds with the LED off.
               sleep(0.5)

#. El bloque ``except`` captura una ``KeyboardInterrupt`` (como presionar Ctrl+C) y sale del bucle de manera segura. La declaración ``pass`` se usa aquí como un marcador de posición para indicar que no se toma ninguna acción específica ante la interrupción.

   .. code-block:: python

       except KeyboardInterrupt:
           # Gracefully handle a keyboard interrupt (Ctrl+C) by breaking the loop.
           # GPIO Zero handles cleanup of GPIO settings automatically on exit.
           pass

